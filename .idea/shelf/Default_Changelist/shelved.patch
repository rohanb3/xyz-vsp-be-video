Index: src/services/rooms/CustomersRoom.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* eslint-disable no-param-reassign, class-methods-use-this, no-use-before-define */\nconst socketIOAuth = require('socketio-auth');\n\nconst {\n  CONNECTION,\n  DISCONNECT,\n  CUSTOMERS,\n  ROOM_CREATED,\n} = require('@/constants/rooms');\n\nconst {\n  CALL_REQUESTED,\n  CALL_ENQUEUED,\n  CALL_NOT_ENQUEUED,\n  CALL_ACCEPTED,\n  CALL_FINISHED,\n  CALLBACK_REQUESTED,\n  CALLBACK_ACCEPTED,\n  CALLBACK_DECLINED,\n  PEER_BUSY,\n  CUSTOMER_CONNECTED,\n  CUSTOMER_DISCONNECTED,\n} = require('@/constants/calls');\n\nconst BUSY = 'busy';\n\nconst calls = require('@/services/calls');\n\nconst twilio = require('@/services/twilio');\n\nconst {authenticateCustomer} = require('@/services/socketAuth');\nconst {connectionsHeap} = require('@/services/connectionsHeap');\nconst logger = require('@/services/logger')(module);\n\nconst { repeatUntilDelivered } = require('./utils');\n\nclass CustomersRoom {\n  constructor(io, mediator) {\n    this.customers = io.of(CUSTOMERS);\n    this.customers.on(CONNECTION, this.onCustomerConnected.bind(this));\n\n    this.mediator = mediator;\n\n    socketIOAuth(this.customers, {\n      authenticate: authenticateCustomer,\n      postAuthenticate: this.onCustomerAuthenticated.bind(this),\n    });\n    calls.subscribeToCallAccepting(this.onCallAccepted.bind(this));\n    calls.subscribeToCallFinishing(this.onCallFinished.bind(this));\n    calls.subscribeToCallbackRequesting(\n      this.checkCustomerAndEmitCallbackRequesting.bind(this)\n    );\n  }\n\n  onCustomerConnected(customer) {\n    customer.on(\n      CALL_REQUESTED,\n      this.onCustomerRequestedCall.bind(this, customer)\n    );\n    customer.on(\n      CALL_FINISHED,\n      this.onCustomerFinishedCall.bind(this, customer)\n    );\n    customer.on(DISCONNECT, this.onCustomerDisconnected.bind(this, customer));\n  }\n\n  onCustomerAuthenticated(customer) {\n    logger.debug(\n      'Customer authenticated',\n      customer.id,\n      customer.identity,\n      customer.deviceId\n    );\n    return this.getSocketIdByDeviceId(customer.deviceId)\n      .then(socketId => {\n        const connectedSocket = this.getConnectedCustomer(socketId);\n        const isPreviousConnectionExist =\n          !!connectedSocket &&\n          connectedSocket !== customer &&\n          connectedSocket.id !== customer.id;\n        logger.debug(\n          'Customer isPreviousConnectionExist: ',\n          socketId,\n          isPreviousConnectionExist,\n          !!connectedSocket,\n          connectedSocket !== customer\n        );\n        if (isPreviousConnectionExist) {\n          logger.debug(\n            'Customer previous connection exists: ',\n            connectedSocket.deviceId,\n            connectedSocket.identity\n          );\n          connectedSocket.deviceId = null;\n          connectedSocket.identity = null;\n        }\n      })\n      .finally(() => this.mapDeviceIdToSocketId(customer));\n  }\n\n  onCustomerRequestedCall(customer, data) {\n    const {identity: requestedBy, deviceId} = customer;\n    const {salesRepId, callbackEnabled} = data;\n    const payload = {\n      requestedBy,\n      deviceId,\n      salesRepId,\n      callbackEnabled,\n    };\n    return calls\n      .requestCall(payload)\n      .then(call => {\n        logger.debug('Customer call: added to pending', call);\n        customer.pendingCallId = call.id;\n        customer.emit(CALL_ENQUEUED, call.id);\n      })\n      .catch(err => {\n        logger.error('Customer call: adding to pending failed ', err);\n        customer.emit(CALL_NOT_ENQUEUED);\n      });\n  }\n\n  onCustomerFinishedCall(customer, call) {\n    logger.debug('Call: attempt to finish', call && call.id, customer.identity);\n    return call && call.id\n      ? calls\n        .finishCall(call.id, customer.identity)\n        .then(() => logger.debug('Call: finished by customer', call.id))\n        .catch(err => logger.error('Call: finishing by customer failed', err))\n      : Promise.resolve();\n  }\n\n  onCustomerDisconnected(customer) {\n    logger.debug(\n      'Customer disconnected',\n      customer.identity,\n      customer.pendingCallId\n    );\n    const finishingCallPromise = customer.pendingCallId\n      ? calls.finishCall(customer.pendingCallId, customer.identity)\n      : Promise.resolve();\n\n    return finishingCallPromise\n      .catch(err => {\n        logger.error('Call: finishing by customer failed', err);\n      })\n      .then(() => this.getSocketIdByDeviceId(customer.deviceId))\n      .then(socketId => {\n        logger.debug('Customer disconnection: ', socketId, customer.id);\n      })\n      .finally(() => this.checkAndUnmapDeviceIdFromSocketId(customer));\n  }\n\n  onCallAccepted(call) {\n    const {id, requestedBy, acceptedBy, deviceId} = call;\n    logger.debug(\n      'Customer call: accepted',\n      id,\n      requestedBy,\n      acceptedBy,\n      deviceId\n    );\n    return this.getSocketIdByDeviceId(deviceId)\n      .then(socketId => this.getCustomer(socketId, id, acceptedBy))\n      .then(({connectedCustomer, callData}) => {\n        return repeatUntilDelivered(() =>\n            this.emitCallAccepting(connectedCustomer, callData),\n            next => {\n              connectedCustomer.once(CUSTOMER_CONNECTED, next);\n              return () => connectedCustomer.off(CUSTOMER_CONNECTED, next);\n            }\n          )\n          .catch(error => {\n            this.mediator.emit(CUSTOMER_DISCONNECTED, callData);\n            logger.error(error);\n          })\n\n\n      });\n  }\n\n  onCallFinished(call) {\n    const callFinishedNotByCustomer = call.finishedBy !== call.requestedBy;\n    if (callFinishedNotByCustomer) {\n      this.checkCustomerAndEmitCallFinishing(call);\n    }\n  }\n\n  getCustomer(socketId, callId, operatorId) {\n    const connectedCustomer = this.getConnectedCustomer(socketId);\n    let callData;\n\n    logger.debug(\n      'Checking customer before accept call emit',\n      !!connectedCustomer,\n      socketId,\n      callId,\n      operatorId\n    );\n    if (connectedCustomer) {\n      logger.debug(\n        'Customer call: acception emitted to customer',\n        callId,\n        socketId\n      );\n      connectedCustomer.pendingCallId = null;\n      const token = twilio.getToken(connectedCustomer.deviceId, callId);\n      callData = {\n        roomId: callId,\n        operatorId,\n        token,\n      };\n    }\n    return {connectedCustomer, callData};\n  }\n\n  checkCustomerAndEmitCallbackRequesting(call) {\n    const {deviceId, id, acceptedBy} = call;\n    return this.getSocketIdByDeviceId(deviceId).then(socketId => {\n      const connectedCustomer = this.getConnectedCustomer(socketId);\n      if (connectedCustomer) {\n        logger.debug('Operator callback: emitting to customer', id);\n        this.emitCallbackRequesting(connectedCustomer, {\n          roomId: id,\n          operatorId: acceptedBy,\n        });\n\n        const onCallbackAccepted = () => {\n          connectedCustomer.removeListener(\n            CALLBACK_DECLINED,\n            onCallbackDeclined\n          );\n          calls\n            .acceptCallback(id)\n            .then(() => connectedCustomer.emit(ROOM_CREATED, id))\n            .then(() =>\n              logger.debug(\n                'Operator callback: accepted and emitted to customer'\n              )\n            )\n            .catch(err => {\n              logger.error(\n                'Operator callback: failed accepting or emitting to customer',\n                err\n              );\n            });\n        };\n\n        const onCallbackDeclined = (data = {}) => {\n          const reason = data.message === BUSY ? PEER_BUSY : '';\n          connectedCustomer.removeListener(\n            CALLBACK_ACCEPTED,\n            onCallbackAccepted\n          );\n          calls.declineCallback(id, reason).catch(err => {\n            logger.error('Operator callback: declining failed', err);\n          });\n        };\n\n        connectedCustomer.once(CALLBACK_ACCEPTED, onCallbackAccepted);\n        connectedCustomer.once(CALLBACK_DECLINED, onCallbackDeclined);\n      }\n    });\n  }\n\n  checkCustomerAndEmitCallFinishing(call) {\n    const {deviceId, id} = call;\n    return this.getSocketIdByDeviceId(deviceId).then(socketId => {\n      const connectedCustomer = this.getConnectedCustomer(socketId);\n      if (connectedCustomer) {\n        logger.debug('Call finished: emitting to customer', id, deviceId);\n        this.emitCallFinishing(connectedCustomer, {id});\n      }\n    });\n  }\n\n  emitCallAccepting(customer, callData) {\n    customer.emit(CALL_ACCEPTED, callData);\n  }\n\n  emitCallbackRequesting(customer, callData) {\n    customer.emit(CALLBACK_REQUESTED, callData);\n  }\n\n  emitCallFinishing(customer, data) {\n    customer.emit(CALL_FINISHED, data);\n  }\n\n  mapDeviceIdToSocketId(socket) {\n    logger.debug(\n      'Customer mapDeviceIdToSocketId: ',\n      socket.deviceId,\n      socket.id\n    );\n    return connectionsHeap.add(socket.deviceId, socket.id).catch(err => {\n      logger.error(\n        'Customer: mapDeviceIdToSocketId failed:',\n        socket.deviceId,\n        socket.id,\n        err\n      );\n    });\n  }\n\n  checkAndUnmapDeviceIdFromSocketId(socket) {\n    logger.debug(\n      'Customer checkAndUnmapDeviceIdFromSocketId: ',\n      socket.deviceId\n    );\n    return socket.deviceId\n      ? connectionsHeap\n        .remove(socket.deviceId)\n        .catch(err =>\n          logger.error(\n            'Customer checkAndUnmapDeviceIdFromSocketId failed: ',\n            socket.deviceId,\n            err\n          )\n        )\n      : Promise.resolve();\n  }\n\n  getSocketIdByDeviceId(deviceId) {\n    logger.debug('Customer getSocketIdByDeviceId: ', deviceId);\n    return connectionsHeap\n      .get(deviceId)\n      .catch(err =>\n        logger.error('Customer getSocketIdByDeviceId failed: ', deviceId, err)\n      );\n  }\n\n  getConnectedCustomer(socketId) {\n    return this.customers.connected[socketId];\n  }\n}\n\nmodule.exports = CustomersRoom;\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/services/rooms/CustomersRoom.js	(date 1566483545000)
+++ src/services/rooms/CustomersRoom.js	(date 1566563357000)
@@ -165,9 +165,9 @@
       .then(({connectedCustomer, callData}) => {
         return repeatUntilDelivered(() =>
             this.emitCallAccepting(connectedCustomer, callData),
-            next => {
-              connectedCustomer.once(CUSTOMER_CONNECTED, next);
-              return () => connectedCustomer.off(CUSTOMER_CONNECTED, next);
+            delivered => {
+              connectedCustomer.once(CUSTOMER_CONNECTED, delivered);
+              return () => connectedCustomer.off(CUSTOMER_CONNECTED, delivered);
             }
           )
           .catch(error => {
@@ -188,7 +188,6 @@
 
   getCustomer(socketId, callId, operatorId) {
     const connectedCustomer = this.getConnectedCustomer(socketId);
-    let callData;
 
     logger.debug(
       'Checking customer before accept call emit',
@@ -205,13 +204,14 @@
       );
       connectedCustomer.pendingCallId = null;
       const token = twilio.getToken(connectedCustomer.deviceId, callId);
-      callData = {
+      let callData = {
         roomId: callId,
         operatorId,
         token,
       };
-    }
-    return {connectedCustomer, callData};
+
+      return {connectedCustomer, callData};
+    }
   }
 
   checkCustomerAndEmitCallbackRequesting(call) {
Index: src/public/js/load-testing.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nmodule.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n},{}],2:[function(require,module,exports){\n/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n\n},{}],3:[function(require,module,exports){\n\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n},{}],4:[function(require,module,exports){\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n\n},{}],5:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n},{}],6:[function(require,module,exports){\n/**\r\n * Create a blob builder even when vendor prefixes exist\r\n */\r\n\r\nvar BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\r\n  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :\r\n  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\r\n  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : \r\n  false;\r\n\r\n/**\r\n * Check if Blob constructor is supported\r\n */\r\n\r\nvar blobSupported = (function() {\r\n  try {\r\n    var a = new Blob(['hi']);\r\n    return a.size === 2;\r\n  } catch(e) {\r\n    return false;\r\n  }\r\n})();\r\n\r\n/**\r\n * Check if Blob constructor supports ArrayBufferViews\r\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\r\n */\r\n\r\nvar blobSupportsArrayBufferView = blobSupported && (function() {\r\n  try {\r\n    var b = new Blob([new Uint8Array([1,2])]);\r\n    return b.size === 2;\r\n  } catch(e) {\r\n    return false;\r\n  }\r\n})();\r\n\r\n/**\r\n * Check if BlobBuilder is supported\r\n */\r\n\r\nvar blobBuilderSupported = BlobBuilder\r\n  && BlobBuilder.prototype.append\r\n  && BlobBuilder.prototype.getBlob;\r\n\r\n/**\r\n * Helper function that maps ArrayBufferViews to ArrayBuffers\r\n * Used by BlobBuilder constructor and old browsers that didn't\r\n * support it in the Blob constructor.\r\n */\r\n\r\nfunction mapArrayBufferViews(ary) {\r\n  return ary.map(function(chunk) {\r\n    if (chunk.buffer instanceof ArrayBuffer) {\r\n      var buf = chunk.buffer;\r\n\r\n      // if this is a subarray, make a copy so we only\r\n      // include the subarray region from the underlying buffer\r\n      if (chunk.byteLength !== buf.byteLength) {\r\n        var copy = new Uint8Array(chunk.byteLength);\r\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\r\n        buf = copy.buffer;\r\n      }\r\n\r\n      return buf;\r\n    }\r\n\r\n    return chunk;\r\n  });\r\n}\r\n\r\nfunction BlobBuilderConstructor(ary, options) {\r\n  options = options || {};\r\n\r\n  var bb = new BlobBuilder();\r\n  mapArrayBufferViews(ary).forEach(function(part) {\r\n    bb.append(part);\r\n  });\r\n\r\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\r\n};\r\n\r\nfunction BlobConstructor(ary, options) {\r\n  return new Blob(mapArrayBufferViews(ary), options || {});\r\n};\r\n\r\nif (typeof Blob !== 'undefined') {\r\n  BlobBuilderConstructor.prototype = Blob.prototype;\r\n  BlobConstructor.prototype = Blob.prototype;\r\n}\r\n\r\nmodule.exports = (function() {\r\n  if (blobSupported) {\r\n    return blobSupportsArrayBufferView ? Blob : BlobConstructor;\r\n  } else if (blobBuilderSupported) {\r\n    return BlobBuilderConstructor;\r\n  } else {\r\n    return undefined;\r\n  }\r\n})();\r\n\n},{}],7:[function(require,module,exports){\n\n},{}],8:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n},{\"base64-js\":5,\"ieee754\":28}],9:[function(require,module,exports){\n/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n\n},{}],10:[function(require,module,exports){\n\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n},{}],11:[function(require,module,exports){\n\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};\n},{}],12:[function(require,module,exports){\n\nmodule.exports = require('./socket');\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = require('engine.io-parser');\n\n},{\"./socket\":13,\"engine.io-parser\":23}],13:[function(require,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar transports = require('./transports/index');\nvar Emitter = require('component-emitter');\nvar debug = require('debug')('engine.io-client:socket');\nvar index = require('indexof');\nvar parser = require('engine.io-parser');\nvar parseuri = require('parseuri');\nvar parseqs = require('parseqs');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket (uri, opts) {\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure\n    : (global.location && 'https:' === location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port\n      ? location.port\n      : (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.transportOptions = opts.transportOptions || {};\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.prevBufferLen = 0;\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;\n  this.forceNode = !!opts.forceNode;\n\n  // other options for Node.js client\n  var freeGlobal = typeof global === 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n\n    if (opts.localAddress) {\n      this.localAddress = opts.localAddress;\n    }\n  }\n\n  // set on handshake\n  this.id = null;\n  this.upgrades = null;\n  this.pingInterval = null;\n  this.pingTimeout = null;\n\n  // set on heartbeat\n  this.pingIntervalTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = require('./transport');\nSocket.transports = require('./transports/index');\nSocket.parser = require('engine.io-parser');\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // per-transport options\n  var options = this.transportOptions[name] || {};\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    query: query,\n    socket: this,\n    agent: options.agent || this.agent,\n    hostname: options.hostname || this.hostname,\n    port: options.port || this.port,\n    secure: options.secure || this.secure,\n    path: options.path || this.path,\n    forceJSONP: options.forceJSONP || this.forceJSONP,\n    jsonp: options.jsonp || this.jsonp,\n    forceBase64: options.forceBase64 || this.forceBase64,\n    enablesXDR: options.enablesXDR || this.enablesXDR,\n    timestampRequests: options.timestampRequests || this.timestampRequests,\n    timestampParam: options.timestampParam || this.timestampParam,\n    policyPort: options.policyPort || this.policyPort,\n    pfx: options.pfx || this.pfx,\n    key: options.key || this.key,\n    passphrase: options.passphrase || this.passphrase,\n    cert: options.cert || this.cert,\n    ca: options.ca || this.ca,\n    ciphers: options.ciphers || this.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,\n    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,\n    extraHeaders: options.extraHeaders || this.extraHeaders,\n    forceNode: options.forceNode || this.forceNode,\n    localAddress: options.localAddress || this.localAddress,\n    requestTimeout: options.requestTimeout || this.requestTimeout,\n    protocols: options.protocols || void (0)\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function () {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function () {\n    self.onDrain();\n  })\n  .on('packet', function (packet) {\n    self.onPacket(packet);\n  })\n  .on('error', function (e) {\n    self.onError(e);\n  })\n  .on('close', function () {\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 });\n  var failed = false;\n  var self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen () {\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' === msg.type && 'probe' === msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' === self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport () {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  // Handle any error that happens while probing\n  function onerror (err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose () {\n    onerror('transport closed');\n  }\n\n  // When the socket is closed while we're probing\n  function onclose () {\n    onerror('socket closed');\n  }\n\n  // When the socket is upgraded while we're probing\n  function onupgrade (to) {\n    if (transport && to.name !== transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  // Remove all listeners on the transport and on self\n  function cleanup () {\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' === this.readyState || 'open' === this.readyState ||\n      'closing' === this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(JSON.parse(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if ('closed' === this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' === self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function () {\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function () {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if ('function' === typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function () {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close () {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose () {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade () {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i < j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./transport\":14,\"./transports/index\":15,\"component-emitter\":10,\"debug\":21,\"engine.io-parser\":23,\"indexof\":29,\"parseqs\":33,\"parseuri\":34}],14:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar parser = require('engine.io-parser');\nvar Emitter = require('component-emitter');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n  this.forceNode = opts.forceNode;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n  this.localAddress = opts.localAddress;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' === this.readyState || '' === this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function (packets) {\n  if ('open' === this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n\n},{\"component-emitter\":10,\"engine.io-parser\":23}],15:[function(require,module,exports){\n(function (global){\n/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\nvar XHR = require('./polling-xhr');\nvar JSONP = require('./polling-jsonp');\nvar websocket = require('./websocket');\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname !== location.hostname || port !== opts.port;\n    xs = opts.secure !== isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling-jsonp\":16,\"./polling-xhr\":17,\"./websocket\":19,\"xmlhttprequest-ssl\":20}],16:[function(require,module,exports){\n(function (global){\n\n/**\n * Module requirements.\n */\n\nvar Polling = require('./polling');\nvar inherit = require('component-inherit');\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function (e) {\n    self.onError('jsonp poll error', e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  } else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch (e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function () {\n      if (self.iframe.readyState === 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling\":18,\"component-inherit\":11}],17:[function(require,module,exports){\n(function (global){\n/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\nvar Polling = require('./polling');\nvar Emitter = require('component-emitter');\nvar inherit = require('component-inherit');\nvar debug = require('debug')('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty () {}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR (opts) {\n  Polling.call(this, opts);\n  this.requestTimeout = opts.requestTimeout;\n  this.extraHeaders = opts.extraHeaders;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname !== global.location.hostname ||\n      port !== opts.port;\n    this.xs = opts.secure !== isSSL;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function (opts) {\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  opts.requestTimeout = this.requestTimeout;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function (data, fn) {\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function (err) {\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function () {\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function (data) {\n    self.onData(data);\n  });\n  req.on('error', function (err) {\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request (opts) {\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined !== opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n  this.requestTimeout = opts.requestTimeout;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function () {\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n\n    if ('POST' === this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    try {\n      xhr.setRequestHeader('Accept', '*/*');\n    } catch (e) {}\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.requestTimeout) {\n      xhr.timeout = this.requestTimeout;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function () {\n        self.onLoad();\n      };\n      xhr.onerror = function () {\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 2) {\n          try {\n            var contentType = xhr.getResponseHeader('Content-Type');\n            if (self.supportsBinary && contentType === 'application/octet-stream') {\n              xhr.responseType = 'arraybuffer';\n            }\n          } catch (e) {}\n        }\n        if (4 !== xhr.readyState) return;\n        if (200 === xhr.status || 1223 === xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function () {\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function () {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function () {\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function (data) {\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function (err) {\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function (fromError) {\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch (e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function () {\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type');\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response || this.xhr.responseText;\n    } else {\n      data = this.xhr.responseText;\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function () {\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function () {\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nRequest.requestsCount = 0;\nRequest.requests = {};\n\nif (global.document) {\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler () {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./polling\":18,\"component-emitter\":10,\"component-inherit\":11,\"debug\":21,\"xmlhttprequest-ssl\":20}],18:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parseqs = require('parseqs');\nvar parser = require('engine.io-parser');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function () {\n  var XMLHttpRequest = require('xmlhttprequest-ssl');\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function (onPause) {\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause () {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' === self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' === packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' !== this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' === this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close () {\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' === this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\n     ('http' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n},{\"../transport\":14,\"component-inherit\":11,\"debug\":21,\"engine.io-parser\":23,\"parseqs\":33,\"xmlhttprequest-ssl\":20,\"yeast\":49}],19:[function(require,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\nvar NodeWebSocket;\nif (typeof window === 'undefined') {\n  try {\n    NodeWebSocket = require('ws');\n  } catch (e) { }\n}\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  WebSocket = NodeWebSocket;\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  this.protocols = opts.protocols;\n  if (!this.usingBrowserWebSocket) {\n    WebSocket = NodeWebSocket;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = this.protocols;\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done () {\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n    ('ws' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../transport\":14,\"component-inherit\":11,\"debug\":21,\"engine.io-parser\":23,\"parseqs\":33,\"ws\":7,\"yeast\":49}],20:[function(require,module,exports){\n(function (global){\n// browser shim for xmlhttprequest module\n\nvar hasCORS = require('has-cors');\n\nmodule.exports = function (opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');\n    } catch (e) { }\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"has-cors\":27}],21:[function(require,module,exports){\n(function (process){\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n}).call(this,require('_process'))\n},{\"./debug\":22,\"_process\":35}],22:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":32}],23:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary2');\nvar sliceBuffer = require('arraybuffer.slice');\nvar after = require('after');\nvar utf8 = require('./utf8');\n\nvar base64encoder;\nif (typeof ArrayBuffer !== 'undefined') {\n  base64encoder = require('base64-arraybuffer');\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data === 'string') {\n    if (data.charAt(0) === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, { strict: false });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '', n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || (length != (n = Number(length)))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var ret = callback(packet, i + n, l);\n      if (false === ret) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] === 255) break;\n\n      // 310 = char length of Number.MAX_VALUE\n      if (msgLength.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n},{\"./keys\":24,\"./utf8\":25,\"after\":1,\"arraybuffer.slice\":2,\"base64-arraybuffer\":4,\"blob\":6,\"has-binary2\":26}],24:[function(require,module,exports){\n\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n},{}],25:[function(require,module,exports){\n/*! https://mths.be/utf8js v2.1.2 by @mathias */\n\nvar stringFromCharCode = String.fromCharCode;\n\n// Taken from https://mths.be/punycode\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\tvar value;\n\tvar extra;\n\twhile (counter < length) {\n\t\tvalue = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// high surrogate, and there is a next character\n\t\t\textra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n// Taken from https://mths.be/punycode\nfunction ucs2encode(array) {\n\tvar length = array.length;\n\tvar index = -1;\n\tvar value;\n\tvar output = '';\n\twhile (++index < length) {\n\t\tvalue = array[index];\n\t\tif (value > 0xFFFF) {\n\t\t\tvalue -= 0x10000;\n\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(value);\n\t}\n\treturn output;\n}\n\nfunction checkScalarValue(codePoint, strict) {\n\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\tif (strict) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n/*--------------------------------------------------------------------------*/\n\nfunction createByte(codePoint, shift) {\n\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n}\n\nfunction encodeCodePoint(codePoint, strict) {\n\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\treturn stringFromCharCode(codePoint);\n\t}\n\tvar symbol = '';\n\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t}\n\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\tif (!checkScalarValue(codePoint, strict)) {\n\t\t\tcodePoint = 0xFFFD;\n\t\t}\n\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\tsymbol += createByte(codePoint, 6);\n\t}\n\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\tsymbol += createByte(codePoint, 12);\n\t\tsymbol += createByte(codePoint, 6);\n\t}\n\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\treturn symbol;\n}\n\nfunction utf8encode(string, opts) {\n\topts = opts || {};\n\tvar strict = false !== opts.strict;\n\n\tvar codePoints = ucs2decode(string);\n\tvar length = codePoints.length;\n\tvar index = -1;\n\tvar codePoint;\n\tvar byteString = '';\n\twhile (++index < length) {\n\t\tcodePoint = codePoints[index];\n\t\tbyteString += encodeCodePoint(codePoint, strict);\n\t}\n\treturn byteString;\n}\n\n/*--------------------------------------------------------------------------*/\n\nfunction readContinuationByte() {\n\tif (byteIndex >= byteCount) {\n\t\tthrow Error('Invalid byte index');\n\t}\n\n\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\tbyteIndex++;\n\n\tif ((continuationByte & 0xC0) == 0x80) {\n\t\treturn continuationByte & 0x3F;\n\t}\n\n\t// If we end up here, it’s not a continuation byte\n\tthrow Error('Invalid continuation byte');\n}\n\nfunction decodeSymbol(strict) {\n\tvar byte1;\n\tvar byte2;\n\tvar byte3;\n\tvar byte4;\n\tvar codePoint;\n\n\tif (byteIndex > byteCount) {\n\t\tthrow Error('Invalid byte index');\n\t}\n\n\tif (byteIndex == byteCount) {\n\t\treturn false;\n\t}\n\n\t// Read first byte\n\tbyte1 = byteArray[byteIndex] & 0xFF;\n\tbyteIndex++;\n\n\t// 1-byte sequence (no continuation bytes)\n\tif ((byte1 & 0x80) == 0) {\n\t\treturn byte1;\n\t}\n\n\t// 2-byte sequence\n\tif ((byte1 & 0xE0) == 0xC0) {\n\t\tbyte2 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\tif (codePoint >= 0x80) {\n\t\t\treturn codePoint;\n\t\t} else {\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t}\n\n\t// 3-byte sequence (may include unpaired surrogates)\n\tif ((byte1 & 0xF0) == 0xE0) {\n\t\tbyte2 = readContinuationByte();\n\t\tbyte3 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\tif (codePoint >= 0x0800) {\n\t\t\treturn checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n\t\t} else {\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t}\n\n\t// 4-byte sequence\n\tif ((byte1 & 0xF8) == 0xF0) {\n\t\tbyte2 = readContinuationByte();\n\t\tbyte3 = readContinuationByte();\n\t\tbyte4 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t(byte3 << 0x06) | byte4;\n\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\treturn codePoint;\n\t\t}\n\t}\n\n\tthrow Error('Invalid UTF-8 detected');\n}\n\nvar byteArray;\nvar byteCount;\nvar byteIndex;\nfunction utf8decode(byteString, opts) {\n\topts = opts || {};\n\tvar strict = false !== opts.strict;\n\n\tbyteArray = ucs2decode(byteString);\n\tbyteCount = byteArray.length;\n\tbyteIndex = 0;\n\tvar codePoints = [];\n\tvar tmp;\n\twhile ((tmp = decodeSymbol(strict)) !== false) {\n\t\tcodePoints.push(tmp);\n\t}\n\treturn ucs2encode(codePoints);\n}\n\nmodule.exports = {\n\tversion: '2.1.2',\n\tencode: utf8encode,\n\tdecode: utf8decode\n};\n\n},{}],26:[function(require,module,exports){\n(function (Buffer){\n/* global Blob File */\n\n/*\n * Module requirements.\n */\n\nvar isArray = require('isarray');\n\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof Blob === 'function' ||\n                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof File === 'function' ||\n                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Supports Buffer, ArrayBuffer, Blob and File.\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary (obj) {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n\n  if (isArray(obj)) {\n    for (var i = 0, l = obj.length; i < l; i++) {\n      if (hasBinary(obj[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||\n    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||\n    (withNativeBlob && obj instanceof Blob) ||\n    (withNativeFile && obj instanceof File)\n  ) {\n    return true;\n  }\n\n  // see: https://github.com/Automattic/has-binary/pull/4\n  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {\n    return hasBinary(obj.toJSON(), true);\n  }\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":8,\"isarray\":30}],27:[function(require,module,exports){\n\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n    'withCredentials' in new XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n\n},{}],28:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],29:[function(require,module,exports){\n\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n},{}],30:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],31:[function(require,module,exports){\n//! moment.js\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return (Object.getOwnPropertyNames(obj).length === 0);\n        } else {\n            var k;\n            for (k in obj) {\n                if (obj.hasOwnProperty(k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false,\n            parsedDateParts : [],\n            meridiem        : null,\n            rfc2822         : false,\n            weekdayMismatch : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            var isNowValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            }\n            else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n                (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [];\n                var arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n                            arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (isFunction(prop)) {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig, prop) &&\n                    !hasOwnProp(childConfig, prop) &&\n                    isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (isFunction(output)) ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit: u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '', i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n    var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK = 7;\n    var WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? '' + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit) {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            }\n            else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet (units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months :\n                this._months['standalone'];\n        }\n        return isArray(this._months) ? this._months[m.month()] :\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n    function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n    function createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m, format) {\n        if (!m) {\n            return isArray(this._weekdays) ? this._weekdays :\n                this._weekdays['standalone'];\n        }\n        return isArray(this._weekdays) ? this._weekdays[m.day()] :\n            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n            shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom, '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n\n    // internal storage for locale config files\n    var locales = {};\n    var localeFamilies = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && (typeof module !== 'undefined') &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                var aliasedRequire = require;\n                aliasedRequire('./locale/' + name);\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {}\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n            else {\n                if ((typeof console !==  'undefined') && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n                        'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            // MERGE\n            tmpLocale = loadLocale(name);\n            if (tmpLocale != null) {\n                parentConfig = tmpLocale._config;\n            }\n            config = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n            locale.parentLocale = locales[name];\n            locales[name] = locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat, tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10);\n            var m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\n        if (match) {\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            // console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex', getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        }  else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input) && isObjectEmpty(input)) ||\n                (isArray(input) && input.length === 0)) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other < this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other > this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m) {\n        for (var key in m) {\n            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n\n        var unitHasDecimal = false;\n        for (var i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound (number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // FORMATTING\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher);\n\n        if (matches === null) {\n            return null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ?\n          0 :\n          parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            }\n            else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (isNumber(input)) {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (match = aspNetRegex.exec(input)) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])                         * sign,\n                h  : toInt(match[HOUR])                         * sign,\n                m  : toInt(match[MINUTE])                       * sign,\n                s  : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n        } else if (match = isoRegex.exec(input)) {\n            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4], sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6], sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n    function calendar$1 (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n        inclusivity = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n    }\n\n    function isSame (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n    function isSameOrAfter (input, units) {\n        return this.isSame(input, units) || this.isAfter(input,units);\n    }\n\n    function isSameOrBefore (input, units) {\n        return this.isSame(input, units) || this.isBefore(input,units);\n    }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n            output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year': output = monthDiff(this, that) / 12; break;\n            case 'month': output = monthDiff(this, that); break;\n            case 'quarter': output = monthDiff(this, that) / 3; break;\n            case 'second': output = (this - that) / 1e3; break; // 1000\n            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default: output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true;\n        var m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect () {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n        var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        var suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n            case 'year':\n                this.month(0);\n                /* falls through */\n            case 'quarter':\n            case 'month':\n                this.date(1);\n                /* falls through */\n            case 'week':\n            case 'isoWeek':\n            case 'day':\n            case 'date':\n                this.hours(0);\n                /* falls through */\n            case 'hour':\n                this.minutes(0);\n                /* falls through */\n            case 'minute':\n                this.seconds(0);\n                /* falls through */\n            case 'second':\n                this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n\n        // 'date' is an alias for 'day', so it should be considered as such.\n        if (units === 'date') {\n            units = 'day';\n        }\n\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function valueOf () {\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2 () {\n        return isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input,\n                this.week(),\n                this.weekday(),\n                this.localeData()._week.dow,\n                this.localeData()._week.doy);\n    }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n          locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add               = add;\n    proto.calendar          = calendar$1;\n    proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf             = endOf;\n    proto.format            = format;\n    proto.from              = from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n    proto.toNow             = toNow;\n    proto.get               = stringGet;\n    proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n    proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n    proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n    proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n    proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData        = localeData;\n    proto.max               = prototypeMax;\n    proto.min               = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n    proto.set               = stringSet;\n    proto.startOf           = startOf;\n    proto.subtract          = subtract;\n    proto.toArray           = toArray;\n    proto.toObject          = toObject;\n    proto.toDate            = toDate;\n    proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n    proto.toJSON            = toJSON;\n    proto.toString          = toString;\n    proto.unix              = unix;\n    proto.valueOf           = valueOf;\n    proto.creationData      = creationData;\n    proto.year       = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear    = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month       = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week           = proto.weeks        = getSetWeek;\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear    = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.date       = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n    proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear  = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset            = getSetOffset;\n    proto.utc                  = setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone            = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              = isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                = isUtc;\n    proto.isUTC                = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n    proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n    proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      = preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture      = pastFuture;\n    proto$1.set             = set;\n\n    proto$1.months            =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n    proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex       = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays       =        localeWeekdays;\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n    proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl (localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n    var mathAbs = Math.abs;\n\n    function abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function clone$1 () {\n        return createDuration(this);\n    }\n\n    function get$2 (units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        ss: 44,         // a few seconds to seconds\n        s : 45,         // seconds to minute\n        m : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d : 26,         // days to month\n        M : 11          // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n        var duration = createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n                seconds < thresholds.s   && ['ss', seconds] ||\n                minutes <= 1             && ['m']           ||\n                minutes < thresholds.m   && ['mm', minutes] ||\n                hours   <= 1             && ['h']           ||\n                hours   < thresholds.h   && ['hh', hours]   ||\n                days    <= 1             && ['d']           ||\n                days    < thresholds.d   && ['dd', days]    ||\n                months  <= 1             && ['M']           ||\n                months  < thresholds.M   && ['MM', months]  ||\n                years   <= 1             && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding (roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof(roundingFunction) === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n        var output = relativeTime$1(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return ((x > 0) - (x < 0)) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000;\n        var days         = abs$1(this._days);\n        var months       = abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        var totalSign = total < 0 ? '-' : '';\n        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return totalSign + 'P' +\n            (Y ? ymSign + Y + 'Y' : '') +\n            (M ? ymSign + M + 'M' : '') +\n            (D ? daysSign + D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? hmsSign + h + 'H' : '') +\n            (m ? hmsSign + m + 'M' : '') +\n            (s ? hmsSign + s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid        = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            = add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      = asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        = asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n    proto$2.asMonths       = asMonths;\n    proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n    proto$2._bubble        = bubble;\n    proto$2.clone          = clone$1;\n    proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n    proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n    proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks          = weeks;\n    proto$2.months         = months;\n    proto$2.years          = years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n    proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n    proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n    // Side effect imports\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    hooks.version = '2.22.2';\n\n    setHookCallback(createLocal);\n\n    hooks.fn                    = proto;\n    hooks.min                   = min;\n    hooks.max                   = max;\n    hooks.now                   = now;\n    hooks.utc                   = createUTC;\n    hooks.unix                  = createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                = isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid               = createInvalid;\n    hooks.duration              = createDuration;\n    hooks.isMoment              = isMoment;\n    hooks.weekdays              = listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData            = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort           = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n    hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          = updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort         = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n    hooks.prototype             = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n        TIME: 'HH:mm',                                  // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'YYYY-[W]WW',                             // <input type=\"week\" />\n        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n\n},{}],32:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],33:[function(require,module,exports){\n/**\r\n * Compiles a querystring\r\n * Returns string representation of the object\r\n *\r\n * @param {Object}\r\n * @api private\r\n */\r\n\r\nexports.encode = function (obj) {\r\n  var str = '';\r\n\r\n  for (var i in obj) {\r\n    if (obj.hasOwnProperty(i)) {\r\n      if (str.length) str += '&';\r\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\r\n    }\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n/**\r\n * Parses a simple querystring into an object\r\n *\r\n * @param {String} qs\r\n * @api private\r\n */\r\n\r\nexports.decode = function(qs){\r\n  var qry = {};\r\n  var pairs = qs.split('&');\r\n  for (var i = 0, l = pairs.length; i < l; i++) {\r\n    var pair = pairs[i].split('=');\r\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n  }\r\n  return qry;\r\n};\r\n\n},{}],34:[function(require,module,exports){\n/**\r\n * Parses an URI\r\n *\r\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n * @api private\r\n */\r\n\r\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\nvar parts = [\r\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\r\n];\r\n\r\nmodule.exports = function parseuri(str) {\r\n    var src = str,\r\n        b = str.indexOf('['),\r\n        e = str.indexOf(']');\r\n\r\n    if (b != -1 && e != -1) {\r\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\r\n    }\r\n\r\n    var m = re.exec(str || ''),\r\n        uri = {},\r\n        i = 14;\r\n\r\n    while (i--) {\r\n        uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    if (b != -1 && e != -1) {\r\n        uri.source = src;\r\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\r\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\r\n        uri.ipv6uri = true;\r\n    }\r\n\r\n    return uri;\r\n};\r\n\n},{}],35:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],36:[function(require,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar url = require('./url');\nvar parser = require('socket.io-parser');\nvar Manager = require('./manager');\nvar debug = require('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  }\n  return io.socket(parsed.path, opts);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');\n\n},{\"./manager\":37,\"./socket\":39,\"./url\":40,\"debug\":41,\"socket.io-parser\":44}],37:[function(require,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar eio = require('engine.io-client');\nvar Socket = require('./socket');\nvar Emitter = require('component-emitter');\nvar parser = require('socket.io-parser');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:manager');\nvar indexOf = require('indexof');\nvar Backoff = require('backo2');\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  var _parser = opts.parser || parser;\n  this.encoder = new _parser.Encoder();\n  this.decoder = new _parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.generateId(nsp);\n    }\n  }\n};\n\n/**\n * generate `socket.id` for the given `nsp`\n *\n * @param {String} nsp\n * @return {String}\n * @api private\n */\n\nManager.prototype.generateId = function (nsp) {\n  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.generateId(nsp);\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting event is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n\n},{\"./on\":38,\"./socket\":39,\"backo2\":3,\"component-bind\":9,\"component-emitter\":10,\"debug\":41,\"engine.io-client\":12,\"indexof\":29,\"socket.io-parser\":44}],38:[function(require,module,exports){\n\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on (obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function () {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n\n},{}],39:[function(require,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar parser = require('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar toArray = require('to-array');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:socket');\nvar parseqs = require('parseqs');\nvar hasBin = require('has-binary2');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket (io, nsp, opts) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  this.flags = {};\n  if (opts && opts.query) {\n    this.query = opts.query;\n  }\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function () {\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' === this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var packet = {\n    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,\n    data: args\n  };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' === typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  this.flags = {};\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' !== this.nsp) {\n    if (this.query) {\n      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;\n      debug('sending connect packet with query %s', query);\n      this.packet({type: parser.CONNECT, query: query});\n    } else {\n      this.packet({type: parser.CONNECT});\n    }\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function (packet) {\n  var sameNamespace = packet.nsp === this.nsp;\n  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';\n\n  if (!sameNamespace && !rootNamespaceError) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    self.packet({\n      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n  if ('function' === typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function (compress) {\n  this.flags.compress = compress;\n  return this;\n};\n\n/**\n * Sets the binary flag\n *\n * @param {Boolean} whether the emitted data contains binary\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.binary = function (binary) {\n  this.flags.binary = binary;\n  return this;\n};\n\n},{\"./on\":38,\"component-bind\":9,\"component-emitter\":10,\"debug\":41,\"has-binary2\":26,\"parseqs\":33,\"socket.io-parser\":44,\"to-array\":48}],40:[function(require,module,exports){\n(function (global){\n\n/**\n * Module dependencies.\n */\n\nvar parseuri = require('parseuri');\nvar debug = require('debug')('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url (uri, loc) {\n  var obj = uri;\n\n  // default to window.location\n  loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' === typeof uri) {\n    if ('/' === uri.charAt(0)) {\n      if ('/' === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' !== typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"debug\":41,\"parseuri\":34}],41:[function(require,module,exports){\narguments[4][21][0].apply(exports,arguments)\n},{\"./debug\":42,\"_process\":35,\"dup\":21}],42:[function(require,module,exports){\narguments[4][22][0].apply(exports,arguments)\n},{\"dup\":22,\"ms\":32}],43:[function(require,module,exports){\n(function (global){\n/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBuf(data)) {\n    var placeholder = { _placeholder: true, num: buffers.length };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n    return newData;\n  }\n  return data;\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder) {\n    return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n\n  return data;\n}\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./is-buffer\":45,\"isarray\":30}],44:[function(require,module,exports){\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    var payload = tryStringify(obj.data);\n    if (payload !== false) {\n      str += payload;\n    } else {\n      return ERROR_PACKET;\n    }\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\nfunction tryStringify(str) {\n  try {\n    return JSON.stringify(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var buf = '';\n    while (str.charAt(++i) !== '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      p.nsp += c;\n      if (i === str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i === str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n\n},{\"./binary\":43,\"./is-buffer\":45,\"component-emitter\":10,\"debug\":46,\"isarray\":30}],45:[function(require,module,exports){\n(function (global){\n\nmodule.exports = isBuf;\n\nvar withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';\nvar withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';\n\nvar isView = (function () {\n  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {\n    return global.ArrayBuffer.isView;\n  } else {\n    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };\n  }\n})();\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||\n          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],46:[function(require,module,exports){\narguments[4][21][0].apply(exports,arguments)\n},{\"./debug\":47,\"_process\":35,\"dup\":21}],47:[function(require,module,exports){\narguments[4][22][0].apply(exports,arguments)\n},{\"dup\":22,\"ms\":32}],48:[function(require,module,exports){\nmodule.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n\n},{}],49:[function(require,module,exports){\n'use strict';\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;\n\n},{}],50:[function(require,module,exports){\n/* eslint-disable no-console */\nconst io = require('socket.io-client');\n\nconst { SOCKET_EVENTS, TYPES, FIELDS } = require('./src/constants');\nconst { getDefaultStatistics, getField, setField } = require('./src/utils');\nconst {\n  drawCustomersFrames,\n  drawOperatorsFrames,\n} = require('./src/userDrawers');\nconst {\n  drawStatisitics,\n  drawQueueStatisticsField,\n} = require('./src/statisticsDrawers');\nconst {\n  init: initUserStatistics,\n  ...userStatistics\n} = require('./src/usersStatistics');\n\nconst isLocal = typeof window.prompt('Is local?') === 'string';\nconst now = Date.now();\nconst socketUrl = '/operators';\nconst socketOptions = { transports: ['websocket'] };\n\nif (!isLocal) {\n  socketOptions.path = '/api/video/socket.io';\n}\n\nconst identity = `${now}-operator-0`;\nconst socket = io(socketUrl, socketOptions);\n\nlet isStarted = false;\nlet callsStatisticsOpened = false;\nlet legendOpened = false;\n\nlet statistics = getDefaultStatistics();\n\nconst statisticsCallbacks = {\n  onUserConnected: (...args) =>\n    userStatistics.onUserConnected(...args, statistics),\n  onUserAuthorized: (...args) =>\n    userStatistics.onUserAuthorized(...args, statistics),\n  incrementConnectingUsers: (...args) =>\n    userStatistics.incrementConnectingUsers(...args, statistics),\n  decrementConnectingUsers: (...args) =>\n    userStatistics.decrementConnectingUsers(...args, statistics),\n  incrementConnectedUsers: (...args) =>\n    userStatistics.incrementConnectedUsers(...args, statistics),\n  decrementConnectedUsers: (...args) =>\n    userStatistics.decrementConnectedUsers(...args, statistics),\n  incrementAuthorizingUsers: (...args) =>\n    userStatistics.incrementAuthorizingUsers(...args, statistics),\n  decrementAuthorizingUsers: (...args) =>\n    userStatistics.decrementAuthorizingUsers(...args, statistics),\n  incrementAuthenticatedUsers: (...args) =>\n    userStatistics.incrementAuthenticatedUsers(...args, statistics),\n  incrementUnauthorizedUsers: (...args) =>\n    userStatistics.incrementUnauthorizedUsers(...args, statistics),\n  incrementWaitingForQueueCalls: (...args) =>\n    userStatistics.incrementWaitingForQueueCalls(...args, statistics),\n  decrementWaitingForQueueCalls: (...args) =>\n    userStatistics.decrementWaitingForQueueCalls(...args, statistics),\n  incrementNotEnqueuedCalls: (...args) =>\n    userStatistics.incrementNotEnqueuedCalls(...args, statistics),\n  incrementPendingCalls: (...args) =>\n    userStatistics.incrementPendingCalls(...args, statistics),\n  decrementPendingCalls: (...args) =>\n    userStatistics.decrementPendingCalls(...args, statistics),\n  incrementActiveCalls: (...args) =>\n    userStatistics.incrementActiveCalls(...args, statistics),\n  decrementActiveCalls: (...args) =>\n    userStatistics.decrementActiveCalls(...args, statistics),\n  incrementFinishedCalls: (...args) =>\n    userStatistics.incrementFinishedCalls(...args, statistics),\n  incrementMissedCalls: (...args) =>\n    userStatistics.incrementMissedCalls(...args, statistics),\n  onCallEnqueued: (...args) =>\n    userStatistics.onCallEnqueued(...args, statistics),\n  onCallAcceptionByOperatorHandled: (...args) =>\n    userStatistics.onCallAcceptionByOperatorHandled(...args, statistics),\n  onCustomerCallAccepted: (...args) =>\n    userStatistics.onCustomerCallAccepted(...args, statistics),\n  updateCallDurationTime: (...args) =>\n    userStatistics.updateCallDurationTime(...args, statistics),\n  incrementOperatorsAcceptedCalls: (...args) =>\n    userStatistics.incrementOperatorsAcceptedCalls(...args, statistics),\n};\n\nlet totalCallsForTest = 0;\n\nwindow.statisticsCallbacks = statisticsCallbacks;\n\nsubscribeToControls();\n\nsocket.on(SOCKET_EVENTS.CONNECT, () => {\n  socket.emit(SOCKET_EVENTS.AUTHENTICATION, { identity });\n  socket.on(SOCKET_EVENTS.AUTHENTICATED, onAuthenticated);\n  socket.on(SOCKET_EVENTS.UNAUTHORIZED, onUnauthorized);\n});\n\nfunction onAuthenticated() {\n  socket.on(SOCKET_EVENTS.CALLS_CHANGED, onCallsChanged);\n}\n\nfunction onUnauthorized() {}\n\nfunction onCallsChanged({ size = 0, peak } = {}) {\n  const prevMaxInQueue = getField(statistics, TYPES.QUEUE, FIELDS.MAX_IN_QUEUE);\n\n  setField(statistics, TYPES.QUEUE, FIELDS.PENDING_IN_QUEUE, size);\n  drawQueueStatisticsField(FIELDS.PENDING_IN_QUEUE, statistics);\n  if (peak && peak.requestedAt) {\n    setField(statistics, TYPES.QUEUE, FIELDS.OLDEST_IN_QUEUE, peak.requestedAt);\n    drawQueueStatisticsField(FIELDS.OLDEST_IN_QUEUE, statistics);\n  }\n\n  if (size > prevMaxInQueue) {\n    setField(statistics, TYPES.QUEUE, FIELDS.MAX_IN_QUEUE, size);\n    drawQueueStatisticsField(FIELDS.MAX_IN_QUEUE, statistics);\n  }\n}\n\nfunction subscribeToControls() {\n  document.querySelector('.start-button').addEventListener('click', startTest);\n  document.querySelector('.clear-button').addEventListener('click', clearTest);\n  document\n    .querySelector('.all-calls-toggler')\n    .addEventListener('click', toggleCalls);\n  document\n    .querySelector('.legend-toggler')\n    .addEventListener('click', toggleLegend);\n}\n\nfunction startTest() {\n  if (!isStarted) {\n    isStarted = true;\n    disableActionButtons();\n    preparePage();\n    initUserStatistics(totalCallsForTest, enableActionButtons);\n  } else {\n    window.alert('Test is running! Please, stop it before');\n  }\n}\n\nfunction clearTest() {\n  isStarted = false;\n  removeUsers();\n  resetStatistics();\n  removeCalls();\n  enableActionButtons();\n}\n\nfunction toggleCalls() {\n  document.querySelector('.all-calls-statistics').classList.toggle('opened');\n  const toggler = document.querySelector(\n    '.all-calls-statistics .all-calls-toggler'\n  );\n  callsStatisticsOpened = !callsStatisticsOpened;\n  toggler.innerHTML = callsStatisticsOpened ? '&#8250;' : '&#8249;';\n}\n\nfunction toggleLegend() {\n  document\n    .querySelector('.users-connection-colors-legend')\n    .classList.toggle('opened');\n  const toggler = document.querySelector(\n    '.users-connection-colors-legend .legend-toggler'\n  );\n  legendOpened = !legendOpened;\n  toggler.innerHTML = legendOpened ? '&#8249;' : '&#8250;';\n}\n\nfunction enableActionButtons() {\n  document.querySelector('.start-button').disabled = false;\n  document.querySelector('.clear-button').disabled = false;\n}\n\nfunction disableActionButtons() {\n  document.querySelector('.start-button').disabled = true;\n  document.querySelector('.clear-button').disabled = true;\n}\n\nfunction resetStatistics() {\n  if (!isStarted) {\n    statistics = getDefaultStatistics();\n    drawStatisitics(statistics);\n  } else {\n    window.alert('Test is running! Please, stop it before');\n  }\n}\n\nfunction preparePage() {\n  const minCallDuration =\n    (Number(document.querySelector('.min-call-duration').value) || 3) * 1000;\n  const maxCallDuration =\n    (Number(document.querySelector('.max-call-duration').value) || 5) * 1000;\n  const connectionDelay =\n    (Number(document.querySelector('.connection-delay').value) || 0.1) * 1000;\n  const operatorsNumber =\n    Number(document.querySelector('.operators-amount').value) || 50;\n\n  prepareCustomers(\n    minCallDuration,\n    maxCallDuration,\n    connectionDelay,\n    operatorsNumber\n  );\n  prepareOperators(\n    minCallDuration,\n    maxCallDuration,\n    connectionDelay,\n    operatorsNumber\n  );\n  drawStatisitics(statistics);\n}\n\nfunction prepareCustomers(\n  minCallDuration,\n  maxCallDuration,\n  connectionDelay,\n  operatorsNumber\n) {\n  const customersNumber =\n    Number(document.querySelector('.customers-amount').value) || 200;\n  const callsPerCustomer =\n    Number(document.querySelector('.calls-per-customer').value) || 1;\n  const maxFirstCallDelay =\n    Number(document.querySelector('.max-first-call-delay').value) * 1000;\n\n  setField(statistics, TYPES.CUSTOMERS, FIELDS.TOTAL, customersNumber);\n\n  totalCallsForTest = customersNumber * callsPerCustomer;\n\n  const options = {\n    io,\n    customersNumber,\n    operatorsNumber,\n    callsPerCustomer,\n    minCallDuration,\n    maxCallDuration,\n    connectionDelay,\n    maxFirstCallDelay,\n    socketOptions,\n    now,\n  };\n\n  drawCustomersFrames(options);\n}\n\nfunction prepareOperators(\n  minCallDuration,\n  maxCallDuration,\n  connectionDelay,\n  operatorsNumber\n) {\n  const acceptingLikelihood =\n    (Number(document.querySelector('.operator-accepting-likelihood').value) ||\n      20) / 100;\n\n  const options = {\n    io,\n    operatorsNumber,\n    minCallDuration,\n    maxCallDuration,\n    connectionDelay,\n    acceptingLikelihood,\n    socketOptions,\n    now,\n  };\n\n  setField(statistics, TYPES.OPERATORS, FIELDS.TOTAL, operatorsNumber);\n  drawOperatorsFrames(options);\n}\n\nfunction removeUsers() {\n  removeFrames('.customers-section');\n  removeFrames('.operators-section');\n}\n\nfunction removeCalls() {\n  document.querySelector('.all-calls-statistics .all-calls').innerHTML = '';\n}\n\nfunction removeFrames(selector) {\n  const iframes = document.querySelectorAll(`${selector} iframe`);\n  for (var i = 0; i < iframes.length; i++) {\n    iframes[i].contentWindow.disconnectFromSocket();\n    iframes[i].parentNode.removeChild(iframes[i]);\n  }\n}\n\nfunction disconnectFromSocket() {\n  if (socket) {\n    socket.disconnect();\n  }\n}\n\nwindow.addEventListener('beforeunload', disconnectFromSocket);\n\n},{\"./src/constants\":51,\"./src/statisticsDrawers\":52,\"./src/userDrawers\":53,\"./src/usersStatistics\":54,\"./src/utils\":55,\"socket.io-client\":36}],51:[function(require,module,exports){\nconst QUEUE = 'queue';\nconst CUSTOMERS = 'customers';\nconst OPERATORS = 'operators';\nconst CALLS = 'calls';\nconst TOTAL = 'total';\nconst CONNECTING = 'connecting';\nconst CONNECTED = 'connected';\nconst AUTHORIZING = 'authorizing';\nconst AUTHENTICATED = 'authenticated';\nconst UNAUTHORIZED = 'unauthorized';\nconst WAITING_FOR_QUEUE_CALLS = 'waitingForQueueCalls';\nconst PENDING_CALLS = 'pendingCalls';\nconst NOT_ENQUEUED_CALLS = 'notEnqueuedCalls';\nconst ACTIVE_CALLS = 'activeCalls';\nconst MAX_ACTIVE_CALLS = 'maxActiveCalls';\nconst FINISHED_CALLS = 'finishedCalls';\nconst MISSED_CALLS = 'missedCalls';\nconst TOTAL_CALLS = 'totalCalls';\nconst PENDING_IN_QUEUE = 'pendingInQueue';\nconst OLDEST_IN_QUEUE = 'oldestInQueue';\nconst MIN_ENQUEUEING_TIME = 'minEnqueueingTime';\nconst MAX_ENQUEUEING_TIME = 'maxEnqueueingTime';\nconst AVERAGE_ENQUEUEING_TIME = 'averageEnqueueingTime';\nconst MIN_ACCEPTING_TIME = 'minAcceptingTime';\nconst MAX_ACCEPTING_TIME = 'maxAcceptingTime';\nconst AVERAGE_ACCEPTING_TIME = 'averageAcceptingTime';\nconst MIN_DURATION = 'minDuration';\nconst MAX_DURATION = 'maxDuration';\nconst AVERAGE_DURATION = 'averageDuration';\nconst TOTAL_DURATION = 'totalDuration';\nconst MAX_IN_QUEUE = 'maxInQueue';\nconst REQUESTED_AT = 'requestedAt';\nconst ENQUEUED_AT = 'enqueuedAt';\nconst ACCEPTED_AT = 'acceptedAt';\nconst ACCEPTED_AT_RAW = 'acceptedAtRaw';\nconst ENQUEUED_IN = 'enqueuedIn';\nconst WRAPPING_UP_CUSTOMER = 'wrappingUpCustomer';\nconst WRAPPING_UP_OPERATOR = 'wrappingUpOperator';\nconst READY_FOR_CUSTOMER_AT = 'readyForCustomerAt';\nconst READY_FOR_CUSTOMER_AT_RAW = 'readyForCustomerAtRaw';\nconst READY_FOR_OPERATOR_AT = 'readyForOperatorAt';\nconst CONNECTION_TO_CALL_CUSTOMER = 'connectionToCallCustomer';\nconst CONNECTION_TO_CALL_OPERATOR = 'connectionToCallOperator';\nconst MIN_CONNECTING_TIME = 'minConnectingTime';\nconst MAX_CONNECTING_TIME = 'maxConnectingTime';\nconst AVERAGE_CONNECTING_TIME = 'averageConnectingTime';\nconst MIN_AUTHORIZING_TIME = 'minAuthorizingTime';\nconst MAX_AUTHORIZING_TIME = 'maxAuthorizingTime';\nconst AVERAGE_AUTHORIZING_TIME = 'averageAuthorizingTime';\nconst TOTAL_CONNECTING_TIME = 'totalConnectingTime';\nconst TOTAL_AUTHORIZING_TIME = 'totalAuthorizingTime';\nconst MIN_CONNECTING_TO_CALL_TIME = 'minConnectingToCallTime';\nconst MAX_CONNECTING_TO_CALL_TIME = 'maxConnectingToCallTime';\nconst AVERAGE_CONNECTING_TO_CALL_TIME = 'averageConnectingToCallTime';\n\nmodule.exports.TYPES = {\n  QUEUE,\n  CUSTOMERS,\n  OPERATORS,\n  CALLS,\n};\n\nmodule.exports.FIELDS = {\n  TOTAL,\n  CONNECTING,\n  CONNECTED,\n  AUTHORIZING,\n  AUTHENTICATED,\n  UNAUTHORIZED,\n  WAITING_FOR_QUEUE_CALLS,\n  PENDING_CALLS,\n  NOT_ENQUEUED_CALLS,\n  ACTIVE_CALLS,\n  MAX_ACTIVE_CALLS,\n  FINISHED_CALLS,\n  MISSED_CALLS,\n  TOTAL_CALLS,\n  PENDING_IN_QUEUE,\n  OLDEST_IN_QUEUE,\n  MIN_ENQUEUEING_TIME,\n  MAX_ENQUEUEING_TIME,\n  AVERAGE_ENQUEUEING_TIME,\n  MIN_ACCEPTING_TIME,\n  MAX_ACCEPTING_TIME,\n  AVERAGE_ACCEPTING_TIME,\n  MIN_DURATION,\n  MAX_DURATION,\n  AVERAGE_DURATION,\n  TOTAL_DURATION,\n  MAX_IN_QUEUE,\n  REQUESTED_AT,\n  ENQUEUED_AT,\n  ENQUEUED_IN,\n  WRAPPING_UP_CUSTOMER,\n  WRAPPING_UP_OPERATOR,\n  ACCEPTED_AT,\n  ACCEPTED_AT_RAW,\n  READY_FOR_CUSTOMER_AT,\n  READY_FOR_CUSTOMER_AT_RAW,\n  READY_FOR_OPERATOR_AT,\n  CONNECTION_TO_CALL_CUSTOMER,\n  CONNECTION_TO_CALL_OPERATOR,\n  MIN_CONNECTING_TIME,\n  MAX_CONNECTING_TIME,\n  AVERAGE_CONNECTING_TIME,\n  TOTAL_CONNECTING_TIME,\n  MIN_AUTHORIZING_TIME,\n  MAX_AUTHORIZING_TIME,\n  AVERAGE_AUTHORIZING_TIME,\n  TOTAL_AUTHORIZING_TIME,\n  MIN_CONNECTING_TO_CALL_TIME,\n  MAX_CONNECTING_TO_CALL_TIME,\n  AVERAGE_CONNECTING_TO_CALL_TIME,\n};\n\nmodule.exports.DEFAULT_STATISTICS = {\n  [QUEUE]: {\n    [PENDING_IN_QUEUE]: 0,\n    [OLDEST_IN_QUEUE]: 0,\n    [MAX_IN_QUEUE]: 0,\n  },\n  [CUSTOMERS]: {\n    [TOTAL]: 0,\n    [CONNECTING]: 0,\n    [CONNECTED]: 0,\n    [AUTHORIZING]: 0,\n    [AUTHENTICATED]: 0,\n    [UNAUTHORIZED]: 0,\n    [MIN_CONNECTING_TIME]: Infinity,\n    [MAX_CONNECTING_TIME]: 0,\n    [AVERAGE_CONNECTING_TIME]: 0,\n    [TOTAL_CONNECTING_TIME]: 0,\n    [MIN_AUTHORIZING_TIME]: Infinity,\n    [MAX_AUTHORIZING_TIME]: 0,\n    [AVERAGE_AUTHORIZING_TIME]: 0,\n    [TOTAL_AUTHORIZING_TIME]: 0,\n    [WAITING_FOR_QUEUE_CALLS]: 0,\n    [NOT_ENQUEUED_CALLS]: 0,\n    [PENDING_CALLS]: 0,\n    [ACTIVE_CALLS]: 0,\n    [MAX_ACTIVE_CALLS]: 0,\n    [FINISHED_CALLS]: 0,\n    [MISSED_CALLS]: 0,\n    [TOTAL_CALLS]: 0,\n    [MIN_ENQUEUEING_TIME]: Infinity,\n    [MAX_ENQUEUEING_TIME]: 0,\n    [AVERAGE_ENQUEUEING_TIME]: 0,\n    [MIN_ACCEPTING_TIME]: Infinity,\n    [MAX_ACCEPTING_TIME]: 0,\n    [AVERAGE_ACCEPTING_TIME]: 0,\n    [MIN_DURATION]: Infinity,\n    [MAX_DURATION]: 0,\n    [AVERAGE_DURATION]: 0,\n    [TOTAL_DURATION]: 0,\n    [MIN_CONNECTING_TO_CALL_TIME]: Infinity,\n    [MAX_CONNECTING_TO_CALL_TIME]: 0,\n    [AVERAGE_CONNECTING_TO_CALL_TIME]: 0,\n  },\n  [OPERATORS]: {\n    [TOTAL]: 0,\n    [CONNECTING]: 0,\n    [CONNECTED]: 0,\n    [AUTHORIZING]: 0,\n    [AUTHENTICATED]: 0,\n    [UNAUTHORIZED]: 0,\n    [MIN_CONNECTING_TIME]: Infinity,\n    [MAX_CONNECTING_TIME]: 0,\n    [AVERAGE_CONNECTING_TIME]: 0,\n    [TOTAL_CONNECTING_TIME]: 0,\n    [MIN_AUTHORIZING_TIME]: Infinity,\n    [MAX_AUTHORIZING_TIME]: 0,\n    [AVERAGE_AUTHORIZING_TIME]: 0,\n    [TOTAL_AUTHORIZING_TIME]: 0,\n    [ACTIVE_CALLS]: 0,\n    [FINISHED_CALLS]: 0,\n    [MIN_ACCEPTING_TIME]: Infinity,\n    [MAX_ACCEPTING_TIME]: 0,\n    [AVERAGE_ACCEPTING_TIME]: 0,\n    [TOTAL_CALLS]: 0,\n  },\n  [CALLS]: {},\n};\n\nmodule.exports.SOCKET_EVENTS = {\n  CONNECT: 'connect',\n  AUTHENTICATION: 'authentication',\n  AUTHENTICATED: 'authenticated',\n  UNAUTHORIZED: 'unauthorized',\n  CALLS_CHANGED: 'calls.changed',\n  CALL_REQUESTED: 'call.requested',\n  CALL_ENQUEUED: 'call.enqueued',\n  CALL_NOT_ENQUEUED: 'call.not.enqueued',\n  CALL_ACCEPTED: 'call.accepted',\n  CALL_FINISHED: 'call.finished',\n  CALLBACK_REQUESTED: 'callback.requested',\n  CALLBACK_REQUESTING_FAILED: 'callback.requesting.failed',\n  CALLBACK_ACCEPTED: 'callback.accepted',\n  CALLBACK_DECLINED: 'callback.declined',\n  ROOM_CREATED: 'room.created',\n  CALLS_EMPTY: 'calls.empty',\n  CALL_ACCEPTING_FAILED: 'call.accepting.failed',\n};\n\nmodule.exports.CALL_STATUSES = {\n  IDLE: 'Idle',\n  CALL_REQUESTED: 'Call requested',\n  CALL_ENQUEUED: 'Call enqueued',\n  CALL_NOT_ENQUEUED: 'Call not enqueued',\n  CALL_ACCEPTED: 'Call accepted',\n  CALL_ACCEPTING_FAILED: 'Call accepting failed',\n  ON_CALL: 'On call',\n  UNAUTHORIZED: 'Unauthorized',\n};\n\nmodule.exports.COLORS_MAP = {\n  idle: '#CFD8DC',\n  callRequested: '#C5CAE9',\n  callEnqueued: '#FFF9C4',\n  callNotEnqueued: '#ffcdd2',\n  callAccepted: '#FFF9C4',\n  callAcceptingFailed: '#ffcdd2',\n  onCall: '#C8E6C9',\n  unauthorized: '#B0BEC5',\n};\n\n},{}],52:[function(require,module,exports){\nconst { TYPES } = require('./constants');\n\nconst drawersMap = {\n  [TYPES.QUEUE]: drawQueueStatisticsField,\n  [TYPES.CUSTOMERS]: drawCustomerStatisticsField,\n  [TYPES.OPERATORS]: drawOperatorStatisticsField,\n};\n\nfunction drawStatisitics(statistics) {\n  Object.keys(statistics).forEach(userType => {\n    const container = getStatisticsContainer(userType);\n\n    if (container) {\n      const statisticData = statistics[userType];\n\n      Object.keys(statisticData).forEach(field =>\n        drawStatisiticsField(container, field, statisticData[field])\n      );\n    }\n  });\n}\n\nfunction drawStatisiticsField(container, field, value) {\n  const seclector = `.${camelToKebab(field)} .quantity`;\n  const el = container.querySelector(seclector);\n  if (el) {\n    el.innerHTML = value === Infinity || isNaN(value) ? 0 : value;\n  }\n}\n\nfunction getStatisticsContainer(userType) {\n  return document.querySelector(`.testing-statistics .${userType}-statistics`);\n}\n\nfunction getStatisticsFieldDrawer(userType) {\n  const defaultDrawer = () => {};\n  return drawersMap[userType] || defaultDrawer;\n}\n\nfunction drawQueueStatisticsField(field, statistics) {\n  const container = getStatisticsContainer(TYPES.QUEUE);\n  const value = statistics[TYPES.QUEUE][field];\n  drawStatisiticsField(container, field, value);\n}\n\nfunction drawCustomerStatisticsField(field, statistics) {\n  const container = getStatisticsContainer(TYPES.CUSTOMERS);\n  const value = statistics[TYPES.CUSTOMERS][field];\n  drawStatisiticsField(container, field, value);\n}\n\nfunction drawOperatorStatisticsField(field, statistics) {\n  const container = getStatisticsContainer(TYPES.OPERATORS);\n  const value = statistics[TYPES.OPERATORS][field];\n  drawStatisiticsField(container, field, value);\n}\n\nfunction drawCall(id, updates) {\n  const container = document.querySelector('.all-calls-statistics .all-calls');\n  if (!updates) {\n    const callWrapper = document.createElement('div');\n    callWrapper.classList.add(`call-${id}`);\n    callWrapper.classList.add(`call-wrapper`);\n    const callTemplate = `\n      <p>Id: ${id}</p>\n      <p class=\"requested-at\">Requested at <span class=\"value\"></span></p>\n      <p class=\"enqueued-at\">Enqueued at <span class=\"value\"></span></p>\n      <p class=\"enqueued-in\">Added to queue in <span class=\"value\">0</span> seconds</p>\n      <p class=\"accepted-at\">Accepted at <span class=\"value\"></span></p>\n      <p class=\"ready-for-customer-at\">Customer got room at <span class=\"value\"></span></p>\n      <p class=\"ready-for-operator-at\">Operator got room at <span class=\"value\"></span></p>\n      <p class=\"wrapping-up-customer\">\n        Customer got room in <span class=\"value\">0</span> seconds after acception\n      </p>\n      <p class=\"wrapping-up-operator\">\n        Operator got room in <span class=\"value\">0</span> seconds after acception\n      </p>\n    `;\n    callWrapper.innerHTML = callTemplate;\n    container.appendChild(callWrapper);\n  } else {\n    const callWrapper = document.querySelector(`.call-${id}`);\n    Object.keys(updates).forEach(key => {\n      const selector = `.${camelToKebab(key)} .value`;\n      const el = callWrapper.querySelector(selector);\n      if (el) {\n        el.innerHTML = updates[key];\n      }\n    });\n  }\n}\n\nfunction camelToKebab(str) {\n  return str.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n}\n\nmodule.exports = {\n  drawStatisitics,\n  drawStatisiticsField,\n  getStatisticsContainer,\n  getStatisticsFieldDrawer,\n  drawQueueStatisticsField,\n  drawCustomerStatisticsField,\n  drawOperatorStatisticsField,\n  drawCall,\n};\n\n},{\"./constants\":51}],53:[function(require,module,exports){\nconst { TYPES } = require('./constants');\n\nconst START_FIRST_CALL_ADDITIONAL_DELAY = 5000;\n\nfunction drawCustomersFrames({\n  io,\n  customersNumber,\n  operatorsNumber,\n  callsPerCustomer,\n  minCallDuration,\n  maxCallDuration,\n  connectionDelay,\n  maxFirstCallDelay,\n  socketOptions,\n  now,\n}) {\n  const parent = document.querySelector('.customers-section');\n  const fragment = document.createDocumentFragment();\n\n  new Array(customersNumber).fill(1).forEach((_, i) => {\n    const iframe = document.createElement('iframe');\n    const num = i + 1;\n    const frameContent = `\n      <html>\n        <body>\n          <p style=\"margin: 0; text-align: center\">\n            <span>${num}</span>\n            <span class=\"peer-id\"></span>\n          </p>\n          <p style=\"margin: 0; text-align: center\">\n            <span class=\"current-call-number\">0</span>\n            <span>/</span>\n            <span class=\"total-allowed-calls\">${callsPerCustomer}</span>\n          </p>\n          <script src=\"/js/customer-load-testing.js\"></script>\n        </body>\n      </html>\n    `;\n\n    iframe.id = `customer-${num}`;\n    iframe.classList.add('user-frame', 'customer-frame');\n    iframe.srcdoc = frameContent;\n\n    setTimeout(() => {\n      const firstCallDelay = Math.ceil(Math.random() * maxFirstCallDelay);\n      const startFirstCallAfter =\n        (Math.max(customersNumber, operatorsNumber) - i) * connectionDelay +\n        firstCallDelay +\n        START_FIRST_CALL_ADDITIONAL_DELAY;\n\n      iframe.contentWindow.io = io;\n      iframe.contentWindow.socketOptions = socketOptions;\n      iframe.contentWindow.connectionDelay = connectionDelay;\n      iframe.contentWindow.userIdentity = `${now}-customer-${num}`;\n      iframe.contentWindow.userType = TYPES.CUSTOMERS;\n      iframe.contentWindow.startFirstCallAfter = startFirstCallAfter;\n      iframe.contentWindow.callsPerCustomer = callsPerCustomer;\n      iframe.contentWindow.minCallDuration = minCallDuration;\n      iframe.contentWindow.maxCallDuration = maxCallDuration;\n    });\n\n    fragment.appendChild(iframe);\n  });\n\n  parent.appendChild(fragment);\n}\n\nfunction drawOperatorsFrames({\n  io,\n  operatorsNumber,\n  minCallDuration,\n  maxCallDuration,\n  connectionDelay,\n  acceptingLikelihood,\n  socketOptions,\n  now,\n}) {\n  const parent = document.querySelector('.operators-section');\n  const fragment = document.createDocumentFragment();\n\n  new Array(operatorsNumber).fill(1).forEach((_, i) => {\n    const iframe = document.createElement('iframe');\n    const num = i + 1;\n    const frameContent = `\n      <html>\n        <body>\n          <p style=\"margin: 0; text-align: center\">\n            <span>${num}</span>\n            <span class=\"peer-id\"></span>\n          </p>\n          <script src=\"/js/operator-load-testing.js\"></script>\n        </body>\n      </html>\n    `;\n\n    iframe.id = `operator-${num}`;\n    iframe.classList.add('user-frame', 'operator-frame');\n    iframe.srcdoc = frameContent;\n    setTimeout(() => {\n      iframe.contentWindow.io = io;\n      iframe.contentWindow.socketOptions = socketOptions;\n      iframe.contentWindow.connectionDelay = connectionDelay;\n      iframe.contentWindow.userIdentity = `${now}-operator-${num}`;\n      iframe.contentWindow.userType = TYPES.OPERATORS;\n      iframe.contentWindow.minCallDuration = minCallDuration;\n      iframe.contentWindow.maxCallDuration = maxCallDuration;\n      iframe.contentWindow.acceptingLikelihood = acceptingLikelihood;\n    });\n    fragment.appendChild(iframe);\n  });\n\n  parent.appendChild(fragment);\n}\n\nmodule.exports = {\n  drawCustomersFrames,\n  drawOperatorsFrames,\n};\n\n},{\"./constants\":51}],54:[function(require,module,exports){\n/* eslint-disable no-console */\nconst moment = require('moment');\nconst { TYPES, FIELDS } = require('./constants');\nconst {\n  getDefaultCall,\n  getField,\n  setField,\n  incrementField,\n  decrementField,\n} = require('./utils');\nconst {\n  getStatisticsFieldDrawer,\n  drawCustomerStatisticsField,\n  drawOperatorStatisticsField,\n  drawCall,\n} = require('./statisticsDrawers');\n\nlet pendingCallsIds = [];\nlet activeCallsIds = [];\nlet finishedCallsIds = [];\nlet missedCallsIds = [];\n\nlet totalEnqueueingTime = 0;\nlet totalAcceptingTime = 0;\nlet totalConnectingToCallTime = 0;\nlet totalDuration = 0;\nlet totalAcceptedCalls = 0;\n\nlet totalCallsForTest = 0;\nlet onAllCallsPerformed = () => {};\n\nmodule.exports = {\n  init,\n  incrementConnectingUsers,\n  decrementConnectingUsers,\n  incrementConnectedUsers,\n  decrementConnectedUsers,\n  incrementAuthorizingUsers,\n  decrementAuthorizingUsers,\n  incrementAuthenticatedUsers,\n  incrementUnauthorizedUsers,\n  incrementWaitingForQueueCalls,\n  decrementWaitingForQueueCalls,\n  incrementNotEnqueuedCalls,\n  incrementPendingCalls,\n  decrementPendingCalls,\n  incrementActiveCalls,\n  decrementActiveCalls,\n  incrementFinishedCalls,\n  incrementMissedCalls,\n  incrementOperatorsAcceptedCalls,\n  onUserConnected,\n  onUserAuthorized,\n  onCallEnqueued,\n  onCallAcceptionByOperatorHandled,\n  onCustomerCallAccepted,\n  updateCallDurationTime,\n};\n\nfunction init(totalCalls = 0, allCallsPerformedHandler = () => {}) {\n  pendingCallsIds = [];\n  activeCallsIds = [];\n  finishedCallsIds = [];\n  missedCallsIds = [];\n\n  totalEnqueueingTime = 0;\n  totalAcceptingTime = 0;\n  totalConnectingToCallTime = 0;\n  totalDuration = 0;\n  totalAcceptedCalls = 0;\n  totalCallsForTest = totalCalls;\n  onAllCallsPerformed = allCallsPerformedHandler;\n}\n\nfunction incrementConnectingUsers(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.CONNECTING);\n  getStatisticsFieldDrawer(userType)(FIELDS.CONNECTING, statistics);\n}\n\nfunction decrementConnectingUsers(userType, statistics) {\n  decrementField(statistics, userType, FIELDS.CONNECTING);\n  getStatisticsFieldDrawer(userType)(FIELDS.CONNECTING, statistics);\n}\n\nfunction incrementConnectedUsers(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.CONNECTED);\n  getStatisticsFieldDrawer(userType)(FIELDS.CONNECTED, statistics);\n}\n\nfunction decrementConnectedUsers(userType, statistics) {\n  decrementField(statistics, userType, FIELDS.CONNECTED);\n  getStatisticsFieldDrawer(userType)(FIELDS.CONNECTED, statistics);\n}\n\nfunction incrementAuthorizingUsers(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.AUTHORIZING);\n  getStatisticsFieldDrawer(userType)(FIELDS.AUTHORIZING, statistics);\n}\n\nfunction decrementAuthorizingUsers(userType, statistics) {\n  decrementField(statistics, userType, FIELDS.AUTHORIZING);\n  getStatisticsFieldDrawer(userType)(FIELDS.AUTHORIZING, statistics);\n}\n\nfunction incrementAuthenticatedUsers(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.AUTHENTICATED);\n  getStatisticsFieldDrawer(userType)(FIELDS.AUTHENTICATED, statistics);\n}\n\nfunction incrementUnauthorizedUsers(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.UNAUTHORIZED);\n  getStatisticsFieldDrawer(userType)(FIELDS.UNAUTHORIZED, statistics);\n}\n\nfunction incrementWaitingForQueueCalls(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.WAITING_FOR_QUEUE_CALLS);\n  getStatisticsFieldDrawer(userType)(\n    FIELDS.WAITING_FOR_QUEUE_CALLS,\n    statistics\n  );\n}\n\nfunction decrementWaitingForQueueCalls(userType, statistics) {\n  decrementField(statistics, userType, FIELDS.WAITING_FOR_QUEUE_CALLS);\n  getStatisticsFieldDrawer(userType)(\n    FIELDS.WAITING_FOR_QUEUE_CALLS,\n    statistics\n  );\n}\n\nfunction incrementNotEnqueuedCalls(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.NOT_ENQUEUED_CALLS);\n  getStatisticsFieldDrawer(userType)(FIELDS.NOT_ENQUEUED_CALLS, statistics);\n}\n\nfunction incrementPendingCalls(userType, callId, statistics) {\n  if (callId && !pendingCallsIds.includes(callId)) {\n    pendingCallsIds.push(callId);\n    incrementField(statistics, userType, FIELDS.PENDING_CALLS);\n    checkAndAddCall(callId, statistics);\n    getStatisticsFieldDrawer(userType)(FIELDS.PENDING_CALLS, statistics);\n  }\n}\n\nfunction decrementPendingCalls(userType, callId, statistics) {\n  if (callId && pendingCallsIds.includes(callId)) {\n    pendingCallsIds = pendingCallsIds.filter(id => id !== callId);\n    decrementField(statistics, userType, FIELDS.PENDING_CALLS);\n    getStatisticsFieldDrawer(userType)(FIELDS.PENDING_CALLS, statistics);\n  }\n}\n\nfunction incrementActiveCalls(userType, callId, statistics) {\n  if (callId && !activeCallsIds.includes(callId)) {\n    activeCallsIds.push(callId);\n    incrementField(statistics, userType, FIELDS.ACTIVE_CALLS);\n    getStatisticsFieldDrawer(userType)(FIELDS.ACTIVE_CALLS, statistics);\n  }\n\n  const currentActiveCalls = getField(\n    statistics,\n    userType,\n    FIELDS.ACTIVE_CALLS\n  );\n  const maxActiveCalls = getField(\n    statistics,\n    userType,\n    FIELDS.MAX_ACTIVE_CALLS\n  );\n\n  if (currentActiveCalls > maxActiveCalls) {\n    setField(statistics, userType, FIELDS.MAX_ACTIVE_CALLS, currentActiveCalls);\n    getStatisticsFieldDrawer(userType)(FIELDS.MAX_ACTIVE_CALLS, statistics);\n  }\n}\n\nfunction decrementActiveCalls(userType, callId, statistics) {\n  if (activeCallsIds.includes(callId)) {\n    activeCallsIds = activeCallsIds.filter(id => id !== callId);\n    decrementField(statistics, userType, FIELDS.ACTIVE_CALLS);\n    getStatisticsFieldDrawer(userType)(FIELDS.ACTIVE_CALLS, statistics);\n  }\n}\n\nfunction incrementFinishedCalls(userType, callId, statistics) {\n  if (callId && !finishedCallsIds.includes(callId)) {\n    finishedCallsIds.push(callId);\n    incrementField(statistics, userType, FIELDS.FINISHED_CALLS);\n    incrementTotalCalls(userType, statistics);\n    getStatisticsFieldDrawer(userType)(FIELDS.FINISHED_CALLS, statistics);\n  }\n}\n\nfunction incrementMissedCalls(userType, callId, statistics) {\n  if (callId && !missedCallsIds.includes(callId)) {\n    missedCallsIds.push(callId);\n    incrementField(statistics, userType, FIELDS.MISSED_CALLS);\n    incrementTotalCalls(userType, statistics);\n    getStatisticsFieldDrawer(userType)(FIELDS.MISSED_CALLS, statistics);\n  }\n}\n\nfunction incrementOperatorsAcceptedCalls(statistics) {\n  incrementTotalCalls(TYPES.OPERATORS, statistics);\n}\n\nfunction onUserConnected(userType, requestTime, responseTime, statistics) {\n  const value = responseTime - requestTime;\n  const totalConnectingTime =\n    getField(statistics, userType, FIELDS.TOTAL_CONNECTING_TIME) + value;\n  const totalUsers = getField(statistics, userType, FIELDS.CONNECTED);\n\n  if (checkMinConnectingTime(userType, value, statistics)) {\n    getStatisticsFieldDrawer(userType)(FIELDS.MIN_CONNECTING_TIME, statistics);\n  }\n\n  if (checkMaxConnectingTime(userType, value, statistics)) {\n    getStatisticsFieldDrawer(userType)(FIELDS.MAX_CONNECTING_TIME, statistics);\n  }\n\n  const average = totalUsers\n    ? (Number(totalConnectingTime) / totalUsers).toFixed(3)\n    : 0;\n\n  setField(\n    statistics,\n    userType,\n    FIELDS.TOTAL_CONNECTING_TIME,\n    totalConnectingTime\n  );\n  setField(statistics, userType, FIELDS.AVERAGE_CONNECTING_TIME, average);\n  getStatisticsFieldDrawer(userType)(\n    FIELDS.AVERAGE_CONNECTING_TIME,\n    statistics\n  );\n}\n\nfunction onUserAuthorized(userType, requestTime, responseTime, statistics) {\n  const value = responseTime - requestTime;\n  const totalAuthorizingTime =\n    getField(statistics, userType, FIELDS.TOTAL_AUTHORIZING_TIME) + value;\n  const totalUsers = getField(statistics, userType, FIELDS.AUTHENTICATED);\n\n  if (checkMinAuthorizingTime(userType, value, statistics)) {\n    getStatisticsFieldDrawer(userType)(FIELDS.MIN_AUTHORIZING_TIME, statistics);\n  }\n\n  if (checkMaxAuthorizingTime(userType, value, statistics)) {\n    getStatisticsFieldDrawer(userType)(FIELDS.MAX_AUTHORIZING_TIME, statistics);\n  }\n\n  const average = totalUsers\n    ? (Number(totalAuthorizingTime) / totalUsers).toFixed(3)\n    : 0;\n\n  setField(\n    statistics,\n    userType,\n    FIELDS.TOTAL_AUTHORIZING_TIME,\n    totalAuthorizingTime\n  );\n  setField(statistics, userType, FIELDS.AVERAGE_AUTHORIZING_TIME, average);\n  getStatisticsFieldDrawer(userType)(\n    FIELDS.AVERAGE_AUTHORIZING_TIME,\n    statistics\n  );\n}\n\nfunction onCallEnqueued(id, requestTime, responseTime, statistics) {\n  const value = responseTime - requestTime;\n\n  if (checkMinEnqueueingTime(value, statistics)) {\n    drawCustomerStatisticsField(FIELDS.MIN_ENQUEUEING_TIME, statistics);\n  }\n\n  if (checkMaxEnqueueingTime(value, statistics)) {\n    drawCustomerStatisticsField(FIELDS.MAX_ENQUEUEING_TIME, statistics);\n  }\n\n  updateAndDrawCall(\n    id,\n    {\n      [FIELDS.REQUESTED_AT]: moment(requestTime * 1000).format('HH:mm:ss'),\n      [FIELDS.ENQUEUED_AT]: moment(responseTime * 1000).format('HH:mm:ss'),\n      [FIELDS.ENQUEUED_IN]: value.toFixed(3),\n    },\n    statistics\n  );\n\n  totalEnqueueingTime += value;\n\n  const totalCalls = getField(statistics, TYPES.CUSTOMERS, FIELDS.TOTAL_CALLS);\n  const average = totalCalls\n    ? (Number(totalEnqueueingTime) / totalCalls).toFixed(2)\n    : 0;\n  setField(\n    statistics,\n    TYPES.CUSTOMERS,\n    FIELDS.AVERAGE_ENQUEUEING_TIME,\n    average\n  );\n  drawCustomerStatisticsField(FIELDS.AVERAGE_ENQUEUEING_TIME, statistics);\n}\n\nfunction onCallAcceptionByOperatorHandled(\n  id,\n  requestTime,\n  responseTime,\n  statistics\n) {\n  const value = responseTime - requestTime;\n\n  if (checkMinAcceptingTime(value, statistics)) {\n    drawOperatorStatisticsField(FIELDS.MIN_ACCEPTING_TIME, statistics);\n  }\n\n  if (checkMaxAcceptingTime(value, statistics)) {\n    drawOperatorStatisticsField(FIELDS.MAX_ACCEPTING_TIME, statistics);\n  }\n\n  if (id) {\n    const updates = {\n      [FIELDS.ACCEPTED_AT]: moment(requestTime * 1000).format('HH:mm:ss'),\n      [FIELDS.ACCEPTED_AT_RAW]: requestTime,\n      [FIELDS.READY_FOR_OPERATOR_AT]: moment(responseTime * 1000).format(\n        'HH:mm:ss'\n      ),\n      [FIELDS.WRAPPING_UP_OPERATOR]: value.toFixed(3),\n    };\n\n    let call = getField(statistics, TYPES.CALLS, id);\n\n    if (!call) {\n      call = checkAndAddCall(id, statistics);\n    }\n\n    const readyForCustomerAt = call[FIELDS.READY_FOR_CUSTOMER_AT_RAW];\n\n    if (readyForCustomerAt) {\n      updates[FIELDS.WRAPPING_UP_CUSTOMER] = (\n        readyForCustomerAt - requestTime\n      ).toFixed(3);\n    }\n\n    updateAndDrawCall(id, updates, statistics);\n  }\n\n  totalAcceptingTime += value;\n\n  const totalCalls = getField(statistics, TYPES.OPERATORS, FIELDS.TOTAL_CALLS);\n  const average = totalCalls\n    ? (Number(totalAcceptingTime) / totalCalls).toFixed(2)\n    : 0;\n  setField(statistics, TYPES.OPERATORS, FIELDS.AVERAGE_ACCEPTING_TIME, average);\n  drawOperatorStatisticsField(FIELDS.AVERAGE_ACCEPTING_TIME, statistics);\n}\n\nfunction onCustomerCallAccepted(id, requestTime, responseTime, statistics) {\n  if (id) {\n    let call = getField(statistics, TYPES.CALLS, id);\n\n    if (!call) {\n      call = checkAndAddCall(id, statistics);\n    }\n\n    const acceptedAt = call[FIELDS.ACCEPTED_AT_RAW];\n    const updates = {\n      [FIELDS.READY_FOR_CUSTOMER_AT]: moment(responseTime * 1000).format(\n        'HH:mm:ss'\n      ),\n      [FIELDS.READY_FOR_CUSTOMER_AT_RAW]: responseTime,\n    };\n    if (acceptedAt) {\n      updates[FIELDS.WRAPPING_UP_CUSTOMER] = (\n        responseTime - acceptedAt\n      ).toFixed(3);\n    }\n    const value = responseTime - requestTime;\n    if (checkMinConnectingToCallTime(TYPES.CUSTOMERS, value, statistics)) {\n      drawCustomerStatisticsField(\n        FIELDS.MIN_CONNECTING_TO_CALL_TIME,\n        statistics\n      );\n    }\n    if (checkMaxConnectingToCallTime(TYPES.CUSTOMERS, value, statistics)) {\n      drawCustomerStatisticsField(\n        FIELDS.MAX_CONNECTING_TO_CALL_TIME,\n        statistics\n      );\n    }\n\n    totalConnectingToCallTime += value;\n    totalAcceptedCalls += 1;\n\n    const average = Number(\n      totalConnectingToCallTime / totalAcceptedCalls\n    ).toFixed(2);\n    setField(\n      statistics,\n      TYPES.CUSTOMERS,\n      FIELDS.AVERAGE_CONNECTING_TO_CALL_TIME,\n      average\n    );\n    drawCustomerStatisticsField(\n      FIELDS.AVERAGE_CONNECTING_TO_CALL_TIME,\n      statistics\n    );\n    updateAndDrawCall(id, updates, statistics);\n  }\n}\n\nfunction updateCallDurationTime(value = 0, statistics) {\n  if (checkMinCallDuration(value, statistics)) {\n    drawCustomerStatisticsField(FIELDS.MIN_DURATION, statistics);\n  }\n\n  if (checkMaxCallDuration(value, statistics)) {\n    drawCustomerStatisticsField(FIELDS.MAX_DURATION, statistics);\n  }\n\n  totalDuration += value;\n\n  const totalCalls = getField(statistics, TYPES.CUSTOMERS, FIELDS.TOTAL_CALLS);\n  const average = totalCalls\n    ? (Number(totalDuration) / totalCalls).toFixed(2)\n    : 0;\n  setField(statistics, TYPES.CUSTOMERS, FIELDS.AVERAGE_DURATION, average);\n  setField(\n    statistics,\n    TYPES.CUSTOMERS,\n    FIELDS.TOTAL_DURATION,\n    totalDuration.toFixed(2)\n  );\n  drawCustomerStatisticsField(FIELDS.AVERAGE_DURATION, statistics);\n  drawCustomerStatisticsField(FIELDS.TOTAL_DURATION, statistics);\n}\n\nfunction incrementTotalCalls(userType, statistics) {\n  incrementField(statistics, userType, FIELDS.TOTAL_CALLS);\n  getStatisticsFieldDrawer(userType)(FIELDS.TOTAL_CALLS, statistics);\n  const totalCalls = getField(statistics, TYPES.CUSTOMERS, FIELDS.TOTAL_CALLS);\n  if (totalCalls === totalCallsForTest) {\n    onAllCallsPerformed();\n    setTimeout(() => {\n      console.log('pendingCallsIds', pendingCallsIds.length);\n      console.log('activeCallsIds', activeCallsIds.length);\n      console.log('finishedCallsIds', finishedCallsIds.length);\n      console.log('missedCallsIds', missedCallsIds.length);\n    }, 15000);\n  }\n}\n\nfunction checkMinEnqueueingTime(value = 0, statistics) {\n  const minEnqueueingTime = parseFloat(\n    getField(statistics, TYPES.CUSTOMERS, FIELDS.MIN_ENQUEUEING_TIME)\n  );\n  if (value < minEnqueueingTime) {\n    setField(\n      statistics,\n      TYPES.CUSTOMERS,\n      FIELDS.MIN_ENQUEUEING_TIME,\n      value.toFixed(2)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMaxEnqueueingTime(value = 0, statistics) {\n  const maxEnqueueingTime = parseFloat(\n    getField(statistics, TYPES.CUSTOMERS, FIELDS.MAX_ENQUEUEING_TIME)\n  );\n  if (value > maxEnqueueingTime) {\n    setField(\n      statistics,\n      TYPES.CUSTOMERS,\n      FIELDS.MAX_ENQUEUEING_TIME,\n      value.toFixed(2)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMinAcceptingTime(value = 0, statistics) {\n  const minAcceptingTime = parseFloat(\n    getField(statistics, TYPES.OPERATORS, FIELDS.MIN_ACCEPTING_TIME)\n  );\n  if (value < minAcceptingTime) {\n    setField(\n      statistics,\n      TYPES.OPERATORS,\n      FIELDS.MIN_ACCEPTING_TIME,\n      value.toFixed(2)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMaxAcceptingTime(value = 0, statistics) {\n  const maxAcceptingTime = parseFloat(\n    getField(statistics, TYPES.OPERATORS, FIELDS.MAX_ACCEPTING_TIME)\n  );\n  if (value > maxAcceptingTime) {\n    setField(\n      statistics,\n      TYPES.OPERATORS,\n      FIELDS.MAX_ACCEPTING_TIME,\n      value.toFixed(2)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMinCallDuration(value = 0, statistics) {\n  const minDuration = parseFloat(\n    getField(statistics, TYPES.CUSTOMERS, FIELDS.MIN_DURATION)\n  );\n  if (value < minDuration) {\n    setField(\n      statistics,\n      TYPES.CUSTOMERS,\n      FIELDS.MIN_DURATION,\n      value.toFixed(2)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMaxCallDuration(value = 0, statistics) {\n  const maxDuration = parseFloat(\n    getField(statistics, TYPES.CUSTOMERS, FIELDS.MAX_DURATION)\n  );\n  if (value > maxDuration) {\n    setField(\n      statistics,\n      TYPES.CUSTOMERS,\n      FIELDS.MAX_DURATION,\n      value.toFixed(2)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMinConnectingTime(userType, value, statistics) {\n  const minConnectingTime = parseFloat(\n    getField(statistics, userType, FIELDS.MIN_CONNECTING_TIME)\n  );\n  if (value < minConnectingTime) {\n    setField(\n      statistics,\n      userType,\n      FIELDS.MIN_CONNECTING_TIME,\n      value.toFixed(3)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMaxConnectingTime(userType, value, statistics) {\n  const maxConnectingTime = parseFloat(\n    getField(statistics, userType, FIELDS.MAX_CONNECTING_TIME)\n  );\n  if (value > maxConnectingTime) {\n    setField(\n      statistics,\n      userType,\n      FIELDS.MAX_CONNECTING_TIME,\n      value.toFixed(3)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMinAuthorizingTime(userType, value, statistics) {\n  const minAuthorizingTime = parseFloat(\n    getField(statistics, userType, FIELDS.MIN_AUTHORIZING_TIME)\n  );\n\n  if (value < minAuthorizingTime) {\n    setField(\n      statistics,\n      userType,\n      FIELDS.MIN_AUTHORIZING_TIME,\n      value.toFixed(3)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMaxAuthorizingTime(userType, value, statistics) {\n  const maxAuthorizingTime = parseFloat(\n    getField(statistics, userType, FIELDS.MAX_AUTHORIZING_TIME)\n  );\n\n  if (value > maxAuthorizingTime) {\n    setField(\n      statistics,\n      userType,\n      FIELDS.MAX_AUTHORIZING_TIME,\n      value.toFixed(3)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMinConnectingToCallTime(userType, value, statistics) {\n  const minConnectingToCallTime = parseFloat(\n    getField(statistics, userType, FIELDS.MIN_CONNECTING_TO_CALL_TIME)\n  );\n\n  if (value < minConnectingToCallTime) {\n    setField(\n      statistics,\n      userType,\n      FIELDS.MIN_CONNECTING_TO_CALL_TIME,\n      value.toFixed(3)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkMaxConnectingToCallTime(userType, value, statistics) {\n  const maxConnectingToCallTime = parseFloat(\n    getField(statistics, userType, FIELDS.MAX_CONNECTING_TO_CALL_TIME)\n  );\n\n  if (value > maxConnectingToCallTime) {\n    setField(\n      statistics,\n      userType,\n      FIELDS.MAX_CONNECTING_TO_CALL_TIME,\n      value.toFixed(3)\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction checkAndAddCall(id, statistics) {\n  if (id && !isCallInList(id, statistics)) {\n    const defaultCall = addCallToList(id, statistics);\n    drawCall(id, null);\n    return defaultCall;\n  }\n  return null;\n}\n\nfunction isCallInList(id, statistics) {\n  return Boolean(statistics[TYPES.CALLS][id]);\n}\n\nfunction addCallToList(id, statistics) {\n  const defaultCall = getDefaultCall();\n  statistics[TYPES.CALLS][id] = defaultCall;\n  return defaultCall;\n}\n\nfunction updateAndDrawCall(id, updates, statistics) {\n  const updatedCall = { ...statistics[TYPES.CALLS][id], ...updates };\n  statistics[TYPES.CALLS][id] = updatedCall;\n  drawCall(id, updates);\n}\n\n},{\"./constants\":51,\"./statisticsDrawers\":52,\"./utils\":55,\"moment\":31}],55:[function(require,module,exports){\n/* eslint-disable no-console */\nconst { DEFAULT_STATISTICS, TYPES, FIELDS } = require('./constants');\n\nconst { QUEUE, CUSTOMERS, OPERATORS, CALLS } = TYPES;\n\nfunction getDefaultStatistics() {\n  return {\n    [QUEUE]: { ...DEFAULT_STATISTICS[QUEUE] },\n    [CUSTOMERS]: { ...DEFAULT_STATISTICS[CUSTOMERS] },\n    [OPERATORS]: { ...DEFAULT_STATISTICS[OPERATORS] },\n    [CALLS]: { ...DEFAULT_STATISTICS[CALLS] },\n  };\n}\n\nfunction getDefaultCall() {\n  return {\n    [FIELDS.REQUESTED_AT]: null,\n    [FIELDS.ENQUEUED_AT]: null,\n    [FIELDS.ACCEPTED_AT]: null,\n    [FIELDS.READY_FOR_CUSTOMER_AT]: null,\n    [FIELDS.READY_FOR_OPERATOR_AT]: null,\n  };\n}\n\nfunction incrementField(statistics, userType, field, value = 1) {\n  try {\n    statistics[userType][field] += value;\n  } catch (e) {\n    console.error(`Field ${field} cannot be incremented for ${userType}: ${e}`);\n  }\n}\n\nfunction decrementField(statistics, userType, field) {\n  try {\n    statistics[userType][field] -= 1;\n  } catch (e) {\n    console.error(`Field ${field} cannot be decremented for ${userType}: ${e}`);\n  }\n}\n\nfunction setField(statistics, userType, field, value) {\n  try {\n    statistics[userType][field] = value;\n  } catch (e) {\n    console.error(\n      `Field ${field} cannot be set for ${userType} with ${value}: ${e}`\n    );\n  }\n}\n\nfunction getField(statistics, userType, field) {\n  let value = 0;\n  try {\n    value = statistics[userType][field];\n  } catch (e) {\n    console.error(\n      `Field ${field} cannot be set for ${userType} with ${value}: ${e}`\n    );\n    value = 0;\n  }\n  return value;\n}\n\nfunction toCamelCase(str) {\n  return str\n    .toLowerCase()\n    .replace(/\\s[a-z]/g, match => match.trim().toUpperCase());\n}\n\nfunction getUserNumber(id = '') {\n  return Number(id.match(/[0-9]*$/)[0]);\n}\n\nfunction getNowSeconds() {\n  return Date.now() / 1000;\n}\n\nmodule.exports = {\n  getDefaultStatistics,\n  getDefaultCall,\n  incrementField,\n  decrementField,\n  setField,\n  getField,\n  toCamelCase,\n  getUserNumber,\n  getNowSeconds,\n};\n\n},{\"./constants\":51}]},{},[50]);\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/public/js/load-testing.js	(date 1566483545000)
+++ src/public/js/load-testing.js	(date 1566550235000)
@@ -473,6 +473,7 @@
 },{}],7:[function(require,module,exports){
 
 },{}],8:[function(require,module,exports){
+(function (Buffer){
 /*!
  * The buffer module from node.js, for the browser.
  *
@@ -2251,7 +2252,8 @@
   return obj !== obj // eslint-disable-line no-self-compare
 }
 
-},{"base64-js":5,"ieee754":28}],9:[function(require,module,exports){
+}).call(this,require("buffer").Buffer)
+},{"base64-js":5,"buffer":8,"ieee754":30}],9:[function(require,module,exports){
 /**
  * Slice reference.
  */
@@ -2461,8 +2463,7 @@
  */
 module.exports.parser = require('engine.io-parser');
 
-},{"./socket":13,"engine.io-parser":23}],13:[function(require,module,exports){
-(function (global){
+},{"./socket":13,"engine.io-parser":24}],13:[function(require,module,exports){
 /**
  * Module dependencies.
  */
@@ -2510,7 +2511,7 @@
   }
 
   this.secure = null != opts.secure ? opts.secure
-    : (global.location && 'https:' === location.protocol);
+    : (typeof location !== 'undefined' && 'https:' === location.protocol);
 
   if (opts.hostname && !opts.port) {
     // if no port is specified manually, use the protocol default
@@ -2519,8 +2520,8 @@
 
   this.agent = opts.agent || false;
   this.hostname = opts.hostname ||
-    (global.location ? location.hostname : 'localhost');
-  this.port = opts.port || (global.location && location.port
+    (typeof location !== 'undefined' ? location.hostname : 'localhost');
+  this.port = opts.port || (typeof location !== 'undefined' && location.port
       ? location.port
       : (this.secure ? 443 : 80));
   this.query = opts.query || {};
@@ -2559,9 +2560,11 @@
   this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
   this.forceNode = !!opts.forceNode;
 
-  // other options for Node.js client
-  var freeGlobal = typeof global === 'object' && global;
-  if (freeGlobal.global === freeGlobal) {
+  // detect ReactNative environment
+  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');
+
+  // other options for Node.js or ReactNative client
+  if (typeof self === 'undefined' || this.isReactNative) {
     if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
       this.extraHeaders = opts.extraHeaders;
     }
@@ -2661,7 +2664,8 @@
     forceNode: options.forceNode || this.forceNode,
     localAddress: options.localAddress || this.localAddress,
     requestTimeout: options.requestTimeout || this.requestTimeout,
-    protocols: options.protocols || void (0)
+    protocols: options.protocols || void (0),
+    isReactNative: this.isReactNative
   });
 
   return transport;
@@ -3207,8 +3211,7 @@
   return filteredUpgrades;
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./transport":14,"./transports/index":15,"component-emitter":10,"debug":21,"engine.io-parser":23,"indexof":29,"parseqs":33,"parseuri":34}],14:[function(require,module,exports){
+},{"./transport":14,"./transports/index":15,"component-emitter":10,"debug":21,"engine.io-parser":24,"indexof":31,"parseqs":33,"parseuri":34}],14:[function(require,module,exports){
 /**
  * Module dependencies.
  */
@@ -3252,6 +3255,9 @@
   this.rejectUnauthorized = opts.rejectUnauthorized;
   this.forceNode = opts.forceNode;
 
+  // results of ReactNative environment detection
+  this.isReactNative = opts.isReactNative;
+
   // other options for Node.js client
   this.extraHeaders = opts.extraHeaders;
   this.localAddress = opts.localAddress;
@@ -3367,8 +3373,7 @@
   this.emit('close');
 };
 
-},{"component-emitter":10,"engine.io-parser":23}],15:[function(require,module,exports){
-(function (global){
+},{"component-emitter":10,"engine.io-parser":24}],15:[function(require,module,exports){
 /**
  * Module dependencies
  */
@@ -3398,7 +3403,7 @@
   var xs = false;
   var jsonp = false !== opts.jsonp;
 
-  if (global.location) {
+  if (typeof location !== 'undefined') {
     var isSSL = 'https:' === location.protocol;
     var port = location.port;
 
@@ -3423,10 +3428,8 @@
   }
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
 },{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,"xmlhttprequest-ssl":20}],16:[function(require,module,exports){
 (function (global){
-
 /**
  * Module requirements.
  */
@@ -3459,6 +3462,15 @@
 
 function empty () { }
 
+/**
+ * Until https://github.com/tc39/proposal-global is shipped.
+ */
+function glob () {
+  return typeof self !== 'undefined' ? self
+      : typeof window !== 'undefined' ? window
+      : typeof global !== 'undefined' ? global : {};
+}
+
 /**
  * JSONP Polling constructor.
  *
@@ -3475,8 +3487,8 @@
   // we do this here (lazily) to avoid unneeded global pollution
   if (!callbacks) {
     // we need to consider multiple engines in the same page
-    if (!global.___eio) global.___eio = [];
-    callbacks = global.___eio;
+    var global = glob();
+    callbacks = global.___eio = (global.___eio || []);
   }
 
   // callback identifier
@@ -3492,8 +3504,8 @@
   this.query.j = this.index;
 
   // prevent spurious errors from being emitted when the window is unloaded
-  if (global.document && global.addEventListener) {
-    global.addEventListener('beforeunload', function () {
+  if (typeof addEventListener === 'function') {
+    addEventListener('beforeunload', function () {
       if (self.script) self.script.onerror = empty;
     }, false);
   }
@@ -3660,7 +3672,8 @@
 
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
 },{"./polling":18,"component-inherit":11}],17:[function(require,module,exports){
-(function (global){
+/* global attachEvent */
+
 /**
  * Module requirements.
  */
@@ -3696,7 +3709,7 @@
   this.requestTimeout = opts.requestTimeout;
   this.extraHeaders = opts.extraHeaders;
 
-  if (global.location) {
+  if (typeof location !== 'undefined') {
     var isSSL = 'https:' === location.protocol;
     var port = location.port;
 
@@ -3705,7 +3718,7 @@
       port = isSSL ? 443 : 80;
     }
 
-    this.xd = opts.hostname !== global.location.hostname ||
+    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
       port !== opts.port;
     this.xs = opts.secure !== isSSL;
   }
@@ -3934,7 +3947,7 @@
     return;
   }
 
-  if (global.document) {
+  if (typeof document !== 'undefined') {
     this.index = Request.requestsCount++;
     Request.requests[this.index] = this;
   }
@@ -3996,7 +4009,7 @@
     } catch (e) {}
   }
 
-  if (global.document) {
+  if (typeof document !== 'undefined') {
     delete Request.requests[this.index];
   }
 
@@ -4036,7 +4049,7 @@
  */
 
 Request.prototype.hasXDR = function () {
-  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
+  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
 };
 
 /**
@@ -4058,11 +4071,12 @@
 Request.requestsCount = 0;
 Request.requests = {};
 
-if (global.document) {
-  if (global.attachEvent) {
-    global.attachEvent('onunload', unloadHandler);
-  } else if (global.addEventListener) {
-    global.addEventListener('beforeunload', unloadHandler, false);
+if (typeof document !== 'undefined') {
+  if (typeof attachEvent === 'function') {
+    attachEvent('onunload', unloadHandler);
+  } else if (typeof addEventListener === 'function') {
+    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
+    addEventListener(terminationEvent, unloadHandler, false);
   }
 }
 
@@ -4074,7 +4088,6 @@
   }
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
 },{"./polling":18,"component-emitter":10,"component-inherit":11,"debug":21,"xmlhttprequest-ssl":20}],18:[function(require,module,exports){
 /**
  * Module dependencies.
@@ -4322,8 +4335,8 @@
   return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
 };
 
-},{"../transport":14,"component-inherit":11,"debug":21,"engine.io-parser":23,"parseqs":33,"xmlhttprequest-ssl":20,"yeast":49}],19:[function(require,module,exports){
-(function (global){
+},{"../transport":14,"component-inherit":11,"debug":21,"engine.io-parser":24,"parseqs":33,"xmlhttprequest-ssl":20,"yeast":52}],19:[function(require,module,exports){
+(function (Buffer){
 /**
  * Module dependencies.
  */
@@ -4334,9 +4347,14 @@
 var inherit = require('component-inherit');
 var yeast = require('yeast');
 var debug = require('debug')('engine.io-client:websocket');
-var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
-var NodeWebSocket;
-if (typeof window === 'undefined') {
+
+var BrowserWebSocket, NodeWebSocket;
+
+if (typeof WebSocket !== 'undefined') {
+  BrowserWebSocket = WebSocket;
+} else if (typeof self !== 'undefined') {
+  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
+} else {
   try {
     NodeWebSocket = require('ws');
   } catch (e) { }
@@ -4348,10 +4366,7 @@
  * interface exposed by `ws` for Node-like environment.
  */
 
-var WebSocket = BrowserWebSocket;
-if (!WebSocket && typeof window === 'undefined') {
-  WebSocket = NodeWebSocket;
-}
+var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
 
 /**
  * Module exports.
@@ -4375,7 +4390,7 @@
   this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
   this.protocols = opts.protocols;
   if (!this.usingBrowserWebSocket) {
-    WebSocket = NodeWebSocket;
+    WebSocketImpl = NodeWebSocket;
   }
   Transport.call(this, opts);
 }
@@ -4435,7 +4450,12 @@
   }
 
   try {
-    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
+    this.ws =
+      this.usingBrowserWebSocket && !this.isReactNative
+        ? protocols
+          ? new WebSocketImpl(uri, protocols)
+          : new WebSocketImpl(uri)
+        : new WebSocketImpl(uri, protocols, opts);
   } catch (err) {
     return this.emit('error', err);
   }
@@ -4502,7 +4522,7 @@
           }
 
           if (self.perMessageDeflate) {
-            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
+            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
             if (len < self.perMessageDeflate.threshold) {
               opts.compress = false;
             }
@@ -4608,12 +4628,11 @@
  */
 
 WS.prototype.check = function () {
-  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
+  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"../transport":14,"component-inherit":11,"debug":21,"engine.io-parser":23,"parseqs":33,"ws":7,"yeast":49}],20:[function(require,module,exports){
-(function (global){
+}).call(this,require("buffer").Buffer)
+},{"../transport":14,"buffer":8,"component-inherit":11,"debug":21,"engine.io-parser":24,"parseqs":33,"ws":7,"yeast":52}],20:[function(require,module,exports){
 // browser shim for xmlhttprequest module
 
 var hasCORS = require('has-cors');
@@ -4647,13 +4666,12 @@
 
   if (!xdomain) {
     try {
-      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
+      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
     } catch (e) { }
   }
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"has-cors":27}],21:[function(require,module,exports){
+},{"has-cors":29}],21:[function(require,module,exports){
 (function (process){
 /**
  * This is the web browser implementation of `debug()`.
@@ -5079,7 +5097,161 @@
   return val;
 }
 
-},{"ms":32}],23:[function(require,module,exports){
+},{"ms":23}],23:[function(require,module,exports){
+/**
+ * Helpers.
+ */
+
+var s = 1000;
+var m = s * 60;
+var h = m * 60;
+var d = h * 24;
+var y = d * 365.25;
+
+/**
+ * Parse or format the given `val`.
+ *
+ * Options:
+ *
+ *  - `long` verbose formatting [false]
+ *
+ * @param {String|Number} val
+ * @param {Object} [options]
+ * @throws {Error} throw an error if val is not a non-empty string or a number
+ * @return {String|Number}
+ * @api public
+ */
+
+module.exports = function(val, options) {
+  options = options || {};
+  var type = typeof val;
+  if (type === 'string' && val.length > 0) {
+    return parse(val);
+  } else if (type === 'number' && isNaN(val) === false) {
+    return options.long ? fmtLong(val) : fmtShort(val);
+  }
+  throw new Error(
+    'val is not a non-empty string or a valid number. val=' +
+      JSON.stringify(val)
+  );
+};
+
+/**
+ * Parse the given `str` and return milliseconds.
+ *
+ * @param {String} str
+ * @return {Number}
+ * @api private
+ */
+
+function parse(str) {
+  str = String(str);
+  if (str.length > 100) {
+    return;
+  }
+  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
+    str
+  );
+  if (!match) {
+    return;
+  }
+  var n = parseFloat(match[1]);
+  var type = (match[2] || 'ms').toLowerCase();
+  switch (type) {
+    case 'years':
+    case 'year':
+    case 'yrs':
+    case 'yr':
+    case 'y':
+      return n * y;
+    case 'days':
+    case 'day':
+    case 'd':
+      return n * d;
+    case 'hours':
+    case 'hour':
+    case 'hrs':
+    case 'hr':
+    case 'h':
+      return n * h;
+    case 'minutes':
+    case 'minute':
+    case 'mins':
+    case 'min':
+    case 'm':
+      return n * m;
+    case 'seconds':
+    case 'second':
+    case 'secs':
+    case 'sec':
+    case 's':
+      return n * s;
+    case 'milliseconds':
+    case 'millisecond':
+    case 'msecs':
+    case 'msec':
+    case 'ms':
+      return n;
+    default:
+      return undefined;
+  }
+}
+
+/**
+ * Short format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtShort(ms) {
+  if (ms >= d) {
+    return Math.round(ms / d) + 'd';
+  }
+  if (ms >= h) {
+    return Math.round(ms / h) + 'h';
+  }
+  if (ms >= m) {
+    return Math.round(ms / m) + 'm';
+  }
+  if (ms >= s) {
+    return Math.round(ms / s) + 's';
+  }
+  return ms + 'ms';
+}
+
+/**
+ * Long format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtLong(ms) {
+  return plural(ms, d, 'day') ||
+    plural(ms, h, 'hour') ||
+    plural(ms, m, 'minute') ||
+    plural(ms, s, 'second') ||
+    ms + ' ms';
+}
+
+/**
+ * Pluralization helper.
+ */
+
+function plural(ms, n, name) {
+  if (ms < n) {
+    return;
+  }
+  if (ms < n * 1.5) {
+    return Math.floor(ms / n) + ' ' + name;
+  }
+  return Math.ceil(ms / n) + ' ' + name + 's';
+}
+
+},{}],24:[function(require,module,exports){
 /**
  * Module dependencies.
  */
@@ -5686,7 +5858,7 @@
   });
 };
 
-},{"./keys":24,"./utf8":25,"after":1,"arraybuffer.slice":2,"base64-arraybuffer":4,"blob":6,"has-binary2":26}],24:[function(require,module,exports){
+},{"./keys":25,"./utf8":26,"after":1,"arraybuffer.slice":2,"base64-arraybuffer":4,"blob":6,"has-binary2":27}],25:[function(require,module,exports){
 
 /**
  * Gets the keys for an object.
@@ -5707,7 +5879,7 @@
   return arr;
 };
 
-},{}],25:[function(require,module,exports){
+},{}],26:[function(require,module,exports){
 /*! https://mths.be/utf8js v2.1.2 by @mathias */
 
 var stringFromCharCode = String.fromCharCode;
@@ -5919,7 +6091,7 @@
 	decode: utf8decode
 };
 
-},{}],26:[function(require,module,exports){
+},{}],27:[function(require,module,exports){
 (function (Buffer){
 /* global Blob File */
 
@@ -5987,7 +6159,14 @@
 }
 
 }).call(this,require("buffer").Buffer)
-},{"buffer":8,"isarray":30}],27:[function(require,module,exports){
+},{"buffer":8,"isarray":28}],28:[function(require,module,exports){
+var toString = {}.toString;
+
+module.exports = Array.isArray || function (arr) {
+  return toString.call(arr) == '[object Array]';
+};
+
+},{}],29:[function(require,module,exports){
 
 /**
  * Module exports.
@@ -6006,7 +6185,7 @@
   module.exports = false;
 }
 
-},{}],28:[function(require,module,exports){
+},{}],30:[function(require,module,exports){
 exports.read = function (buffer, offset, isLE, mLen, nBytes) {
   var e, m
   var eLen = (nBytes * 8) - mLen - 1
@@ -6092,7 +6271,7 @@
   buffer[offset + i - d] |= s * 128
 }
 
-},{}],29:[function(require,module,exports){
+},{}],31:[function(require,module,exports){
 
 var indexOf = [].indexOf;
 
@@ -6103,14 +6282,7 @@
   }
   return -1;
 };
-},{}],30:[function(require,module,exports){
-var toString = {}.toString;
-
-module.exports = Array.isArray || function (arr) {
-  return toString.call(arr) == '[object Array]';
-};
-
-},{}],31:[function(require,module,exports){
+},{}],32:[function(require,module,exports){
 //! moment.js
 
 ;(function (global, factory) {
@@ -7255,22 +7427,36 @@
     function createDate (y, m, d, h, M, s, ms) {
         // can't just apply() to create a date:
         // https://stackoverflow.com/q/181348
-        var date = new Date(y, m, d, h, M, s, ms);
-
+        var date;
         // the date constructor remaps years 0-99 to 1900-1999
-        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
-            date.setFullYear(y);
+        if (y < 100 && y >= 0) {
+            // preserve leap years using a full 400 year cycle, then reset
+            date = new Date(y + 400, m, d, h, M, s, ms);
+            if (isFinite(date.getFullYear())) {
+                date.setFullYear(y);
+            }
+        } else {
+            date = new Date(y, m, d, h, M, s, ms);
         }
+
         return date;
     }
 
     function createUTCDate (y) {
-        var date = new Date(Date.UTC.apply(null, arguments));
-
+        var date;
         // the Date.UTC function remaps years 0-99 to 1900-1999
-        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
-            date.setUTCFullYear(y);
+        if (y < 100 && y >= 0) {
+            var args = Array.prototype.slice.call(arguments);
+            // preserve leap years using a full 400 year cycle, then reset
+            args[0] = y + 400;
+            date = new Date(Date.UTC.apply(null, args));
+            if (isFinite(date.getUTCFullYear())) {
+                date.setUTCFullYear(y);
+            }
+        } else {
+            date = new Date(Date.UTC.apply(null, arguments));
         }
+
         return date;
     }
 
@@ -7372,7 +7558,7 @@
 
     var defaultLocaleWeek = {
         dow : 0, // Sunday is the first day of the week.
-        doy : 6  // The week that contains Jan 1st is the first week of the year.
+        doy : 6  // The week that contains Jan 6th is the first week of the year.
     };
 
     function localeFirstDayOfWeek () {
@@ -7481,25 +7667,28 @@
     }
 
     // LOCALES
+    function shiftWeekdays (ws, n) {
+        return ws.slice(n, 7).concat(ws.slice(0, n));
+    }
 
     var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
     function localeWeekdays (m, format) {
-        if (!m) {
-            return isArray(this._weekdays) ? this._weekdays :
-                this._weekdays['standalone'];
-        }
-        return isArray(this._weekdays) ? this._weekdays[m.day()] :
-            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
+        var weekdays = isArray(this._weekdays) ? this._weekdays :
+            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
+        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
+            : (m) ? weekdays[m.day()] : weekdays;
     }
 
     var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
     function localeWeekdaysShort (m) {
-        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
+        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
+            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
     }
 
     var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
     function localeWeekdaysMin (m) {
-        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
+        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
+            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
     }
 
     function handleStrictParse$1(weekdayName, format, strict) {
@@ -8248,13 +8437,13 @@
                     weekdayOverflow = true;
                 }
             } else if (w.e != null) {
-                // local weekday -- counting starts from begining of week
+                // local weekday -- counting starts from beginning of week
                 weekday = w.e + dow;
                 if (w.e < 0 || w.e > 6) {
                     weekdayOverflow = true;
                 }
             } else {
-                // default to begining of week
+                // default to beginning of week
                 weekday = dow;
             }
         }
@@ -8848,7 +9037,7 @@
             years = normalizedInput.year || 0,
             quarters = normalizedInput.quarter || 0,
             months = normalizedInput.month || 0,
-            weeks = normalizedInput.week || 0,
+            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
             days = normalizedInput.day || 0,
             hours = normalizedInput.hour || 0,
             minutes = normalizedInput.minute || 0,
@@ -9141,7 +9330,7 @@
             } else {
                 duration.milliseconds = input;
             }
-        } else if (match = aspNetRegex.exec(input)) {
+        } else if (!!(match = aspNetRegex.exec(input))) {
             sign = (match[1] === '-') ? -1 : 1;
             duration = {
                 y  : 0,
@@ -9151,8 +9340,8 @@
                 s  : toInt(match[SECOND])                       * sign,
                 ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
             };
-        } else if (match = isoRegex.exec(input)) {
-            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
+        } else if (!!(match = isoRegex.exec(input))) {
+            sign = (match[1] === '-') ? -1 : 1;
             duration = {
                 y : parseIso(match[2], sign),
                 M : parseIso(match[3], sign),
@@ -9194,7 +9383,7 @@
     }
 
     function positiveMomentsDifference(base, other) {
-        var res = {milliseconds: 0, months: 0};
+        var res = {};
 
         res.months = other.month() - base.month() +
             (other.year() - base.year()) * 12;
@@ -9303,7 +9492,7 @@
         if (!(this.isValid() && localInput.isValid())) {
             return false;
         }
-        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
+        units = normalizeUnits(units) || 'millisecond';
         if (units === 'millisecond') {
             return this.valueOf() > localInput.valueOf();
         } else {
@@ -9316,7 +9505,7 @@
         if (!(this.isValid() && localInput.isValid())) {
             return false;
         }
-        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
+        units = normalizeUnits(units) || 'millisecond';
         if (units === 'millisecond') {
             return this.valueOf() < localInput.valueOf();
         } else {
@@ -9325,9 +9514,14 @@
     }
 
     function isBetween (from, to, units, inclusivity) {
+        var localFrom = isMoment(from) ? from : createLocal(from),
+            localTo = isMoment(to) ? to : createLocal(to);
+        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
+            return false;
+        }
         inclusivity = inclusivity || '()';
-        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
-            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
+        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
+            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
     }
 
     function isSame (input, units) {
@@ -9336,7 +9530,7 @@
         if (!(this.isValid() && localInput.isValid())) {
             return false;
         }
-        units = normalizeUnits(units || 'millisecond');
+        units = normalizeUnits(units) || 'millisecond';
         if (units === 'millisecond') {
             return this.valueOf() === localInput.valueOf();
         } else {
@@ -9346,11 +9540,11 @@
     }
 
     function isSameOrAfter (input, units) {
-        return this.isSame(input, units) || this.isAfter(input,units);
+        return this.isSame(input, units) || this.isAfter(input, units);
     }
 
     function isSameOrBefore (input, units) {
-        return this.isSame(input, units) || this.isBefore(input,units);
+        return this.isSame(input, units) || this.isBefore(input, units);
     }
 
     function diff (input, units, asFloat) {
@@ -9527,64 +9721,132 @@
         return this._locale;
     }
 
+    var MS_PER_SECOND = 1000;
+    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
+    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
+    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
+
+    // actual modulo - handles negative numbers (for dates before 1970):
+    function mod$1(dividend, divisor) {
+        return (dividend % divisor + divisor) % divisor;
+    }
+
+    function localStartOfDate(y, m, d) {
+        // the date constructor remaps years 0-99 to 1900-1999
+        if (y < 100 && y >= 0) {
+            // preserve leap years using a full 400 year cycle, then reset
+            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
+        } else {
+            return new Date(y, m, d).valueOf();
+        }
+    }
+
+    function utcStartOfDate(y, m, d) {
+        // Date.UTC remaps years 0-99 to 1900-1999
+        if (y < 100 && y >= 0) {
+            // preserve leap years using a full 400 year cycle, then reset
+            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
+        } else {
+            return Date.UTC(y, m, d);
+        }
+    }
+
     function startOf (units) {
+        var time;
         units = normalizeUnits(units);
-        // the following switch intentionally omits break keywords
-        // to utilize falling through the cases.
+        if (units === undefined || units === 'millisecond' || !this.isValid()) {
+            return this;
+        }
+
+        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
+
         switch (units) {
             case 'year':
-                this.month(0);
-                /* falls through */
+                time = startOfDate(this.year(), 0, 1);
+                break;
             case 'quarter':
+                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
+                break;
             case 'month':
-                this.date(1);
-                /* falls through */
+                time = startOfDate(this.year(), this.month(), 1);
+                break;
             case 'week':
+                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
+                break;
             case 'isoWeek':
+                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
+                break;
             case 'day':
             case 'date':
-                this.hours(0);
-                /* falls through */
+                time = startOfDate(this.year(), this.month(), this.date());
+                break;
             case 'hour':
-                this.minutes(0);
-                /* falls through */
+                time = this._d.valueOf();
+                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
+                break;
             case 'minute':
-                this.seconds(0);
-                /* falls through */
+                time = this._d.valueOf();
+                time -= mod$1(time, MS_PER_MINUTE);
+                break;
             case 'second':
-                this.milliseconds(0);
+                time = this._d.valueOf();
+                time -= mod$1(time, MS_PER_SECOND);
+                break;
         }
 
-        // weeks are a special case
-        if (units === 'week') {
-            this.weekday(0);
-        }
-        if (units === 'isoWeek') {
-            this.isoWeekday(1);
-        }
-
-        // quarters are also special
-        if (units === 'quarter') {
-            this.month(Math.floor(this.month() / 3) * 3);
-        }
-
+        this._d.setTime(time);
+        hooks.updateOffset(this, true);
         return this;
     }
 
     function endOf (units) {
+        var time;
         units = normalizeUnits(units);
-        if (units === undefined || units === 'millisecond') {
+        if (units === undefined || units === 'millisecond' || !this.isValid()) {
             return this;
         }
+
+        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
+
+        switch (units) {
+            case 'year':
+                time = startOfDate(this.year() + 1, 0, 1) - 1;
+                break;
+            case 'quarter':
+                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
+                break;
+            case 'month':
+                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
+                break;
+            case 'week':
+                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
+                break;
+            case 'isoWeek':
+                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
+                break;
+            case 'day':
+            case 'date':
+                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
+                break;
+            case 'hour':
+                time = this._d.valueOf();
+                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
+                break;
+            case 'minute':
+                time = this._d.valueOf();
+                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
+                break;
+            case 'second':
+                time = this._d.valueOf();
+                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
+                break;
+        }
+
+        this._d.setTime(time);
+        hooks.updateOffset(this, true);
+        return this;
+    }
 
-        // 'date' is an alias for 'day', so it should be considered as such.
-        if (units === 'date') {
-            units = 'day';
-        }
-
-        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
-    }
-
     function valueOf () {
         return this._d.valueOf() - ((this._offset || 0) * 60000);
     }
@@ -10288,10 +10550,14 @@
 
         units = normalizeUnits(units);
 
-        if (units === 'month' || units === 'year') {
-            days   = this._days   + milliseconds / 864e5;
+        if (units === 'month' || units === 'quarter' || units === 'year') {
+            days = this._days + milliseconds / 864e5;
             months = this._months + daysToMonths(days);
-            return units === 'month' ? months : months / 12;
+            switch (units) {
+                case 'month':   return months;
+                case 'quarter': return months / 3;
+                case 'year':    return months / 12;
+            }
         } else {
             // handle milliseconds separately because of floating point math errors (issue #1867)
             days = this._days + Math.round(monthsToDays(this._months));
@@ -10334,6 +10600,7 @@
     var asDays         = makeAs('d');
     var asWeeks        = makeAs('w');
     var asMonths       = makeAs('M');
+    var asQuarters     = makeAs('Q');
     var asYears        = makeAs('y');
 
     function clone$1 () {
@@ -10525,6 +10792,7 @@
     proto$2.asDays         = asDays;
     proto$2.asWeeks        = asWeeks;
     proto$2.asMonths       = asMonths;
+    proto$2.asQuarters     = asQuarters;
     proto$2.asYears        = asYears;
     proto$2.valueOf        = valueOf$1;
     proto$2._bubble        = bubble;
@@ -10569,7 +10837,7 @@
     // Side effect imports
 
 
-    hooks.version = '2.22.2';
+    hooks.version = '2.24.0';
 
     setHookCallback(createLocal);
 
@@ -10610,7 +10878,7 @@
         TIME: 'HH:mm',                                  // <input type="time" />
         TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
         TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
-        WEEK: 'YYYY-[W]WW',                             // <input type="week" />
+        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
         MONTH: 'YYYY-MM'                                // <input type="month" />
     };
 
@@ -10618,160 +10886,6 @@
 
 })));
 
-},{}],32:[function(require,module,exports){
-/**
- * Helpers.
- */
-
-var s = 1000;
-var m = s * 60;
-var h = m * 60;
-var d = h * 24;
-var y = d * 365.25;
-
-/**
- * Parse or format the given `val`.
- *
- * Options:
- *
- *  - `long` verbose formatting [false]
- *
- * @param {String|Number} val
- * @param {Object} [options]
- * @throws {Error} throw an error if val is not a non-empty string or a number
- * @return {String|Number}
- * @api public
- */
-
-module.exports = function(val, options) {
-  options = options || {};
-  var type = typeof val;
-  if (type === 'string' && val.length > 0) {
-    return parse(val);
-  } else if (type === 'number' && isNaN(val) === false) {
-    return options.long ? fmtLong(val) : fmtShort(val);
-  }
-  throw new Error(
-    'val is not a non-empty string or a valid number. val=' +
-      JSON.stringify(val)
-  );
-};
-
-/**
- * Parse the given `str` and return milliseconds.
- *
- * @param {String} str
- * @return {Number}
- * @api private
- */
-
-function parse(str) {
-  str = String(str);
-  if (str.length > 100) {
-    return;
-  }
-  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
-    str
-  );
-  if (!match) {
-    return;
-  }
-  var n = parseFloat(match[1]);
-  var type = (match[2] || 'ms').toLowerCase();
-  switch (type) {
-    case 'years':
-    case 'year':
-    case 'yrs':
-    case 'yr':
-    case 'y':
-      return n * y;
-    case 'days':
-    case 'day':
-    case 'd':
-      return n * d;
-    case 'hours':
-    case 'hour':
-    case 'hrs':
-    case 'hr':
-    case 'h':
-      return n * h;
-    case 'minutes':
-    case 'minute':
-    case 'mins':
-    case 'min':
-    case 'm':
-      return n * m;
-    case 'seconds':
-    case 'second':
-    case 'secs':
-    case 'sec':
-    case 's':
-      return n * s;
-    case 'milliseconds':
-    case 'millisecond':
-    case 'msecs':
-    case 'msec':
-    case 'ms':
-      return n;
-    default:
-      return undefined;
-  }
-}
-
-/**
- * Short format for `ms`.
- *
- * @param {Number} ms
- * @return {String}
- * @api private
- */
-
-function fmtShort(ms) {
-  if (ms >= d) {
-    return Math.round(ms / d) + 'd';
-  }
-  if (ms >= h) {
-    return Math.round(ms / h) + 'h';
-  }
-  if (ms >= m) {
-    return Math.round(ms / m) + 'm';
-  }
-  if (ms >= s) {
-    return Math.round(ms / s) + 's';
-  }
-  return ms + 'ms';
-}
-
-/**
- * Long format for `ms`.
- *
- * @param {Number} ms
- * @return {String}
- * @api private
- */
-
-function fmtLong(ms) {
-  return plural(ms, d, 'day') ||
-    plural(ms, h, 'hour') ||
-    plural(ms, m, 'minute') ||
-    plural(ms, s, 'second') ||
-    ms + ' ms';
-}
-
-/**
- * Pluralization helper.
- */
-
-function plural(ms, n, name) {
-  if (ms < n) {
-    return;
-  }
-  if (ms < n * 1.5) {
-    return Math.floor(ms / n) + ' ' + name;
-  }
-  return Math.ceil(ms / n) + ' ' + name + 's';
-}
-
 },{}],33:[function(require,module,exports){
 /**
  * Compiles a querystring
@@ -11134,7 +11248,7 @@
 exports.Manager = require('./manager');
 exports.Socket = require('./socket');
 
-},{"./manager":37,"./socket":39,"./url":40,"debug":41,"socket.io-parser":44}],37:[function(require,module,exports){
+},{"./manager":37,"./socket":39,"./url":40,"debug":41,"socket.io-parser":45}],37:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -11709,7 +11823,7 @@
   this.emitAll('reconnect', attempt);
 };
 
-},{"./on":38,"./socket":39,"backo2":3,"component-bind":9,"component-emitter":10,"debug":41,"engine.io-client":12,"indexof":29,"socket.io-parser":44}],38:[function(require,module,exports){
+},{"./on":38,"./socket":39,"backo2":3,"component-bind":9,"component-emitter":10,"debug":41,"engine.io-client":12,"indexof":31,"socket.io-parser":45}],38:[function(require,module,exports){
 
 /**
  * Module exports.
@@ -12175,8 +12289,7 @@
   return this;
 };
 
-},{"./on":38,"component-bind":9,"component-emitter":10,"debug":41,"has-binary2":26,"parseqs":33,"socket.io-parser":44,"to-array":48}],40:[function(require,module,exports){
-(function (global){
+},{"./on":38,"component-bind":9,"component-emitter":10,"debug":41,"has-binary2":27,"parseqs":33,"socket.io-parser":45,"to-array":51}],40:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -12204,7 +12317,7 @@
   var obj = uri;
 
   // default to window.location
-  loc = loc || global.location;
+  loc = loc || (typeof location !== 'undefined' && location);
   if (null == uri) uri = loc.protocol + '//' + loc.host;
 
   // relative path support
@@ -12253,13 +12366,13 @@
   return obj;
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
 },{"debug":41,"parseuri":34}],41:[function(require,module,exports){
 arguments[4][21][0].apply(exports,arguments)
 },{"./debug":42,"_process":35,"dup":21}],42:[function(require,module,exports){
 arguments[4][22][0].apply(exports,arguments)
-},{"dup":22,"ms":32}],43:[function(require,module,exports){
-(function (global){
+},{"dup":22,"ms":43}],43:[function(require,module,exports){
+arguments[4][23][0].apply(exports,arguments)
+},{"dup":23}],44:[function(require,module,exports){
 /*global Blob,File*/
 
 /**
@@ -12269,8 +12382,8 @@
 var isArray = require('isarray');
 var isBuf = require('./is-buffer');
 var toString = Object.prototype.toString;
-var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
-var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';
+var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
+var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');
 
 /**
  * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
@@ -12402,8 +12515,7 @@
   }
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./is-buffer":45,"isarray":30}],44:[function(require,module,exports){
+},{"./is-buffer":46,"isarray":49}],45:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -12635,7 +12747,7 @@
 Emitter(Decoder.prototype);
 
 /**
- * Decodes an ecoded packet string into packet JSON.
+ * Decodes an encoded packet string into packet JSON.
  *
  * @param {String} obj - encoded packet
  * @return {Object} packet
@@ -12656,8 +12768,7 @@
     } else { // non-binary full packet
       this.emit('decoded', packet);
     }
-  }
-  else if (isBuf(obj) || obj.base64) { // raw binary data
+  } else if (isBuf(obj) || obj.base64) { // raw binary data
     if (!this.reconstructor) {
       throw new Error('got binary data when not reconstructing a packet');
     } else {
@@ -12667,8 +12778,7 @@
         this.emit('decoded', packet);
       }
     }
-  }
-  else {
+  } else {
     throw new Error('Unknown type: ' + obj);
   }
 };
@@ -12822,21 +12932,17 @@
   };
 }
 
-},{"./binary":43,"./is-buffer":45,"component-emitter":10,"debug":46,"isarray":30}],45:[function(require,module,exports){
-(function (global){
+},{"./binary":44,"./is-buffer":46,"component-emitter":10,"debug":47,"isarray":49}],46:[function(require,module,exports){
+(function (Buffer){
 
 module.exports = isBuf;
 
-var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';
-var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';
+var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
+var withNativeArrayBuffer = typeof ArrayBuffer === 'function';
 
-var isView = (function () {
-  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {
-    return global.ArrayBuffer.isView;
-  } else {
-    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };
-  }
-})();
+var isView = function (obj) {
+  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
+};
 
 /**
  * Returns true if obj is a buffer or an arraybuffer.
@@ -12845,16 +12951,20 @@
  */
 
 function isBuf(obj) {
-  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||
-          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));
+  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
+          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{}],46:[function(require,module,exports){
+}).call(this,require("buffer").Buffer)
+},{"buffer":8}],47:[function(require,module,exports){
 arguments[4][21][0].apply(exports,arguments)
-},{"./debug":47,"_process":35,"dup":21}],47:[function(require,module,exports){
+},{"./debug":48,"_process":35,"dup":21}],48:[function(require,module,exports){
 arguments[4][22][0].apply(exports,arguments)
-},{"dup":22,"ms":32}],48:[function(require,module,exports){
+},{"dup":22,"ms":50}],49:[function(require,module,exports){
+arguments[4][28][0].apply(exports,arguments)
+},{"dup":28}],50:[function(require,module,exports){
+arguments[4][23][0].apply(exports,arguments)
+},{"dup":23}],51:[function(require,module,exports){
 module.exports = toArray
 
 function toArray(list, index) {
@@ -12869,7 +12979,7 @@
     return array
 }
 
-},{}],49:[function(require,module,exports){
+},{}],52:[function(require,module,exports){
 'use strict';
 
 var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
@@ -12939,7 +13049,7 @@
 yeast.decode = decode;
 module.exports = yeast;
 
-},{}],50:[function(require,module,exports){
+},{}],53:[function(require,module,exports){
 /* eslint-disable no-console */
 const io = require('socket.io-client');
 
@@ -13238,7 +13348,7 @@
 
 window.addEventListener('beforeunload', disconnectFromSocket);
 
-},{"./src/constants":51,"./src/statisticsDrawers":52,"./src/userDrawers":53,"./src/usersStatistics":54,"./src/utils":55,"socket.io-client":36}],51:[function(require,module,exports){
+},{"./src/constants":54,"./src/statisticsDrawers":55,"./src/userDrawers":56,"./src/usersStatistics":57,"./src/utils":58,"socket.io-client":36}],54:[function(require,module,exports){
 const QUEUE = 'queue';
 const CUSTOMERS = 'customers';
 const OPERATORS = 'operators';
@@ -13464,7 +13574,7 @@
   unauthorized: '#B0BEC5',
 };
 
-},{}],52:[function(require,module,exports){
+},{}],55:[function(require,module,exports){
 const { TYPES } = require('./constants');
 
 const drawersMap = {
@@ -13572,7 +13682,7 @@
   drawCall,
 };
 
-},{"./constants":51}],53:[function(require,module,exports){
+},{"./constants":54}],56:[function(require,module,exports){
 const { TYPES } = require('./constants');
 
 const START_FIRST_CALL_ADDITIONAL_DELAY = 5000;
@@ -13692,7 +13802,7 @@
   drawOperatorsFrames,
 };
 
-},{"./constants":51}],54:[function(require,module,exports){
+},{"./constants":54}],57:[function(require,module,exports){
 /* eslint-disable no-console */
 const moment = require('moment');
 const { TYPES, FIELDS } = require('./constants');
@@ -14366,7 +14476,7 @@
   drawCall(id, updates);
 }
 
-},{"./constants":51,"./statisticsDrawers":52,"./utils":55,"moment":31}],55:[function(require,module,exports){
+},{"./constants":54,"./statisticsDrawers":55,"./utils":58,"moment":32}],58:[function(require,module,exports){
 /* eslint-disable no-console */
 const { DEFAULT_STATISTICS, TYPES, FIELDS } = require('./constants');
 
@@ -14456,4 +14566,4 @@
   getNowSeconds,
 };
 
-},{"./constants":51}]},{},[50]);
+},{"./constants":54}]},{},[53]);
Index: src/public/js/customer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/public/js/customer.js	(date 1566483545000)
+++ src/public/js/customer.js	(date 1566550233000)
@@ -234,7 +234,7 @@
 exports.HandshakeProtocol = HandshakeProtocol;
 
 }).call(this,require("buffer").Buffer)
-},{"./TextMessageFormat":17,"./Utils":18,"buffer":82}],5:[function(require,module,exports){
+},{"./TextMessageFormat":17,"./Utils":18,"buffer":48}],5:[function(require,module,exports){
 "use strict";
 // Copyright (c) .NET Foundation. All rights reserved.
 // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
@@ -600,7 +600,7 @@
                         transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);
                         if (!(typeof transport === "number")) return [3 /*break*/, 8];
                         this.transport = this.constructTransport(transport);
-                        if (negotiateResponse.connectionId) return [3 /*break*/, 5];
+                        if (!!negotiateResponse.connectionId) return [3 /*break*/, 5];
                         return [4 /*yield*/, this.getNegotiationResponse(url)];
                     case 4:
                         negotiateResponse = _a.sent();
@@ -1925,7 +1925,7 @@
 exports.NodeHttpClient = NodeHttpClient;
 
 }).call(this,require("buffer").Buffer)
-},{"./Errors":3,"./HttpClient":5,"./ILogger":10,"./Utils":18,"buffer":82}],16:[function(require,module,exports){
+},{"./Errors":3,"./HttpClient":5,"./ILogger":10,"./Utils":18,"buffer":48}],16:[function(require,module,exports){
 "use strict";
 // Copyright (c) .NET Foundation. All rights reserved.
 // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
@@ -2617,11574 +2617,6 @@
 exports.JsonHubProtocol = JsonHubProtocol_1.JsonHubProtocol;
 
 },{"./DefaultHttpClient":2,"./Errors":3,"./HttpClient":5,"./HubConnection":7,"./HubConnectionBuilder":8,"./IHubProtocol":9,"./ILogger":10,"./ITransport":11,"./JsonHubProtocol":12,"./Loggers":13}],22:[function(require,module,exports){
-module.exports={
-  "_args": [
-    [
-      "@twilio/sip.js@0.7.7",
-      "/Users/vsmoliy/Desktop/xys-vsp-be-video"
-    ]
-  ],
-  "_from": "@twilio/sip.js@0.7.7",
-  "_id": "@twilio/sip.js@0.7.7",
-  "_inBundle": false,
-  "_integrity": "sha1-z/UPZvmyldRvIZc3tyeAx9Dm31I=",
-  "_location": "/@twilio/sip.js",
-  "_phantomChildren": {},
-  "_requested": {
-    "type": "version",
-    "registry": true,
-    "raw": "@twilio/sip.js@0.7.7",
-    "name": "@twilio/sip.js",
-    "escapedName": "@twilio%2fsip.js",
-    "scope": "@twilio",
-    "rawSpec": "0.7.7",
-    "saveSpec": null,
-    "fetchSpec": "0.7.7"
-  },
-  "_requiredBy": [
-    "/twilio-video"
-  ],
-  "_resolved": "https://registry.npmjs.org/@twilio/sip.js/-/sip.js-0.7.7.tgz",
-  "_spec": "0.7.7",
-  "_where": "/Users/vsmoliy/Desktop/xys-vsp-be-video",
-  "author": {
-    "name": "OnSIP",
-    "email": "developer@onsip.com",
-    "url": "http://sipjs.com/authors/"
-  },
-  "browser": {
-    "./src/environment.js": "./src/environment_browser.js"
-  },
-  "bugs": {
-    "url": "https://github.com/onsip/SIP.js/issues"
-  },
-  "contributors": [
-    {
-      "url": "https://github.com/onsip/SIP.js/blob/master/THANKS.md"
-    }
-  ],
-  "description": "A simple, intuitive, and powerful JavaScript signaling library",
-  "devDependencies": {
-    "beefy": "^2.1.5",
-    "browserify": "^4.1.8",
-    "grunt": "~0.4.0",
-    "grunt-browserify": "^4.0.1",
-    "grunt-cli": "~0.1.6",
-    "grunt-contrib-copy": "^0.5.0",
-    "grunt-contrib-jasmine": "^1.0.3",
-    "grunt-contrib-jshint": ">0.5.0",
-    "grunt-contrib-uglify": "~0.2.0",
-    "grunt-peg": "~1.3.1",
-    "grunt-trimtrailingspaces": "^0.4.0",
-    "pegjs": "^0.8.0",
-    "release-tool": "^0.2.2"
-  },
-  "engines": {
-    "node": ">=0.12"
-  },
-  "homepage": "http://sipjs.com",
-  "keywords": [
-    "sip",
-    "websocket",
-    "webrtc",
-    "library",
-    "javascript"
-  ],
-  "license": "MIT",
-  "main": "src/index.js",
-  "name": "@twilio/sip.js",
-  "repository": {
-    "type": "git",
-    "url": "git+https://github.com/onsip/SIP.js.git"
-  },
-  "scripts": {
-    "build": "grunt build",
-    "repl": "beefy test/repl.js --open",
-    "test": "grunt travis --verbose"
-  },
-  "title": "SIP.js",
-  "version": "0.7.7"
-}
-
-},{}],23:[function(require,module,exports){
-"use strict";
-module.exports = function (SIP) {
-var ClientContext;
-
-ClientContext = function (ua, method, target, options) {
-  var originalTarget = target;
-
-  // Validate arguments
-  if (target === undefined) {
-    throw new TypeError('Not enough arguments');
-  }
-
-  this.ua = ua;
-  this.logger = ua.getLogger('sip.clientcontext');
-  this.method = method;
-  target = ua.normalizeTarget(target);
-  if (!target) {
-    throw new TypeError('Invalid target: ' + originalTarget);
-  }
-
-  /* Options
-   * - extraHeaders
-   * - params
-   * - contentType
-   * - body
-   */
-  options = Object.create(options || Object.prototype);
-  options.extraHeaders = (options.extraHeaders || []).slice();
-
-  // Build the request
-  this.request = new SIP.OutgoingRequest(this.method,
-                                         target,
-                                         this.ua,
-                                         options.params,
-                                         options.extraHeaders);
-  if (options.body) {
-    this.body = {};
-    this.body.body = options.body;
-    if (options.contentType) {
-      this.body.contentType = options.contentType;
-    }
-    this.request.body = this.body;
-  }
-
-  /* Set other properties from the request */
-  this.localIdentity = this.request.from;
-  this.remoteIdentity = this.request.to;
-
-  this.data = {};
-};
-ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);
-
-ClientContext.prototype.send = function () {
-  (new SIP.RequestSender(this, this.ua)).send();
-  return this;
-};
-
-ClientContext.prototype.cancel = function (options) {
-  options = options || {};
-
-  options.extraHeaders = (options.extraHeaders || []).slice();
-
-  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
-  this.request.cancel(cancel_reason, options.extraHeaders);
-
-  this.emit('cancel');
-};
-
-ClientContext.prototype.receiveResponse = function (response) {
-  var cause = SIP.Utils.getReasonPhrase(response.status_code);
-
-  switch(true) {
-    case /^1[0-9]{2}$/.test(response.status_code):
-      this.emit('progress', response, cause);
-      break;
-
-    case /^2[0-9]{2}$/.test(response.status_code):
-      if(this.ua.applicants[this]) {
-        delete this.ua.applicants[this];
-      }
-      this.emit('accepted', response, cause);
-      break;
-
-    default:
-      if(this.ua.applicants[this]) {
-        delete this.ua.applicants[this];
-      }
-      this.emit('rejected', response, cause);
-      this.emit('failed', response, cause);
-      break;
-  }
-
-};
-
-ClientContext.prototype.onRequestTimeout = function () {
-  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
-};
-
-ClientContext.prototype.onTransportError = function () {
-  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
-};
-
-SIP.ClientContext = ClientContext;
-};
-
-},{}],24:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP Constants
- */
-
-/**
- * SIP Constants.
- * @augments SIP
- */
-
-module.exports = function (name, version) {
-return {
-  USER_AGENT: name +'/'+ version,
-
-  // SIP scheme
-  SIP:  'sip',
-  SIPS: 'sips',
-
-  // End and Failure causes
-  causes: {
-    // Generic error causes
-    CONNECTION_ERROR:         'Connection Error',
-    REQUEST_TIMEOUT:          'Request Timeout',
-    SIP_FAILURE_CODE:         'SIP Failure Code',
-    INTERNAL_ERROR:           'Internal Error',
-
-    // SIP error causes
-    BUSY:                     'Busy',
-    REJECTED:                 'Rejected',
-    REDIRECTED:               'Redirected',
-    UNAVAILABLE:              'Unavailable',
-    NOT_FOUND:                'Not Found',
-    ADDRESS_INCOMPLETE:       'Address Incomplete',
-    INCOMPATIBLE_SDP:         'Incompatible SDP',
-    AUTHENTICATION_ERROR:     'Authentication Error',
-    DIALOG_ERROR:             'Dialog Error',
-
-    // Session error causes
-    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
-    WEBRTC_ERROR:             'WebRTC Error',
-    CANCELED:                 'Canceled',
-    NO_ANSWER:                'No Answer',
-    EXPIRES:                  'Expires',
-    NO_ACK:                   'No ACK',
-    NO_PRACK:                 'No PRACK',
-    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
-    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
-    RTP_TIMEOUT:              'RTP Timeout'
-  },
-
-  supported: {
-    UNSUPPORTED:        'none',
-    SUPPORTED:          'supported',
-    REQUIRED:           'required'
-  },
-
-  SIP_ERROR_CAUSES: {
-    REDIRECTED: [300,301,302,305,380],
-    BUSY: [486,600],
-    REJECTED: [403,603],
-    NOT_FOUND: [404,604],
-    UNAVAILABLE: [480,410,408,430],
-    ADDRESS_INCOMPLETE: [484],
-    INCOMPATIBLE_SDP: [488,606],
-    AUTHENTICATION_ERROR:[401,407]
-  },
-
-  // SIP Methods
-  ACK:        'ACK',
-  BYE:        'BYE',
-  CANCEL:     'CANCEL',
-  INFO:       'INFO',
-  INVITE:     'INVITE',
-  MESSAGE:    'MESSAGE',
-  NOTIFY:     'NOTIFY',
-  OPTIONS:    'OPTIONS',
-  REGISTER:   'REGISTER',
-  UPDATE:     'UPDATE',
-  SUBSCRIBE:  'SUBSCRIBE',
-  REFER:      'REFER',
-  PRACK:      'PRACK',
-
-  /* SIP Response Reasons
-   * DOC: http://www.iana.org/assignments/sip-parameters
-   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
-   */
-  REASON_PHRASE: {
-    100: 'Trying',
-    180: 'Ringing',
-    181: 'Call Is Being Forwarded',
-    182: 'Queued',
-    183: 'Session Progress',
-    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
-    200: 'OK',
-    202: 'Accepted',  // RFC 3265
-    204: 'No Notification',  //RFC 5839
-    300: 'Multiple Choices',
-    301: 'Moved Permanently',
-    302: 'Moved Temporarily',
-    305: 'Use Proxy',
-    380: 'Alternative Service',
-    400: 'Bad Request',
-    401: 'Unauthorized',
-    402: 'Payment Required',
-    403: 'Forbidden',
-    404: 'Not Found',
-    405: 'Method Not Allowed',
-    406: 'Not Acceptable',
-    407: 'Proxy Authentication Required',
-    408: 'Request Timeout',
-    410: 'Gone',
-    412: 'Conditional Request Failed',  // RFC 3903
-    413: 'Request Entity Too Large',
-    414: 'Request-URI Too Long',
-    415: 'Unsupported Media Type',
-    416: 'Unsupported URI Scheme',
-    417: 'Unknown Resource-Priority',  // RFC 4412
-    420: 'Bad Extension',
-    421: 'Extension Required',
-    422: 'Session Interval Too Small',  // RFC 4028
-    423: 'Interval Too Brief',
-    428: 'Use Identity Header',  // RFC 4474
-    429: 'Provide Referrer Identity',  // RFC 3892
-    430: 'Flow Failed',  // RFC 5626
-    433: 'Anonymity Disallowed',  // RFC 5079
-    436: 'Bad Identity-Info',  // RFC 4474
-    437: 'Unsupported Certificate',  // RFC 4744
-    438: 'Invalid Identity Header',  // RFC 4744
-    439: 'First Hop Lacks Outbound Support',  // RFC 5626
-    440: 'Max-Breadth Exceeded',  // RFC 5393
-    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
-    470: 'Consent Needed',  // RFC 5360
-    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
-    480: 'Temporarily Unavailable',
-    481: 'Call/Transaction Does Not Exist',
-    482: 'Loop Detected',
-    483: 'Too Many Hops',
-    484: 'Address Incomplete',
-    485: 'Ambiguous',
-    486: 'Busy Here',
-    487: 'Request Terminated',
-    488: 'Not Acceptable Here',
-    489: 'Bad Event',  // RFC 3265
-    491: 'Request Pending',
-    493: 'Undecipherable',
-    494: 'Security Agreement Required',  // RFC 3329
-    500: 'Internal Server Error',
-    501: 'Not Implemented',
-    502: 'Bad Gateway',
-    503: 'Service Unavailable',
-    504: 'Server Time-out',
-    505: 'Version Not Supported',
-    513: 'Message Too Large',
-    580: 'Precondition Failure',  // RFC 3312
-    600: 'Busy Everywhere',
-    603: 'Decline',
-    604: 'Does Not Exist Anywhere',
-    606: 'Not Acceptable'
-  },
-
-  /* SIP Option Tags
-   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
-   */
-  OPTION_TAGS: {
-    '100rel':                   true,  // RFC 3262
-    199:                        true,  // RFC 6228
-    answermode:                 true,  // RFC 5373
-    'early-session':            true,  // RFC 3959
-    eventlist:                  true,  // RFC 4662
-    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
-    'from-change':              true,  // RFC 4916
-    'geolocation-http':         true,  // RFC 6442
-    'geolocation-sip':          true,  // RFC 6442
-    gin:                        true,  // RFC 6140
-    gruu:                       true,  // RFC 5627
-    histinfo:                   true,  // RFC 7044
-    ice:                        true,  // RFC 5768
-    join:                       true,  // RFC 3911
-    'multiple-refer':           true,  // RFC 5368
-    norefersub:                 true,  // RFC 4488
-    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
-    outbound:                   true,  // RFC 5626
-    path:                       true,  // RFC 3327
-    policy:                     true,  // RFC 6794
-    precondition:               true,  // RFC 3312
-    pref:                       true,  // RFC 3840
-    privacy:                    true,  // RFC 3323
-    'recipient-list-invite':    true,  // RFC 5366
-    'recipient-list-message':   true,  // RFC 5365
-    'recipient-list-subscribe': true,  // RFC 5367
-    replaces:                   true,  // RFC 3891
-    'resource-priority':        true,  // RFC 4412
-    'sdp-anat':                 true,  // RFC 4092
-    'sec-agree':                true,  // RFC 3329
-    tdialog:                    true,  // RFC 4538
-    timer:                      true,  // RFC 4028
-    uui:                        true   // RFC 7433
-  }
-};
-};
-
-},{}],25:[function(require,module,exports){
-"use strict";
-
-/**
- * @fileoverview In-Dialog Request Sender
- */
-
-/**
- * @augments SIP.Dialog
- * @class Class creating an In-dialog request sender.
- * @param {SIP.Dialog} dialog
- * @param {Object} applicant
- * @param {SIP.OutgoingRequest} request
- */
-/**
- * @fileoverview in-Dialog Request Sender
- */
-
-module.exports = function (SIP) {
-var RequestSender;
-
-RequestSender = function(dialog, applicant, request) {
-
-  this.dialog = dialog;
-  this.applicant = applicant;
-  this.request = request;
-
-  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
-  this.reattempt = false;
-  this.reattemptTimer = null;
-};
-
-RequestSender.prototype = {
-  send: function() {
-    var self = this,
-      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);
-
-      request_sender.send();
-
-    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
-    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
-      this.dialog.uac_pending_reply = true;
-      request_sender.clientTransaction.on('stateChanged', function stateChanged(){
-        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
-            this.state === SIP.Transactions.C.STATUS_COMPLETED ||
-            this.state === SIP.Transactions.C.STATUS_TERMINATED) {
-
-          this.removeListener('stateChanged', stateChanged);
-          self.dialog.uac_pending_reply = false;
-
-          if (self.dialog.uas_pending_reply === false) {
-            self.dialog.owner.onReadyToReinvite();
-          }
-        }
-      });
-    }
-  },
-
-  onRequestTimeout: function() {
-    this.applicant.onRequestTimeout();
-  },
-
-  onTransportError: function() {
-    this.applicant.onTransportError();
-  },
-
-  receiveResponse: function(response) {
-    var self = this;
-
-    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
-    if (response.status_code === 408 || response.status_code === 481) {
-      this.applicant.onDialogError(response);
-    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {
-      if (this.reattempt) {
-        this.applicant.receiveResponse(response);
-      } else {
-        this.request.cseq.value = this.dialog.local_seqnum += 1;
-        this.reattemptTimer = SIP.Timers.setTimeout(
-          function() {
-            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {
-              self.reattempt = true;
-              self.request_sender.send();
-            }
-          },
-          this.getReattemptTimeout()
-        );
-      }
-    } else {
-      this.applicant.receiveResponse(response);
-    }
-  }
-};
-
-return RequestSender;
-};
-
-},{}],26:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP Dialog
- */
-
-/**
- * @augments SIP
- * @class Class creating a SIP dialog.
- * @param {SIP.RTCSession} owner
- * @param {SIP.IncomingRequest|SIP.IncomingResponse} message
- * @param {Enum} type UAC / UAS
- * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED
- */
-module.exports = function (SIP) {
-
-var RequestSender = require('./Dialog/RequestSender')(SIP);
-
-var Dialog,
-  C = {
-    // Dialog states
-    STATUS_EARLY:       1,
-    STATUS_CONFIRMED:   2
-  };
-
-// RFC 3261 12.1
-Dialog = function(owner, message, type, state) {
-  var contact;
-
-  this.uac_pending_reply = false;
-  this.uas_pending_reply = false;
-
-  if(!message.hasHeader('contact')) {
-    return {
-      error: 'unable to create a Dialog without Contact header field'
-    };
-  }
-
-  if(message instanceof SIP.IncomingResponse) {
-    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
-  } else {
-    // Create confirmed dialog if state is not defined
-    state = state || C.STATUS_CONFIRMED;
-  }
-
-  contact = message.parseHeader('contact');
-
-  // RFC 3261 12.1.1
-  if(type === 'UAS') {
-    this.id = {
-      call_id: message.call_id,
-      local_tag: message.to_tag,
-      remote_tag: message.from_tag,
-      toString: function() {
-        return this.call_id + this.local_tag + this.remote_tag;
-      }
-    };
-    this.state = state;
-    this.remote_seqnum = message.cseq;
-    this.local_uri = message.parseHeader('to').uri;
-    this.remote_uri = message.parseHeader('from').uri;
-    this.remote_target = contact.uri;
-    this.route_set = message.getHeaders('record-route');
-    this.invite_seqnum = message.cseq;
-    this.local_seqnum = message.cseq;
-  }
-  // RFC 3261 12.1.2
-  else if(type === 'UAC') {
-    this.id = {
-      call_id: message.call_id,
-      local_tag: message.from_tag,
-      remote_tag: message.to_tag,
-      toString: function() {
-        return this.call_id + this.local_tag + this.remote_tag;
-      }
-    };
-    this.state = state;
-    this.invite_seqnum = message.cseq;
-    this.local_seqnum = message.cseq;
-    this.local_uri = message.parseHeader('from').uri;
-    this.pracked = [];
-    this.remote_uri = message.parseHeader('to').uri;
-    this.remote_target = contact.uri;
-    this.route_set = message.getHeaders('record-route').reverse();
-
-    //RENDERBODY
-    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {
-      this.mediaHandler = owner.mediaHandlerFactory(owner);
-    }
-  }
-
-  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());
-  this.owner = owner;
-  owner.ua.dialogs[this.id.toString()] = this;
-  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
-  owner.emit('dialog', this);
-};
-
-Dialog.prototype = {
-  /**
-   * @param {SIP.IncomingMessage} message
-   * @param {Enum} UAC/UAS
-   */
-  update: function(message, type) {
-    this.state = C.STATUS_CONFIRMED;
-
-    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');
-
-    if(type === 'UAC') {
-      // RFC 3261 13.2.2.4
-      this.route_set = message.getHeaders('record-route').reverse();
-    }
-  },
-
-  terminate: function() {
-    this.logger.log('dialog ' + this.id.toString() + ' deleted');
-    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {
-      this.mediaHandler.peerConnection.close();
-    }
-    delete this.owner.ua.dialogs[this.id.toString()];
-  },
-
-  /**
-  * @param {String} method request method
-  * @param {Object} extraHeaders extra headers
-  * @returns {SIP.OutgoingRequest}
-  */
-
-  // RFC 3261 12.2.1.1
-  createRequest: function(method, extraHeaders, body) {
-    var cseq, request;
-    extraHeaders = (extraHeaders || []).slice();
-
-    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }
-
-    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;
-
-    request = new SIP.OutgoingRequest(
-      method,
-      this.remote_target,
-      this.owner.ua, {
-        'cseq': cseq,
-        'call_id': this.id.call_id,
-        'from_uri': this.local_uri,
-        'from_tag': this.id.local_tag,
-        'to_uri': this.remote_uri,
-        'to_tag': this.id.remote_tag,
-        'route_set': this.route_set
-      }, extraHeaders, body);
-
-    request.dialog = this;
-
-    return request;
-  },
-
-  /**
-  * @param {SIP.IncomingRequest} request
-  * @returns {Boolean}
-  */
-
-  // RFC 3261 12.2.2
-  checkInDialogRequest: function(request) {
-    var self = this;
-
-    if(!this.remote_seqnum) {
-      this.remote_seqnum = request.cseq;
-    } else if(request.cseq < this.remote_seqnum) {
-        //Do not try to reply to an ACK request.
-        if (request.method !== SIP.C.ACK) {
-          request.reply(500);
-        }
-        if (request.cseq === this.invite_seqnum) {
-          return true;
-        }
-        return false;
-    } else if(request.cseq > this.remote_seqnum) {
-      this.remote_seqnum = request.cseq;
-    }
-
-    switch(request.method) {
-      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
-      case SIP.C.INVITE:
-        if (this.uac_pending_reply === true) {
-          request.reply(491);
-        } else if (this.uas_pending_reply === true) {
-          var retryAfter = (Math.random() * 10 | 0) + 1;
-          request.reply(500, null, ['Retry-After:' + retryAfter]);
-          return false;
-        } else {
-          this.uas_pending_reply = true;
-          request.server_transaction.on('stateChanged', function stateChanged(){
-            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
-                this.state === SIP.Transactions.C.STATUS_COMPLETED ||
-                this.state === SIP.Transactions.C.STATUS_TERMINATED) {
-
-              this.removeListener('stateChanged', stateChanged);
-              self.uas_pending_reply = false;
-
-              if (self.uac_pending_reply === false) {
-                self.owner.onReadyToReinvite();
-              }
-            }
-          });
-        }
-
-        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
-        if(request.hasHeader('contact')) {
-          request.server_transaction.on('stateChanged', function(){
-            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {
-              self.remote_target = request.parseHeader('contact').uri;
-            }
-          });
-        }
-        break;
-      case SIP.C.NOTIFY:
-        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
-        if(request.hasHeader('contact')) {
-          request.server_transaction.on('stateChanged', function(){
-            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {
-              self.remote_target = request.parseHeader('contact').uri;
-            }
-          });
-        }
-        break;
-    }
-
-    return true;
-  },
-
-  sendRequest: function(applicant, method, options) {
-    options = options || {};
-
-    var extraHeaders = (options.extraHeaders || []).slice();
-
-    var body = null;
-    if (options.body) {
-      if (options.body.body) {
-        body = options.body;
-      } else {
-        body = {};
-        body.body = options.body;
-        if (options.contentType) {
-          body.contentType = options.contentType;
-        }
-      }
-    }
-
-    var request = this.createRequest(method, extraHeaders, body),
-      request_sender = new RequestSender(this, applicant, request);
-
-    request_sender.send();
-
-    return request;
-  },
-
-  /**
-  * @param {SIP.IncomingRequest} request
-  */
-  receiveRequest: function(request) {
-    //Check in-dialog request
-    if(!this.checkInDialogRequest(request)) {
-      return;
-    }
-
-    this.owner.receiveRequest(request);
-  }
-};
-
-Dialog.C = C;
-SIP.Dialog = Dialog;
-};
-
-},{"./Dialog/RequestSender":25}],27:[function(require,module,exports){
-"use strict";
-
-/**
- * @fileoverview SIP Digest Authentication
- */
-
-/**
- * SIP Digest Authentication.
- * @augments SIP.
- * @function Digest Authentication
- * @param {SIP.UA} ua
- */
-module.exports = function (Utils) {
-var DigestAuthentication;
-
-DigestAuthentication = function(ua) {
-  this.logger = ua.getLogger('sipjs.digestauthentication');
-  this.username = ua.configuration.authorizationUser;
-  this.password = ua.configuration.password;
-  this.cnonce = null;
-  this.nc = 0;
-  this.ncHex = '00000000';
-  this.response = null;
-};
-
-
-/**
-* Performs Digest authentication given a SIP request and the challenge
-* received in a response to that request.
-* Returns true if credentials were successfully generated, false otherwise.
-*
-* @param {SIP.OutgoingRequest} request
-* @param {Object} challenge
-*/
-DigestAuthentication.prototype.authenticate = function(request, challenge) {
-  // Inspect and validate the challenge.
-
-  this.algorithm = challenge.algorithm;
-  this.realm = challenge.realm;
-  this.nonce = challenge.nonce;
-  this.opaque = challenge.opaque;
-  this.stale = challenge.stale;
-
-  if (this.algorithm) {
-    if (this.algorithm !== 'MD5') {
-      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
-      return false;
-    }
-  } else {
-    this.algorithm = 'MD5';
-  }
-
-  if (! this.realm) {
-    this.logger.warn('challenge without Digest realm, authentication aborted');
-    return false;
-  }
-
-  if (! this.nonce) {
-    this.logger.warn('challenge without Digest nonce, authentication aborted');
-    return false;
-  }
-
-  // 'qop' can contain a list of values (Array). Let's choose just one.
-  if (challenge.qop) {
-    if (challenge.qop.indexOf('auth') > -1) {
-      this.qop = 'auth';
-    } else if (challenge.qop.indexOf('auth-int') > -1) {
-      this.qop = 'auth-int';
-    } else {
-      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
-      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
-      return false;
-    }
-  } else {
-    this.qop = null;
-  }
-
-  // Fill other attributes.
-
-  this.method = request.method;
-  this.uri = request.ruri;
-  this.cnonce = Utils.createRandomToken(12);
-  this.nc += 1;
-  this.updateNcHex();
-
-  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
-  if (this.nc === 4294967296) {
-    this.nc = 1;
-    this.ncHex = '00000001';
-  }
-
-  // Calculate the Digest "response" value.
-  this.calculateResponse();
-
-  return true;
-};
-
-
-/**
-* Generate Digest 'response' value.
-* @private
-*/
-DigestAuthentication.prototype.calculateResponse = function() {
-  var ha1, ha2;
-
-  // HA1 = MD5(A1) = MD5(username:realm:password)
-  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);
-
-  if (this.qop === 'auth') {
-    // HA2 = MD5(A2) = MD5(method:digestURI)
-    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
-    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
-    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
-
-  } else if (this.qop === 'auth-int') {
-    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
-    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
-    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
-    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
-
-  } else if (this.qop === null) {
-    // HA2 = MD5(A2) = MD5(method:digestURI)
-    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
-    // response = MD5(HA1:nonce:HA2)
-    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
-  }
-};
-
-
-/**
-* Return the Proxy-Authorization or WWW-Authorization header value.
-*/
-DigestAuthentication.prototype.toString = function() {
-  var auth_params = [];
-
-  if (! this.response) {
-    throw new Error('response field does not exist, cannot generate Authorization header');
-  }
-
-  auth_params.push('algorithm=' + this.algorithm);
-  auth_params.push('username="' + this.username + '"');
-  auth_params.push('realm="' + this.realm + '"');
-  auth_params.push('nonce="' + this.nonce + '"');
-  auth_params.push('uri="' + this.uri + '"');
-  auth_params.push('response="' + this.response + '"');
-  if (this.opaque) {
-    auth_params.push('opaque="' + this.opaque + '"');
-  }
-  if (this.qop) {
-    auth_params.push('qop=' + this.qop);
-    auth_params.push('cnonce="' + this.cnonce + '"');
-    auth_params.push('nc=' + this.ncHex);
-  }
-
-  return 'Digest ' + auth_params.join(', ');
-};
-
-
-/**
-* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
-* @private
-*/
-DigestAuthentication.prototype.updateNcHex = function() {
-  var hex = Number(this.nc).toString(16);
-  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
-};
-
-return DigestAuthentication;
-};
-
-},{}],28:[function(require,module,exports){
-"use strict";
-var NodeEventEmitter = require('events').EventEmitter;
-
-module.exports = function (console) {
-
-// Don't use `new SIP.EventEmitter()` for inheriting.
-// Use Object.create(SIP.EventEmitter.prototoype);
-function EventEmitter () {
-  NodeEventEmitter.call(this);
-}
-
-EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {
-  constructor: {
-    value: EventEmitter,
-    enumerable: false,
-    writable: true,
-    configurable: true
-  }
-});
-
-EventEmitter.prototype.off = function off (eventName, listener) {
-  var warning = '';
-  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\n';
-  warning += 'Please use removeListener or removeAllListeners instead.\n';
-  warning += 'See here for more details:\n';
-  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';
-  console.warn(warning);
-
-  if (arguments.length < 2) {
-    return this.removeAllListeners.apply(this, arguments);
-  } else {
-    return this.removeListener(eventName, listener);
-  }
-};
-
-return EventEmitter;
-
-};
-
-},{"events":100}],29:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview Exceptions
- */
-
-/**
- * SIP Exceptions.
- * @augments SIP
- */
-module.exports = {
-  ConfigurationError: (function(){
-    var exception = function(parameter, value) {
-      this.code = 1;
-      this.name = 'CONFIGURATION_ERROR';
-      this.parameter = parameter;
-      this.value = value;
-      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
-    };
-    exception.prototype = new Error();
-    return exception;
-  }()),
-
-  InvalidStateError: (function(){
-    var exception = function(status) {
-      this.code = 2;
-      this.name = 'INVALID_STATE_ERROR';
-      this.status = status;
-      this.message = 'Invalid status: ' + status;
-    };
-    exception.prototype = new Error();
-    return exception;
-  }()),
-
-  NotSupportedError: (function(){
-    var exception = function(message) {
-      this.code = 3;
-      this.name = 'NOT_SUPPORTED_ERROR';
-      this.message = message;
-    };
-    exception.prototype = new Error();
-    return exception;
-  }()),
-
-  GetDescriptionError: (function(){
-    var exception = function(message) {
-      this.code = 4;
-      this.name = 'GET_DESCRIPTION_ERROR';
-      this.message = message;
-    };
-    exception.prototype = new Error();
-    return exception;
-  }())
-};
-
-},{}],30:[function(require,module,exports){
-"use strict";
-var Grammar = require('./Grammar/dist/Grammar');
-
-module.exports = function (SIP) {
-
-return {
-  parse: function parseCustom (input, startRule) {
-    var options = {startRule: startRule, SIP: SIP};
-    try {
-      Grammar.parse(input, options);
-    } catch (e) {
-      options.data = -1;
-    }
-    return options.data;
-  }
-};
-
-};
-
-},{"./Grammar/dist/Grammar":31}],31:[function(require,module,exports){
-module.exports = (function() {
-  /*
-   * Generated by PEG.js 0.8.0.
-   *
-   * http://pegjs.majda.cz/
-   */
-
-  function peg$subclass(child, parent) {
-    function ctor() { this.constructor = child; }
-    ctor.prototype = parent.prototype;
-    child.prototype = new ctor();
-  }
-
-  function SyntaxError(message, expected, found, offset, line, column) {
-    this.message  = message;
-    this.expected = expected;
-    this.found    = found;
-    this.offset   = offset;
-    this.line     = line;
-    this.column   = column;
-
-    this.name     = "SyntaxError";
-  }
-
-  peg$subclass(SyntaxError, Error);
-
-  function parse(input) {
-    var options = arguments.length > 1 ? arguments[1] : {},
-
-        peg$FAILED = {},
-
-        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },
-        peg$startRuleIndex   = 118,
-
-        peg$consts = [
-          "\r\n",
-          { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
-          /^[0-9]/,
-          { type: "class", value: "[0-9]", description: "[0-9]" },
-          /^[a-zA-Z]/,
-          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
-          /^[0-9a-fA-F]/,
-          { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
-          /^[\0-\xFF]/,
-          { type: "class", value: "[\\0-\\xFF]", description: "[\\0-\\xFF]" },
-          /^["]/,
-          { type: "class", value: "[\"]", description: "[\"]" },
-          " ",
-          { type: "literal", value: " ", description: "\" \"" },
-          "\t",
-          { type: "literal", value: "\t", description: "\"\\t\"" },
-          /^[a-zA-Z0-9]/,
-          { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
-          ";",
-          { type: "literal", value: ";", description: "\";\"" },
-          "/",
-          { type: "literal", value: "/", description: "\"/\"" },
-          "?",
-          { type: "literal", value: "?", description: "\"?\"" },
-          ":",
-          { type: "literal", value: ":", description: "\":\"" },
-          "@",
-          { type: "literal", value: "@", description: "\"@\"" },
-          "&",
-          { type: "literal", value: "&", description: "\"&\"" },
-          "=",
-          { type: "literal", value: "=", description: "\"=\"" },
-          "+",
-          { type: "literal", value: "+", description: "\"+\"" },
-          "$",
-          { type: "literal", value: "$", description: "\"$\"" },
-          ",",
-          { type: "literal", value: ",", description: "\",\"" },
-          "-",
-          { type: "literal", value: "-", description: "\"-\"" },
-          "_",
-          { type: "literal", value: "_", description: "\"_\"" },
-          ".",
-          { type: "literal", value: ".", description: "\".\"" },
-          "!",
-          { type: "literal", value: "!", description: "\"!\"" },
-          "~",
-          { type: "literal", value: "~", description: "\"~\"" },
-          "*",
-          { type: "literal", value: "*", description: "\"*\"" },
-          "'",
-          { type: "literal", value: "'", description: "\"'\"" },
-          "(",
-          { type: "literal", value: "(", description: "\"(\"" },
-          ")",
-          { type: "literal", value: ")", description: "\")\"" },
-          peg$FAILED,
-          "%",
-          { type: "literal", value: "%", description: "\"%\"" },
-          null,
-          [],
-          function() {return " "; },
-          function() {return ':'; },
-          /^[!-~]/,
-          { type: "class", value: "[!-~]", description: "[!-~]" },
-          /^[\x80-\uFFFF]/,
-          { type: "class", value: "[\\x80-\\uFFFF]", description: "[\\x80-\\uFFFF]" },
-          /^[\x80-\xBF]/,
-          { type: "class", value: "[\\x80-\\xBF]", description: "[\\x80-\\xBF]" },
-          /^[a-f]/,
-          { type: "class", value: "[a-f]", description: "[a-f]" },
-          "`",
-          { type: "literal", value: "`", description: "\"`\"" },
-          "<",
-          { type: "literal", value: "<", description: "\"<\"" },
-          ">",
-          { type: "literal", value: ">", description: "\">\"" },
-          "\\",
-          { type: "literal", value: "\\", description: "\"\\\\\"" },
-          "[",
-          { type: "literal", value: "[", description: "\"[\"" },
-          "]",
-          { type: "literal", value: "]", description: "\"]\"" },
-          "{",
-          { type: "literal", value: "{", description: "\"{\"" },
-          "}",
-          { type: "literal", value: "}", description: "\"}\"" },
-          function() {return "*"; },
-          function() {return "/"; },
-          function() {return "="; },
-          function() {return "("; },
-          function() {return ")"; },
-          function() {return ">"; },
-          function() {return "<"; },
-          function() {return ","; },
-          function() {return ";"; },
-          function() {return ":"; },
-          function() {return "\""; },
-          /^[!-']/,
-          { type: "class", value: "[!-']", description: "[!-']" },
-          /^[*-[]/,
-          { type: "class", value: "[*-[]", description: "[*-[]" },
-          /^[\]-~]/,
-          { type: "class", value: "[\\]-~]", description: "[\\]-~]" },
-          function(contents) {
-                                  return contents; },
-          /^[#-[]/,
-          { type: "class", value: "[#-[]", description: "[#-[]" },
-          /^[\0-\t]/,
-          { type: "class", value: "[\\0-\\t]", description: "[\\0-\\t]" },
-          /^[\x0B-\f]/,
-          { type: "class", value: "[\\x0B-\\f]", description: "[\\x0B-\\f]" },
-          /^[\x0E-]/,
-          { type: "class", value: "[\\x0E-]", description: "[\\x0E-]" },
-          function() {
-                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
-                                  delete options.data.scheme;
-                                  delete options.data.user;
-                                  delete options.data.host;
-                                  delete options.data.host_type;
-                                  delete options.data.port;
-                                },
-          function() {
-                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
-                                  delete options.data.scheme;
-                                  delete options.data.user;
-                                  delete options.data.host;
-                                  delete options.data.host_type;
-                                  delete options.data.port;
-                                  delete options.data.uri_params;
-
-                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}
-                                },
-          "sips",
-          { type: "literal", value: "sips", description: "\"sips\"" },
-          "sip",
-          { type: "literal", value: "sip", description: "\"sip\"" },
-          function(uri_scheme) {
-                              options.data.scheme = uri_scheme; },
-          function() {
-                              options.data.user = decodeURIComponent(text().slice(0, -1));},
-          function() {
-                              options.data.password = text(); },
-          function() {
-                              options.data.host = text();
-                              return options.data.host; },
-          function() {
-                            options.data.host_type = 'domain';
-                            return text(); },
-          /^[a-zA-Z0-9_\-]/,
-          { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
-          /^[a-zA-Z0-9\-]/,
-          { type: "class", value: "[a-zA-Z0-9\\-]", description: "[a-zA-Z0-9\\-]" },
-          function() {
-                              options.data.host_type = 'IPv6';
-                              return text(); },
-          "::",
-          { type: "literal", value: "::", description: "\"::\"" },
-          function() {
-                            options.data.host_type = 'IPv6';
-                            return text(); },
-          function() {
-                              options.data.host_type = 'IPv4';
-                              return text(); },
-          "25",
-          { type: "literal", value: "25", description: "\"25\"" },
-          /^[0-5]/,
-          { type: "class", value: "[0-5]", description: "[0-5]" },
-          "2",
-          { type: "literal", value: "2", description: "\"2\"" },
-          /^[0-4]/,
-          { type: "class", value: "[0-4]", description: "[0-4]" },
-          "1",
-          { type: "literal", value: "1", description: "\"1\"" },
-          /^[1-9]/,
-          { type: "class", value: "[1-9]", description: "[1-9]" },
-          function(port) {
-                              port = parseInt(port.join(''));
-                              options.data.port = port;
-                              return port; },
-          "transport=",
-          { type: "literal", value: "transport=", description: "\"transport=\"" },
-          "udp",
-          { type: "literal", value: "udp", description: "\"udp\"" },
-          "tcp",
-          { type: "literal", value: "tcp", description: "\"tcp\"" },
-          "sctp",
-          { type: "literal", value: "sctp", description: "\"sctp\"" },
-          "tls",
-          { type: "literal", value: "tls", description: "\"tls\"" },
-          function(transport) {
-                                if(!options.data.uri_params) options.data.uri_params={};
-                                options.data.uri_params['transport'] = transport.toLowerCase(); },
-          "user=",
-          { type: "literal", value: "user=", description: "\"user=\"" },
-          "phone",
-          { type: "literal", value: "phone", description: "\"phone\"" },
-          "ip",
-          { type: "literal", value: "ip", description: "\"ip\"" },
-          function(user) {
-                                if(!options.data.uri_params) options.data.uri_params={};
-                                options.data.uri_params['user'] = user.toLowerCase(); },
-          "method=",
-          { type: "literal", value: "method=", description: "\"method=\"" },
-          function(method) {
-                                if(!options.data.uri_params) options.data.uri_params={};
-                                options.data.uri_params['method'] = method; },
-          "ttl=",
-          { type: "literal", value: "ttl=", description: "\"ttl=\"" },
-          function(ttl) {
-                                if(!options.data.params) options.data.params={};
-                                options.data.params['ttl'] = ttl; },
-          "maddr=",
-          { type: "literal", value: "maddr=", description: "\"maddr=\"" },
-          function(maddr) {
-                                if(!options.data.uri_params) options.data.uri_params={};
-                                options.data.uri_params['maddr'] = maddr; },
-          "lr",
-          { type: "literal", value: "lr", description: "\"lr\"" },
-          function() {
-                                if(!options.data.uri_params) options.data.uri_params={};
-                                options.data.uri_params['lr'] = undefined; },
-          function(param, value) {
-                                if(!options.data.uri_params) options.data.uri_params = {};
-                                if (value === null){
-                                  value = undefined;
-                                }
-                                else {
-                                  value = value[1];
-                                }
-                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},
-          function(hname, hvalue) {
-                                hname = hname.join('').toLowerCase();
-                                hvalue = hvalue.join('');
-                                if(!options.data.uri_headers) options.data.uri_headers = {};
-                                if (!options.data.uri_headers[hname]) {
-                                  options.data.uri_headers[hname] = [hvalue];
-                                } else {
-                                  options.data.uri_headers[hname].push(hvalue);
-                                }},
-          function() {
-                                // lots of tests fail if this isn't guarded...
-                                if (options.startRule === 'Refer_To') {
-                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
-                                  delete options.data.scheme;
-                                  delete options.data.user;
-                                  delete options.data.host;
-                                  delete options.data.host_type;
-                                  delete options.data.port;
-                                  delete options.data.uri_params;
-                                }
-                              },
-          "//",
-          { type: "literal", value: "//", description: "\"//\"" },
-          function() {
-                              options.data.scheme= text(); },
-          { type: "literal", value: "SIP", description: "\"SIP\"" },
-          function() {
-                              options.data.sip_version = text(); },
-          "INVITE",
-          { type: "literal", value: "INVITE", description: "\"INVITE\"" },
-          "ACK",
-          { type: "literal", value: "ACK", description: "\"ACK\"" },
-          "VXACH",
-          { type: "literal", value: "VXACH", description: "\"VXACH\"" },
-          "OPTIONS",
-          { type: "literal", value: "OPTIONS", description: "\"OPTIONS\"" },
-          "BYE",
-          { type: "literal", value: "BYE", description: "\"BYE\"" },
-          "CANCEL",
-          { type: "literal", value: "CANCEL", description: "\"CANCEL\"" },
-          "REGISTER",
-          { type: "literal", value: "REGISTER", description: "\"REGISTER\"" },
-          "SUBSCRIBE",
-          { type: "literal", value: "SUBSCRIBE", description: "\"SUBSCRIBE\"" },
-          "NOTIFY",
-          { type: "literal", value: "NOTIFY", description: "\"NOTIFY\"" },
-          "REFER",
-          { type: "literal", value: "REFER", description: "\"REFER\"" },
-          function() {
-
-                              options.data.method = text();
-                              return options.data.method; },
-          function(status_code) {
-                            options.data.status_code = parseInt(status_code.join('')); },
-          function() {
-                            options.data.reason_phrase = text(); },
-          function() {
-                        options.data = text(); },
-          function() {
-                                  var idx, length;
-                                  length = options.data.multi_header.length;
-                                  for (idx = 0; idx < length; idx++) {
-                                    if (options.data.multi_header[idx].parsed === null) {
-                                      options.data = null;
-                                      break;
-                                    }
-                                  }
-                                  if (options.data !== null) {
-                                    options.data = options.data.multi_header;
-                                  } else {
-                                    options.data = -1;
-                                  }},
-          function() {
-                                  var header;
-                                  if(!options.data.multi_header) options.data.multi_header = [];
-                                  try {
-                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
-                                    delete options.data.uri;
-                                    delete options.data.displayName;
-                                    delete options.data.params;
-                                  } catch(e) {
-                                    header = null;
-                                  }
-                                  options.data.multi_header.push( { 'position': peg$currPos,
-                                                            'offset': offset(),
-                                                            'parsed': header
-                                                          });},
-          function(displayName) {
-                                  displayName = text().trim();
-                                  if (displayName[0] === '\"') {
-                                    displayName = displayName.substring(1, displayName.length-1);
-                                  }
-                                  options.data.displayName = displayName; },
-          "q",
-          { type: "literal", value: "q", description: "\"q\"" },
-          function(q) {
-                                  if(!options.data.params) options.data.params = {};
-                                  options.data.params['q'] = q; },
-          "expires",
-          { type: "literal", value: "expires", description: "\"expires\"" },
-          function(expires) {
-                                  if(!options.data.params) options.data.params = {};
-                                  options.data.params['expires'] = expires; },
-          function(delta_seconds) {
-                                  return parseInt(delta_seconds.join('')); },
-          "0",
-          { type: "literal", value: "0", description: "\"0\"" },
-          function() {
-                                  return parseFloat(text()); },
-          function(param, value) {
-                                  if(!options.data.params) options.data.params = {};
-                                  if (value === null){
-                                    value = undefined;
-                                  }
-                                  else {
-                                    value = value[1];
-                                  }
-                                  options.data.params[param.toLowerCase()] = value;},
-          "render",
-          { type: "literal", value: "render", description: "\"render\"" },
-          "session",
-          { type: "literal", value: "session", description: "\"session\"" },
-          "icon",
-          { type: "literal", value: "icon", description: "\"icon\"" },
-          "alert",
-          { type: "literal", value: "alert", description: "\"alert\"" },
-          function() {
-                                      if (options.startRule === 'Content_Disposition') {
-                                        options.data.type = text().toLowerCase();
-                                      }
-                                    },
-          "handling",
-          { type: "literal", value: "handling", description: "\"handling\"" },
-          "optional",
-          { type: "literal", value: "optional", description: "\"optional\"" },
-          "required",
-          { type: "literal", value: "required", description: "\"required\"" },
-          function(length) {
-                                  options.data = parseInt(length.join('')); },
-          function() {
-                                  options.data = text(); },
-          "text",
-          { type: "literal", value: "text", description: "\"text\"" },
-          "image",
-          { type: "literal", value: "image", description: "\"image\"" },
-          "audio",
-          { type: "literal", value: "audio", description: "\"audio\"" },
-          "video",
-          { type: "literal", value: "video", description: "\"video\"" },
-          "application",
-          { type: "literal", value: "application", description: "\"application\"" },
-          "message",
-          { type: "literal", value: "message", description: "\"message\"" },
-          "multipart",
-          { type: "literal", value: "multipart", description: "\"multipart\"" },
-          "x-",
-          { type: "literal", value: "x-", description: "\"x-\"" },
-          function(cseq_value) {
-                            options.data.value=parseInt(cseq_value.join('')); },
-          function(expires) {options.data = expires; },
-          function(event_type) {
-                                 options.data.event = event_type.toLowerCase(); },
-          function() {
-                          var tag = options.data.tag;
-                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
-                            if (tag) {options.data.setParam('tag',tag)}
-                          },
-          "tag",
-          { type: "literal", value: "tag", description: "\"tag\"" },
-          function(tag) {options.data.tag = tag; },
-          function(forwards) {
-                            options.data = parseInt(forwards.join('')); },
-          function(min_expires) {options.data = min_expires; },
-          function() {
-                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
-                                },
-          "digest",
-          { type: "literal", value: "Digest", description: "\"Digest\"" },
-          "realm",
-          { type: "literal", value: "realm", description: "\"realm\"" },
-          function(realm) { options.data.realm = realm; },
-          "domain",
-          { type: "literal", value: "domain", description: "\"domain\"" },
-          "nonce",
-          { type: "literal", value: "nonce", description: "\"nonce\"" },
-          function(nonce) { options.data.nonce=nonce; },
-          "opaque",
-          { type: "literal", value: "opaque", description: "\"opaque\"" },
-          function(opaque) { options.data.opaque=opaque; },
-          "stale",
-          { type: "literal", value: "stale", description: "\"stale\"" },
-          "true",
-          { type: "literal", value: "true", description: "\"true\"" },
-          function() { options.data.stale=true; },
-          "false",
-          { type: "literal", value: "false", description: "\"false\"" },
-          function() { options.data.stale=false; },
-          "algorithm",
-          { type: "literal", value: "algorithm", description: "\"algorithm\"" },
-          "md5",
-          { type: "literal", value: "MD5", description: "\"MD5\"" },
-          "md5-sess",
-          { type: "literal", value: "MD5-sess", description: "\"MD5-sess\"" },
-          function(algorithm) {
-                                options.data.algorithm=algorithm.toUpperCase(); },
-          "qop",
-          { type: "literal", value: "qop", description: "\"qop\"" },
-          "auth-int",
-          { type: "literal", value: "auth-int", description: "\"auth-int\"" },
-          "auth",
-          { type: "literal", value: "auth", description: "\"auth\"" },
-          function(qop_value) {
-                                  options.data.qop || (options.data.qop=[]);
-                                  options.data.qop.push(qop_value.toLowerCase()); },
-          function(rack_value) {
-                            options.data.value=parseInt(rack_value.join('')); },
-          function() {
-                            var idx, length;
-                            length = options.data.multi_header.length;
-                            for (idx = 0; idx < length; idx++) {
-                              if (options.data.multi_header[idx].parsed === null) {
-                                options.data = null;
-                                break;
-                              }
-                            }
-                            if (options.data !== null) {
-                              options.data = options.data.multi_header;
-                            } else {
-                              options.data = -1;
-                            }},
-          function() {
-                            var header;
-                            if(!options.data.multi_header) options.data.multi_header = [];
-                            try {
-                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
-                              delete options.data.uri;
-                              delete options.data.displayName;
-                              delete options.data.params;
-                            } catch(e) {
-                              header = null;
-                            }
-                            options.data.multi_header.push( { 'position': peg$currPos,
-                                                      'offset': offset(),
-                                                      'parsed': header
-                                                    });},
-          function() {
-                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
-                      },
-          function() {
-                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
-                                  options.data = -1;
-                                }
-                              },
-          function() {
-                                options.data = {
-                                  call_id: options.data
-                                };
-                              },
-          "from-tag",
-          { type: "literal", value: "from-tag", description: "\"from-tag\"" },
-          function(from_tag) {
-                                options.data.replaces_from_tag = from_tag;
-                              },
-          "to-tag",
-          { type: "literal", value: "to-tag", description: "\"to-tag\"" },
-          function(to_tag) {
-                                options.data.replaces_to_tag = to_tag;
-                              },
-          "early-only",
-          { type: "literal", value: "early-only", description: "\"early-only\"" },
-          function() {
-                                options.data.early_only = true;
-                              },
-          function(r) {return r;},
-          function(first, rest) { return list(first, rest); },
-          function(value) {
-                          if (options.startRule === 'Require') {
-                            options.data = value || [];
-                          }
-                        },
-          function(rseq_value) {
-                            options.data.value=parseInt(rseq_value.join('')); },
-          "active",
-          { type: "literal", value: "active", description: "\"active\"" },
-          "pending",
-          { type: "literal", value: "pending", description: "\"pending\"" },
-          "terminated",
-          { type: "literal", value: "terminated", description: "\"terminated\"" },
-          function() {
-                                  options.data.state = text(); },
-          "reason",
-          { type: "literal", value: "reason", description: "\"reason\"" },
-          function(reason) {
-                                  if (typeof reason !== 'undefined') options.data.reason = reason; },
-          function(expires) {
-                                  if (typeof expires !== 'undefined') options.data.expires = expires; },
-          "retry_after",
-          { type: "literal", value: "retry_after", description: "\"retry_after\"" },
-          function(retry_after) {
-                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },
-          "deactivated",
-          { type: "literal", value: "deactivated", description: "\"deactivated\"" },
-          "probation",
-          { type: "literal", value: "probation", description: "\"probation\"" },
-          "rejected",
-          { type: "literal", value: "rejected", description: "\"rejected\"" },
-          "timeout",
-          { type: "literal", value: "timeout", description: "\"timeout\"" },
-          "giveup",
-          { type: "literal", value: "giveup", description: "\"giveup\"" },
-          "noresource",
-          { type: "literal", value: "noresource", description: "\"noresource\"" },
-          "invariant",
-          { type: "literal", value: "invariant", description: "\"invariant\"" },
-          function(value) {
-                          if (options.startRule === 'Supported') {
-                            options.data = value || [];
-                          }
-                        },
-          function() {
-                        var tag = options.data.tag;
-                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
-                          if (tag) {options.data.setParam('tag',tag)}
-                        },
-          "ttl",
-          { type: "literal", value: "ttl", description: "\"ttl\"" },
-          function(via_ttl_value) {
-                                options.data.ttl = via_ttl_value; },
-          "maddr",
-          { type: "literal", value: "maddr", description: "\"maddr\"" },
-          function(via_maddr) {
-                                options.data.maddr = via_maddr; },
-          "received",
-          { type: "literal", value: "received", description: "\"received\"" },
-          function(via_received) {
-                                options.data.received = via_received; },
-          "branch",
-          { type: "literal", value: "branch", description: "\"branch\"" },
-          function(via_branch) {
-                                options.data.branch = via_branch; },
-          "rport",
-          { type: "literal", value: "rport", description: "\"rport\"" },
-          function() {
-                                if(typeof response_port !== 'undefined')
-                                  options.data.rport = response_port.join(''); },
-          function(via_protocol) {
-                                options.data.protocol = via_protocol; },
-          { type: "literal", value: "UDP", description: "\"UDP\"" },
-          { type: "literal", value: "TCP", description: "\"TCP\"" },
-          { type: "literal", value: "TLS", description: "\"TLS\"" },
-          { type: "literal", value: "SCTP", description: "\"SCTP\"" },
-          function(via_transport) {
-                                options.data.transport = via_transport; },
-          function() {
-                                options.data.host = text(); },
-          function(via_sent_by_port) {
-                                options.data.port = parseInt(via_sent_by_port.join('')); },
-          function(ttl) {
-                                return parseInt(ttl.join('')); },
-          function(deltaSeconds) {
-                                if (options.startRule === 'Session_Expires') {
-                                  options.data.deltaSeconds = deltaSeconds;
-                                }
-                              },
-          "refresher",
-          { type: "literal", value: "refresher", description: "\"refresher\"" },
-          "uas",
-          { type: "literal", value: "uas", description: "\"uas\"" },
-          "uac",
-          { type: "literal", value: "uac", description: "\"uac\"" },
-          function(endpoint) {
-                                if (options.startRule === 'Session_Expires') {
-                                  options.data.refresher = endpoint;
-                                }
-                              },
-          function(deltaSeconds) {
-                                if (options.startRule === 'Min_SE') {
-                                  options.data = deltaSeconds;
-                                }
-                              },
-          "stuns",
-          { type: "literal", value: "stuns", description: "\"stuns\"" },
-          "stun",
-          { type: "literal", value: "stun", description: "\"stun\"" },
-          function(scheme) {
-                                options.data.scheme = scheme; },
-          function(host) {
-                                options.data.host = host; },
-          "?transport=",
-          { type: "literal", value: "?transport=", description: "\"?transport=\"" },
-          "turns",
-          { type: "literal", value: "turns", description: "\"turns\"" },
-          "turn",
-          { type: "literal", value: "turn", description: "\"turn\"" },
-          function() {
-                                options.data.transport = transport; },
-          function() {
-                            options.data = text(); }
-        ],
-
-        peg$bytecode = [
-          peg$decode(". \"\"2 3!"),
-          peg$decode("0\"\"\"1!3#"),
-          peg$decode("0$\"\"1!3%"),
-          peg$decode("0&\"\"1!3'"),
-          peg$decode("7'*# \"7("),
-          peg$decode("0(\"\"1!3)"),
-          peg$decode("0*\"\"1!3+"),
-          peg$decode(".,\"\"2,3-"),
-          peg$decode("..\"\"2.3/"),
-          peg$decode("00\"\"1!31"),
-          peg$decode(".2\"\"2233*\x89 \".4\"\"2435*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
-          peg$decode("7)*# \"7,"),
-          peg$decode(".F\"\"2F3G*} \".H\"\"2H3I*q \".J\"\"2J3K*e \".L\"\"2L3M*Y \".N\"\"2N3O*M \".P\"\"2P3Q*A \".R\"\"2R3S*5 \".T\"\"2T3U*) \".V\"\"2V3W"),
-          peg$decode("!!.Y\"\"2Y3Z+7$7#+-%7#+#%'#%$## X$\"# X\"# X+! (%"),
-          peg$decode("!! \\7$,#&7$\"+-$7 +#%'\"%$\"# X\"# X*# \" [+@$ \\7$+&$,#&7$\"\"\" X+'%4\"6]\" %$\"# X\"# X"),
-          peg$decode("7.*# \" ["),
-          peg$decode("! \\7'*# \"7(,)&7'*# \"7(\"+A$.8\"\"2839+1%7/+'%4#6^# %$## X$\"# X\"# X"),
-          peg$decode("!! \\72+&$,#&72\"\"\" X+o$ \\! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X,@&! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
-          peg$decode("0_\"\"1!3`*# \"73"),
-          peg$decode("0a\"\"1!3b"),
-          peg$decode("0c\"\"1!3d"),
-          peg$decode("7!*) \"0e\"\"1!3f"),
-          peg$decode("! \\7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x9E$,\x9B&7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
-          peg$decode("! \\7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x92$,\x8F&7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
-          peg$decode(".T\"\"2T3U*\xE3 \".V\"\"2V3W*\xD7 \".i\"\"2i3j*\xCB \".k\"\"2k3l*\xBF \".:\"\"2:3;*\xB3 \".D\"\"2D3E*\xA7 \".2\"\"2233*\x9B \".8\"\"2839*\x8F \".m\"\"2m3n*\x83 \"7&*} \".4\"\"2435*q \".o\"\"2o3p*e \".q\"\"2q3r*Y \".6\"\"2637*M \".>\"\"2>3?*A \".s\"\"2s3t*5 \".u\"\"2u3v*) \"7'*# \"7("),
-          peg$decode("! \\7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v+\u0134$,\u0131&7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v\"\"\" X+! (%"),
-          peg$decode("!7/+A$.P\"\"2P3Q+1%7/+'%4#6w# %$## X$\"# X\"# X"),
-          peg$decode("!7/+A$.4\"\"2435+1%7/+'%4#6x# %$## X$\"# X\"# X"),
-          peg$decode("!7/+A$.>\"\"2>3?+1%7/+'%4#6y# %$## X$\"# X\"# X"),
-          peg$decode("!7/+A$.T\"\"2T3U+1%7/+'%4#6z# %$## X$\"# X\"# X"),
-          peg$decode("!7/+A$.V\"\"2V3W+1%7/+'%4#6{# %$## X$\"# X\"# X"),
-          peg$decode("!.k\"\"2k3l+1$7/+'%4\"6|\" %$\"# X\"# X"),
-          peg$decode("!7/+7$.i\"\"2i3j+'%4\"6}\" %$\"# X\"# X"),
-          peg$decode("!7/+A$.D\"\"2D3E+1%7/+'%4#6~# %$## X$\"# X\"# X"),
-          peg$decode("!7/+A$.2\"\"2233+1%7/+'%4#6# %$## X$\"# X\"# X"),
-          peg$decode("!7/+A$.8\"\"2839+1%7/+'%4#6\x80# %$## X$\"# X\"# X"),
-          peg$decode("!7/+1$7&+'%4\"6\x81\" %$\"# X\"# X"),
-          peg$decode("!7&+1$7/+'%4\"6\x81\" %$\"# X\"# X"),
-          peg$decode("!7=+W$ \\7G*) \"7K*# \"7F,/&7G*) \"7K*# \"7F\"+-%7>+#%'#%$## X$\"# X\"# X"),
-          peg$decode("0\x82\"\"1!3\x83*A \"0\x84\"\"1!3\x85*5 \"0\x86\"\"1!3\x87*) \"73*# \"7."),
-          peg$decode("!!7/+U$7&+K% \\7J*# \"7K,)&7J*# \"7K\"+-%7&+#%'$%$$# X$## X$\"# X\"# X+! (%"),
-          peg$decode("!7/+`$7&+V%! \\7J*# \"7K,)&7J*# \"7K\"+! (%+2%7&+(%4$6\x88$!!%$$# X$## X$\"# X\"# X"),
-          peg$decode("7.*G \".L\"\"2L3M*; \"0\x89\"\"1!3\x8A*/ \"0\x86\"\"1!3\x87*# \"73"),
-          peg$decode("!.m\"\"2m3n+K$0\x8B\"\"1!3\x8C*5 \"0\x8D\"\"1!3\x8E*) \"0\x8F\"\"1!3\x90+#%'\"%$\"# X\"# X"),
-          peg$decode("!7N+Q$.8\"\"2839+A%7O*# \" [+1%7S+'%4$6\x91$ %$$# X$## X$\"# X\"# X"),
-          peg$decode("!7N+k$.8\"\"2839+[%7O*# \" [+K%7S+A%7_+7%7l*# \" [+'%4&6\x92& %$&# X$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("!/\x93\"\"1$3\x94*) \"/\x95\"\"1#3\x96+' 4!6\x97!! %"),
-          peg$decode("!7P+b$!.8\"\"2839+-$7R+#%'\"%$\"# X\"# X*# \" [+7%.:\"\"2:3;+'%4#6\x98# %$## X$\"# X\"# X"),
-          peg$decode(" \\7+*) \"7-*# \"7Q+2$,/&7+*) \"7-*# \"7Q\"\"\" X"),
-          peg$decode(".<\"\"2<3=*q \".>\"\"2>3?*e \".@\"\"2@3A*Y \".B\"\"2B3C*M \".D\"\"2D3E*A \".2\"\"2233*5 \".6\"\"2637*) \".4\"\"2435"),
-          peg$decode("! \\7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E,e&7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E\"+& 4!6\x99! %"),
-          peg$decode("!7T+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
-          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\x9A! %"),
-          peg$decode("! \\!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X,>&!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X\"+G$7W+=%.J\"\"2J3K*# \" [+'%4#6\x9B# %$## X$\"# X\"# X"),
-          peg$decode(" \\0\x9C\"\"1!3\x9D+,$,)&0\x9C\"\"1!3\x9D\"\"\" X"),
-          peg$decode("!0$\"\"1!3%+A$ \\0\x9E\"\"1!3\x9F,)&0\x9E\"\"1!3\x9F\"+#%'\"%$\"# X\"# X"),
-          peg$decode("!.o\"\"2o3p+A$7Y+7%.q\"\"2q3r+'%4#6\xA0# %$## X$\"# X\"# X"),
-          peg$decode("!!7Z+\xBF$.8\"\"2839+\xAF%7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0838 \"!.\xA1\"\"2\xA13\xA2+\xAF$7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0795 \"!.\xA1\"\"2\xA13\xA2+\x95$7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u070C \"!.\xA1\"\"2\xA13\xA2+{$7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u069D \"!.\xA1\"\"2\xA13\xA2+a$7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X*\u0648 \"!.\xA1\"\"2\xA13\xA2+G$7Z+=%.8\"\"2839+-%7[+#%'$%$$# X$## X$\"# X\"# X*\u060D \"!.\xA1\"\"2\xA13\xA2+-$7[+#%'\"%$\"# X\"# X*\u05EC \"!.\xA1\"\"2\xA13\xA2+-$7Z+#%'\"%$\"# X\"# X*\u05CB \"!7Z+\xA5$.\xA1\"\"2\xA13\xA2+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0538 \"!7Z+\xB6$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x8B%.\xA1\"\"2\xA13\xA2+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0494 \"!7Z+\xC7$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x9C%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+q%.\xA1\"\"2\xA13\xA2+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u03DF \"!7Z+\xD8$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xAD%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x82%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+W%.\xA1\"\"2\xA13\xA2+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0319 \"!7Z+\xE9$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0242 \"!7Z+\u0114$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xE9%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0140 \"!7Z+\u0135$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\u010A%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xDF%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xB4%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x89%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+^%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+3%.\xA1\"\"2\xA13\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X+& 4!6\xA3! %"),
-          peg$decode("!7#+S$7#*# \" [+C%7#*# \" [+3%7#*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
-          peg$decode("!7Z+=$.8\"\"2839+-%7Z+#%'#%$## X$\"# X\"# X*# \"7\\"),
-          peg$decode("!7]+u$.J\"\"2J3K+e%7]+[%.J\"\"2J3K+K%7]+A%.J\"\"2J3K+1%7]+'%4'6\xA4' %$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("!.\xA5\"\"2\xA53\xA6+3$0\xA7\"\"1!3\xA8+#%'\"%$\"# X\"# X*\xA0 \"!.\xA9\"\"2\xA93\xAA+=$0\xAB\"\"1!3\xAC+-%7!+#%'#%$## X$\"# X\"# X*o \"!.\xAD\"\"2\xAD3\xAE+7$7!+-%7!+#%'#%$## X$\"# X\"# X*D \"!0\xAF\"\"1!3\xB0+-$7!+#%'\"%$\"# X\"# X*# \"7!"),
-          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\xB1!! %"),
-          peg$decode(" \\!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X\""),
-          peg$decode("7a*A \"7b*; \"7c*5 \"7d*/ \"7e*) \"7f*# \"7g"),
-          peg$decode("!/\xB2\"\"1*3\xB3+b$/\xB4\"\"1#3\xB5*G \"/\xB6\"\"1#3\xB7*; \"/\xB8\"\"1$3\xB9*/ \"/\xBA\"\"1#3\xBB*# \"76+(%4\"6\xBC\"! %$\"# X\"# X"),
-          peg$decode("!/\xBD\"\"1%3\xBE+J$/\xBF\"\"1%3\xC0*/ \"/\xC1\"\"1\"3\xC2*# \"76+(%4\"6\xC3\"! %$\"# X\"# X"),
-          peg$decode("!/\xC4\"\"1'3\xC5+2$7\x8F+(%4\"6\xC6\"! %$\"# X\"# X"),
-          peg$decode("!/\xC7\"\"1$3\xC8+2$7\xEF+(%4\"6\xC9\"! %$\"# X\"# X"),
-          peg$decode("!/\xCA\"\"1&3\xCB+2$7T+(%4\"6\xCC\"! %$\"# X\"# X"),
-          peg$decode("!/\xCD\"\"1\"3\xCE+R$!.>\"\"2>3?+-$76+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xCF\" %$\"# X\"# X"),
-          peg$decode("!7h+T$!.>\"\"2>3?+-$7i+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xD0\"\"! %$\"# X\"# X"),
-          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
-          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
-          peg$decode("7k*) \"7+*# \"7-"),
-          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".8\"\"2839*A \".<\"\"2<3=*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
-          peg$decode("!.6\"\"2637+u$7m+k% \\!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X,>&!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X\"+#%'#%$## X$\"# X\"# X"),
-          peg$decode("!7n+C$.>\"\"2>3?+3%7o+)%4#6\xD1#\"\" %$## X$\"# X\"# X"),
-          peg$decode(" \\7p*) \"7+*# \"7-+2$,/&7p*) \"7+*# \"7-\"\"\" X"),
-          peg$decode(" \\7p*) \"7+*# \"7-,/&7p*) \"7+*# \"7-\""),
-          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".6\"\"2637*A \".8\"\"2839*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
-          peg$decode("7\x90*# \"7r"),
-          peg$decode("!7\x8F+K$7'+A%7s+7%7'+-%7\x84+#%'%%$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("7M*# \"7t"),
-          peg$decode("!7+G$.8\"\"2839+7%7u*# \"7x+'%4#6\xD2# %$## X$\"# X\"# X"),
-          peg$decode("!7v*# \"7w+N$!.6\"\"2637+-$7\x83+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
-          peg$decode("!.\xD3\"\"2\xD33\xD4+=$7\x80+3%7w*# \" [+#%'#%$## X$\"# X\"# X"),
-          peg$decode("!.4\"\"2435+-$7{+#%'\"%$\"# X\"# X"),
-          peg$decode("!7z+5$ \\7y,#&7y\"+#%'\"%$\"# X\"# X"),
-          peg$decode("7**) \"7+*# \"7-"),
-          peg$decode("7+*\x8F \"7-*\x89 \".2\"\"2233*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
-          peg$decode("!7|+k$ \\!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X,>&!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("! \\7~,#&7~\"+k$ \\!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode(" \\7~,#&7~\""),
-          peg$decode("7+*w \"7-*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
-          peg$decode("!7\"+\x8D$ \\7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K,M&7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K\"+'%4\"6\xD5\" %$\"# X\"# X"),
-          peg$decode("7\x81*# \"7\x82"),
-          peg$decode("!!7O+3$.:\"\"2:3;+#%'\"%$\"# X\"# X*# \" [+-$7S+#%'\"%$\"# X\"# X*# \" ["),
-          peg$decode(" \\7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A+\x8C$,\x89&7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A\"\"\" X"),
-          peg$decode(" \\7y,#&7y\""),
-          peg$decode("!/\x95\"\"1#3\xD6+y$.4\"\"2435+i% \\7!+&$,#&7!\"\"\" X+P%.J\"\"2J3K+@% \\7!+&$,#&7!\"\"\" X+'%4%6\xD7% %$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode(".\xD8\"\"2\xD83\xD9"),
-          peg$decode(".\xDA\"\"2\xDA3\xDB"),
-          peg$decode(".\xDC\"\"2\xDC3\xDD"),
-          peg$decode(".\xDE\"\"2\xDE3\xDF"),
-          peg$decode(".\xE0\"\"2\xE03\xE1"),
-          peg$decode(".\xE2\"\"2\xE23\xE3"),
-          peg$decode(".\xE4\"\"2\xE43\xE5"),
-          peg$decode(".\xE6\"\"2\xE63\xE7"),
-          peg$decode(".\xE8\"\"2\xE83\xE9"),
-          peg$decode(".\xEA\"\"2\xEA3\xEB"),
-          peg$decode("!7\x85*S \"7\x86*M \"7\x88*G \"7\x89*A \"7\x8A*; \"7\x8B*5 \"7\x8C*/ \"7\x8D*) \"7\x8E*# \"76+& 4!6\xEC! %"),
-          peg$decode("!7\x84+K$7'+A%7\x91+7%7'+-%7\x93+#%'%%$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("!7\x92+' 4!6\xED!! %"),
-          peg$decode("!7!+7$7!+-%7!+#%'#%$## X$\"# X\"# X"),
-          peg$decode("! \\7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(,G&7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(\"+& 4!6\xEE! %"),
-          peg$decode("!7\xB5+_$ \\!7A+-$7\xB5+#%'\"%$\"# X\"# X,8&!7A+-$7\xB5+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("!79+R$!.:\"\"2:3;+-$79+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xEF\" %$\"# X\"# X"),
-          peg$decode("!7:*j \"!7\x97+_$ \\!7A+-$7\x97+#%'\"%$\"# X\"# X,8&!7A+-$7\x97+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+& 4!6\xF0! %"),
-          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\x9A+#%'\"%$\"# X\"# X,8&!7B+-$7\x9A+#%'\"%$\"# X\"# X\"+'%4\"6\xF1\" %$\"# X\"# X"),
-          peg$decode("!7\x99*# \" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\"# X\"# X"),
-          peg$decode("!!76+_$ \\!7.+-$76+#%'\"%$\"# X\"# X,8&!7.+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X*# \"7H+' 4!6\xF2!! %"),
-          peg$decode("7\x9B*) \"7\x9C*# \"7\x9F"),
-          peg$decode("!/\xF3\"\"1!3\xF4+<$7<+2%7\x9E+(%4#6\xF5#! %$## X$\"# X\"# X"),
-          peg$decode("!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\xF8#! %$## X$\"# X\"# X"),
-          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\xF9!! %"),
-          peg$decode("!.\xFA\"\"2\xFA3\xFB+x$!.J\"\"2J3K+S$7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'$%$$# X$## X$\"# X\"# X*# \" [+'%4\"6\xFC\" %$\"# X\"# X"),
-          peg$decode("!76+N$!7<+-$7\xA0+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xFD\"\"! %$\"# X\"# X"),
-          peg$decode("76*) \"7T*# \"7H"),
-          peg$decode("!7\xA2+_$ \\!7B+-$7\xA3+#%'\"%$\"# X\"# X,8&!7B+-$7\xA3+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("!/\xFE\"\"1&3\xFF*G \"/\u0100\"\"1'3\u0101*; \"/\u0102\"\"1$3\u0103*/ \"/\u0104\"\"1%3\u0105*# \"76+& 4!6\u0106! %"),
-          peg$decode("7\xA4*# \"7\x9F"),
-          peg$decode("!/\u0107\"\"1(3\u0108+O$7<+E%/\u0109\"\"1(3\u010A*/ \"/\u010B\"\"1(3\u010C*# \"76+#%'#%$## X$\"# X\"# X"),
-          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u010D!! %"),
-          peg$decode("!7\xA8+& 4!6\u010E! %"),
-          peg$decode("!7\xA9+s$7;+i%7\xAE+_% \\!7B+-$7\xAF+#%'\"%$\"# X\"# X,8&!7B+-$7\xAF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
-          peg$decode("7\xAA*# \"7\xAB"),
-          peg$decode("/\u010F\"\"1$3\u0110*S \"/\u0111\"\"1%3\u0112*G \"/\u0113\"\"1%3\u0114*; \"/\u0115\"\"1%3\u0116*/ \"/\u0117\"\"1+3\u0118*# \"7\xAC"),
-          peg$decode("/\u0119\"\"1'3\u011A*/ \"/\u011B\"\"1)3\u011C*# \"7\xAC"),
-          peg$decode("76*# \"7\xAD"),
-          peg$decode("!/\u011D\"\"1\"3\u011E+-$76+#%'\"%$\"# X\"# X"),
-          peg$decode("7\xAC*# \"76"),
-          peg$decode("!76+7$7<+-%7\xB0+#%'#%$## X$\"# X\"# X"),
-          peg$decode("76*# \"7H"),
-          peg$decode("!7\xB2+7$7.+-%7\x8F+#%'#%$## X$\"# X\"# X"),
-          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u011F!! %"),
-          peg$decode("!7\x9D+' 4!6\u0120!! %"),
-          peg$decode("!7\xB5+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u0121\"!!%$\"# X\"# X"),
-          peg$decode("!!77+k$ \\!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X,>&!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
-          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xB7+#%'\"%$\"# X\"# X,8&!7B+-$7\xB7+#%'\"%$\"# X\"# X\"+'%4\"6\u0122\" %$\"# X\"# X"),
-          peg$decode("7\xB8*# \"7\x9F"),
-          peg$decode("!/\u0123\"\"1#3\u0124+<$7<+2%76+(%4#6\u0125#! %$## X$\"# X\"# X"),
-          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u0126!! %"),
-          peg$decode("!7\x9D+' 4!6\u0127!! %"),
-          peg$decode("! \\7\x99,#&7\x99\"+\x81$7@+w%7M+m%7?+c% \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4%6\u0128% %$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("7\xBD"),
-          peg$decode("!/\u0129\"\"1&3\u012A+s$7.+i%7\xC0+_% \\!7A+-$7\xC0+#%'\"%$\"# X\"# X,8&!7A+-$7\xC0+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X*# \"7\xBE"),
-          peg$decode("!76+s$7.+i%7\xBF+_% \\!7A+-$7\xBF+#%'\"%$\"# X\"# X,8&!7A+-$7\xBF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
-          peg$decode("!76+=$7<+3%76*# \"7H+#%'#%$## X$\"# X\"# X"),
-          peg$decode("7\xC1*G \"7\xC3*A \"7\xC5*; \"7\xC7*5 \"7\xC8*/ \"7\xC9*) \"7\xCA*# \"7\xBF"),
-          peg$decode("!/\u012B\"\"1%3\u012C+7$7<+-%7\xC2+#%'#%$## X$\"# X\"# X"),
-          peg$decode("!7I+' 4!6\u012D!! %"),
-          peg$decode("!/\u012E\"\"1&3\u012F+\xA5$7<+\x9B%7D+\x91%7\xC4+\x87% \\! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X,G&! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("7t*# \"7w"),
-          peg$decode("!/\u0130\"\"1%3\u0131+7$7<+-%7\xC6+#%'#%$## X$\"# X\"# X"),
-          peg$decode("!7I+' 4!6\u0132!! %"),
-          peg$decode("!/\u0133\"\"1&3\u0134+<$7<+2%7I+(%4#6\u0135#! %$## X$\"# X\"# X"),
-          peg$decode("!/\u0136\"\"1%3\u0137+_$7<+U%!/\u0138\"\"1$3\u0139+& 4!6\u013A! %*4 \"!/\u013B\"\"1%3\u013C+& 4!6\u013D! %+#%'#%$## X$\"# X\"# X"),
-          peg$decode("!/\u013E\"\"1)3\u013F+T$7<+J%/\u0140\"\"1#3\u0141*/ \"/\u0142\"\"1(3\u0143*# \"76+(%4#6\u0144#! %$## X$\"# X\"# X"),
-          peg$decode("!/\u0145\"\"1#3\u0146+\x9E$7<+\x94%7D+\x8A%!7\xCB+k$ \\!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X,>&!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+-%7E+#%'%%$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("!/\u0147\"\"1(3\u0148*/ \"/\u0149\"\"1$3\u014A*# \"76+' 4!6\u014B!! %"),
-          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("!7\xCE+K$7.+A%7\xCE+7%7.+-%7\x8F+#%'%%$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u014C!! %"),
-          peg$decode("!7\xD0+c$ \\!7A+-$7\xD0+#%'\"%$\"# X\"# X,8&!7A+-$7\xD0+#%'\"%$\"# X\"# X\"+'%4\"6\u014D\" %$\"# X\"# X"),
-          peg$decode("!7\x98+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014E\" %$\"# X\"# X"),
-          peg$decode("!7L*T \"7\x98*N \"!7@*# \" [+=$7t+3%7?*# \" [+#%'#%$## X$\"# X\"# X+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014F\" %$\"# X\"# X"),
-          peg$decode("!7\xD3+c$ \\!7B+-$7\xD4+#%'\"%$\"# X\"# X,8&!7B+-$7\xD4+#%'\"%$\"# X\"# X\"+'%4\"6\u0150\" %$\"# X\"# X"),
-          peg$decode("!7\x95+& 4!6\u0151! %"),
-          peg$decode("!/\u0152\"\"1(3\u0153+<$7<+2%76+(%4#6\u0154#! %$## X$\"# X\"# X*j \"!/\u0155\"\"1&3\u0156+<$7<+2%76+(%4#6\u0157#! %$## X$\"# X\"# X*: \"!/\u0158\"\"1*3\u0159+& 4!6\u015A! %*# \"7\x9F"),
-          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u015D!! %"),
-          peg$decode("!7\xD7+_$ \\!7A+-$7\xD7+#%'\"%$\"# X\"# X,8&!7A+-$7\xD7+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("!7\x98+_$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u015E!! %"),
-          peg$decode("!7\xDA+_$ \\!7B+-$7\xDB+#%'\"%$\"# X\"# X,8&!7B+-$7\xDB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("!/\u015F\"\"1&3\u0160*; \"/\u0161\"\"1'3\u0162*/ \"/\u0163\"\"1*3\u0164*# \"76+& 4!6\u0165! %"),
-          peg$decode("!/\u0166\"\"1&3\u0167+<$7<+2%7\xDC+(%4#6\u0168#! %$## X$\"# X\"# X*\x83 \"!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\u0169#! %$## X$\"# X\"# X*S \"!/\u016A\"\"1+3\u016B+<$7<+2%7\x9D+(%4#6\u016C#! %$## X$\"# X\"# X*# \"7\x9F"),
-          peg$decode("/\u016D\"\"1+3\u016E*k \"/\u016F\"\"1)3\u0170*_ \"/\u0171\"\"1(3\u0172*S \"/\u0173\"\"1'3\u0174*G \"/\u0175\"\"1&3\u0176*; \"/\u0177\"\"1*3\u0178*/ \"/\u0179\"\"1)3\u017A*# \"76"),
-          peg$decode("71*# \" ["),
-          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u017B!! %"),
-          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xE0+#%'\"%$\"# X\"# X,8&!7B+-$7\xE0+#%'\"%$\"# X\"# X\"+'%4\"6\u017C\" %$\"# X\"# X"),
-          peg$decode("7\xB8*# \"7\x9F"),
-          peg$decode("!7\xE2+_$ \\!7A+-$7\xE2+#%'\"%$\"# X\"# X,8&!7A+-$7\xE2+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
-          peg$decode("!7\xE9+s$7.+i%7\xEC+_% \\!7B+-$7\xE3+#%'\"%$\"# X\"# X,8&!7B+-$7\xE3+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
-          peg$decode("7\xE4*; \"7\xE5*5 \"7\xE6*/ \"7\xE7*) \"7\xE8*# \"7\x9F"),
-          peg$decode("!/\u017D\"\"1#3\u017E+<$7<+2%7\xEF+(%4#6\u017F#! %$## X$\"# X\"# X"),
-          peg$decode("!/\u0180\"\"1%3\u0181+<$7<+2%7T+(%4#6\u0182#! %$## X$\"# X\"# X"),
-          peg$decode("!/\u0183\"\"1(3\u0184+B$7<+8%7\\*# \"7Y+(%4#6\u0185#! %$## X$\"# X\"# X"),
-          peg$decode("!/\u0186\"\"1&3\u0187+<$7<+2%76+(%4#6\u0188#! %$## X$\"# X\"# X"),
-          peg$decode("!/\u0189\"\"1%3\u018A+T$!7<+5$ \\7!,#&7!\"+#%'\"%$\"# X\"# X*# \" [+'%4\"6\u018B\" %$\"# X\"# X"),
-          peg$decode("!7\xEA+K$7;+A%76+7%7;+-%7\xEB+#%'%%$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("!/\x95\"\"1#3\xD6*# \"76+' 4!6\u018C!! %"),
-          peg$decode("!/\xB4\"\"1#3\u018D*G \"/\xB6\"\"1#3\u018E*; \"/\xBA\"\"1#3\u018F*/ \"/\xB8\"\"1$3\u0190*# \"76+' 4!6\u0191!! %"),
-          peg$decode("!7\xED+H$!7C+-$7\xEE+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
-          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\u0192! %"),
-          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\u0193!! %"),
-          peg$decode("!!7!+C$7!*# \" [+3%7!*# \" [+#%'#%$## X$\"# X\"# X+' 4!6\u0194!! %"),
-          peg$decode("7\xBD"),
-          peg$decode("!7\x9D+d$ \\!7B+-$7\xF2+#%'\"%$\"# X\"# X,8&!7B+-$7\xF2+#%'\"%$\"# X\"# X\"+(%4\"6\u0195\"!!%$\"# X\"# X"),
-          peg$decode("7\xF3*# \"7\x9F"),
-          peg$decode("!.\u0196\"\"2\u01963\u0197+N$7<+D%.\u0198\"\"2\u01983\u0199*) \".\u019A\"\"2\u019A3\u019B+(%4#6\u019C#! %$## X$\"# X\"# X"),
-          peg$decode("!7\x9D+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u019D\"!!%$\"# X\"# X"),
-          peg$decode("!76+7$70+-%7\xF6+#%'#%$## X$\"# X\"# X"),
-          peg$decode(" \\72*) \"74*# \"7.,/&72*) \"74*# \"7.\""),
-          peg$decode(" \\7%,#&7%\""),
-          peg$decode("!7\xF9+=$.8\"\"2839+-%7\xFA+#%'#%$## X$\"# X\"# X"),
-          peg$decode("!/\u019E\"\"1%3\u019F*) \"/\u01A0\"\"1$3\u01A1+' 4!6\u01A2!! %"),
-          peg$decode("!7\xFB+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
-          peg$decode("!7\\*) \"7X*# \"7\x82+' 4!6\u01A3!! %"),
-          peg$decode("! \\7\xFD*) \"7-*# \"7\xFE,/&7\xFD*) \"7-*# \"7\xFE\"+! (%"),
-          peg$decode("7\"*S \"7!*M \".F\"\"2F3G*A \".J\"\"2J3K*5 \".H\"\"2H3I*) \".N\"\"2N3O"),
-          peg$decode(".L\"\"2L3M*\x95 \".B\"\"2B3C*\x89 \".<\"\"2<3=*} \".R\"\"2R3S*q \".T\"\"2T3U*e \".V\"\"2V3W*Y \".P\"\"2P3Q*M \".@\"\"2@3A*A \".D\"\"2D3E*5 \".2\"\"2233*) \".>\"\"2>3?"),
-          peg$decode("!7\u0100+h$.8\"\"2839+X%7\xFA+N%!.\u01A4\"\"2\u01A43\u01A5+-$7\xEB+#%'\"%$\"# X\"# X*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
-          peg$decode("!/\u01A6\"\"1%3\u01A7*) \"/\u01A8\"\"1$3\u01A9+' 4!6\u01A2!! %"),
-          peg$decode("!7\xEB+Q$/\xB4\"\"1#3\xB5*7 \"/\xB6\"\"1#3\xB7*+ \" \\7+,#&7+\"+'%4\"6\u01AA\" %$\"# X\"# X"),
-          peg$decode("!7\u0104+\x8F$.F\"\"2F3G+%7\u0103+u%.F\"\"2F3G+e%7\u0103+[%.F\"\"2F3G+K%7\u0103+A%.F\"\"2F3G+1%7\u0105+'%4)6\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
-          peg$decode("!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\"# X\"# X"),
-          peg$decode("!7\u0103+-$7\u0103+#%'\"%$\"# X\"# X"),
-          peg$decode("!7\u0103+7$7\u0103+-%7\u0103+#%'#%$## X$\"# X\"# X")
-        ],
-
-        peg$currPos          = 0,
-        peg$reportedPos      = 0,
-        peg$cachedPos        = 0,
-        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
-        peg$maxFailPos       = 0,
-        peg$maxFailExpected  = [],
-        peg$silentFails      = 0,
-
-        peg$result;
-
-    if ("startRule" in options) {
-      if (!(options.startRule in peg$startRuleIndices)) {
-        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
-      }
-
-      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
-    }
-
-    function text() {
-      return input.substring(peg$reportedPos, peg$currPos);
-    }
-
-    function offset() {
-      return peg$reportedPos;
-    }
-
-    function line() {
-      return peg$computePosDetails(peg$reportedPos).line;
-    }
-
-    function column() {
-      return peg$computePosDetails(peg$reportedPos).column;
-    }
-
-    function expected(description) {
-      throw peg$buildException(
-        null,
-        [{ type: "other", description: description }],
-        peg$reportedPos
-      );
-    }
-
-    function error(message) {
-      throw peg$buildException(message, null, peg$reportedPos);
-    }
-
-    function peg$computePosDetails(pos) {
-      function advance(details, startPos, endPos) {
-        var p, ch;
-
-        for (p = startPos; p < endPos; p++) {
-          ch = input.charAt(p);
-          if (ch === "\n") {
-            if (!details.seenCR) { details.line++; }
-            details.column = 1;
-            details.seenCR = false;
-          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
-            details.line++;
-            details.column = 1;
-            details.seenCR = true;
-          } else {
-            details.column++;
-            details.seenCR = false;
-          }
-        }
-      }
-
-      if (peg$cachedPos !== pos) {
-        if (peg$cachedPos > pos) {
-          peg$cachedPos = 0;
-          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
-        }
-        advance(peg$cachedPosDetails, peg$cachedPos, pos);
-        peg$cachedPos = pos;
-      }
-
-      return peg$cachedPosDetails;
-    }
-
-    function peg$fail(expected) {
-      if (peg$currPos < peg$maxFailPos) { return; }
-
-      if (peg$currPos > peg$maxFailPos) {
-        peg$maxFailPos = peg$currPos;
-        peg$maxFailExpected = [];
-      }
-
-      peg$maxFailExpected.push(expected);
-    }
-
-    function peg$buildException(message, expected, pos) {
-      function cleanupExpected(expected) {
-        var i = 1;
-
-        expected.sort(function(a, b) {
-          if (a.description < b.description) {
-            return -1;
-          } else if (a.description > b.description) {
-            return 1;
-          } else {
-            return 0;
-          }
-        });
-
-        while (i < expected.length) {
-          if (expected[i - 1] === expected[i]) {
-            expected.splice(i, 1);
-          } else {
-            i++;
-          }
-        }
-      }
-
-      function buildMessage(expected, found) {
-        function stringEscape(s) {
-          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
-
-          return s
-            .replace(/\\/g,   '\\\\')
-            .replace(/"/g,    '\\"')
-            .replace(/\x08/g, '\\b')
-            .replace(/\t/g,   '\\t')
-            .replace(/\n/g,   '\\n')
-            .replace(/\f/g,   '\\f')
-            .replace(/\r/g,   '\\r')
-            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
-            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
-            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
-            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
-        }
-
-        var expectedDescs = new Array(expected.length),
-            expectedDesc, foundDesc, i;
-
-        for (i = 0; i < expected.length; i++) {
-          expectedDescs[i] = expected[i].description;
-        }
-
-        expectedDesc = expected.length > 1
-          ? expectedDescs.slice(0, -1).join(", ")
-              + " or "
-              + expectedDescs[expected.length - 1]
-          : expectedDescs[0];
-
-        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
-
-        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
-      }
-
-      var posDetails = peg$computePosDetails(pos),
-          found      = pos < input.length ? input.charAt(pos) : null;
-
-      if (expected !== null) {
-        cleanupExpected(expected);
-      }
-
-      return new SyntaxError(
-        message !== null ? message : buildMessage(expected, found),
-        expected,
-        found,
-        pos,
-        posDetails.line,
-        posDetails.column
-      );
-    }
-
-    function peg$decode(s) {
-      var bc = new Array(s.length), i;
-
-      for (i = 0; i < s.length; i++) {
-        bc[i] = s.charCodeAt(i) - 32;
-      }
-
-      return bc;
-    }
-
-    function peg$parseRule(index) {
-      var bc    = peg$bytecode[index],
-          ip    = 0,
-          ips   = [],
-          end   = bc.length,
-          ends  = [],
-          stack = [],
-          params, i;
-
-      function protect(object) {
-        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
-      }
-
-      while (true) {
-        while (ip < end) {
-          switch (bc[ip]) {
-            case 0:
-              stack.push(protect(peg$consts[bc[ip + 1]]));
-              ip += 2;
-              break;
-
-            case 1:
-              stack.push(peg$currPos);
-              ip++;
-              break;
-
-            case 2:
-              stack.pop();
-              ip++;
-              break;
-
-            case 3:
-              peg$currPos = stack.pop();
-              ip++;
-              break;
-
-            case 4:
-              stack.length -= bc[ip + 1];
-              ip += 2;
-              break;
-
-            case 5:
-              stack.splice(-2, 1);
-              ip++;
-              break;
-
-            case 6:
-              stack[stack.length - 2].push(stack.pop());
-              ip++;
-              break;
-
-            case 7:
-              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
-              ip += 2;
-              break;
-
-            case 8:
-              stack.pop();
-              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
-              ip++;
-              break;
-
-            case 9:
-              ends.push(end);
-              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
-
-              if (stack[stack.length - 1]) {
-                end = ip + 3 + bc[ip + 1];
-                ip += 3;
-              } else {
-                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
-                ip += 3 + bc[ip + 1];
-              }
-
-              break;
-
-            case 10:
-              ends.push(end);
-              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
-
-              if (stack[stack.length - 1] === peg$FAILED) {
-                end = ip + 3 + bc[ip + 1];
-                ip += 3;
-              } else {
-                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
-                ip += 3 + bc[ip + 1];
-              }
-
-              break;
-
-            case 11:
-              ends.push(end);
-              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
-
-              if (stack[stack.length - 1] !== peg$FAILED) {
-                end = ip + 3 + bc[ip + 1];
-                ip += 3;
-              } else {
-                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
-                ip += 3 + bc[ip + 1];
-              }
-
-              break;
-
-            case 12:
-              if (stack[stack.length - 1] !== peg$FAILED) {
-                ends.push(end);
-                ips.push(ip);
-
-                end = ip + 2 + bc[ip + 1];
-                ip += 2;
-              } else {
-                ip += 2 + bc[ip + 1];
-              }
-
-              break;
-
-            case 13:
-              ends.push(end);
-              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
-
-              if (input.length > peg$currPos) {
-                end = ip + 3 + bc[ip + 1];
-                ip += 3;
-              } else {
-                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
-                ip += 3 + bc[ip + 1];
-              }
-
-              break;
-
-            case 14:
-              ends.push(end);
-              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
-
-              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
-                end = ip + 4 + bc[ip + 2];
-                ip += 4;
-              } else {
-                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
-                ip += 4 + bc[ip + 2];
-              }
-
-              break;
-
-            case 15:
-              ends.push(end);
-              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
-
-              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
-                end = ip + 4 + bc[ip + 2];
-                ip += 4;
-              } else {
-                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
-                ip += 4 + bc[ip + 2];
-              }
-
-              break;
-
-            case 16:
-              ends.push(end);
-              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
-
-              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
-                end = ip + 4 + bc[ip + 2];
-                ip += 4;
-              } else {
-                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
-                ip += 4 + bc[ip + 2];
-              }
-
-              break;
-
-            case 17:
-              stack.push(input.substr(peg$currPos, bc[ip + 1]));
-              peg$currPos += bc[ip + 1];
-              ip += 2;
-              break;
-
-            case 18:
-              stack.push(peg$consts[bc[ip + 1]]);
-              peg$currPos += peg$consts[bc[ip + 1]].length;
-              ip += 2;
-              break;
-
-            case 19:
-              stack.push(peg$FAILED);
-              if (peg$silentFails === 0) {
-                peg$fail(peg$consts[bc[ip + 1]]);
-              }
-              ip += 2;
-              break;
-
-            case 20:
-              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
-              ip += 2;
-              break;
-
-            case 21:
-              peg$reportedPos = peg$currPos;
-              ip++;
-              break;
-
-            case 22:
-              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
-              for (i = 0; i < bc[ip + 3]; i++) {
-                params[i] = stack[stack.length - 1 - params[i]];
-              }
-
-              stack.splice(
-                stack.length - bc[ip + 2],
-                bc[ip + 2],
-                peg$consts[bc[ip + 1]].apply(null, params)
-              );
-
-              ip += 4 + bc[ip + 3];
-              break;
-
-            case 23:
-              stack.push(peg$parseRule(bc[ip + 1]));
-              ip += 2;
-              break;
-
-            case 24:
-              peg$silentFails++;
-              ip++;
-              break;
-
-            case 25:
-              peg$silentFails--;
-              ip++;
-              break;
-
-            default:
-              throw new Error("Invalid opcode: " + bc[ip] + ".");
-          }
-        }
-
-        if (ends.length > 0) {
-          end = ends.pop();
-          ip = ips.pop();
-        } else {
-          break;
-        }
-      }
-
-      return stack[0];
-    }
-
-
-      options.data = {}; // Object to which header attributes will be assigned during parsing
-
-      function list (first, rest) {
-        return [first].concat(rest);
-      }
-
-
-    peg$result = peg$parseRule(peg$startRuleIndex);
-
-    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
-      return peg$result;
-    } else {
-      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
-        peg$fail({ type: "end", description: "end of input" });
-      }
-
-      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
-    }
-  }
-
-  return {
-    SyntaxError: SyntaxError,
-    parse:       parse
-  };
-})();
-},{}],32:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview Hacks - This file contains all of the things we
- * wish we didn't have to do, just for interop.  It is similar to
- * Utils, which provides actually useful and relevant functions for
- * a SIP library. Methods in this file are grouped by vendor, so
- * as to most easily track when particular hacks may not be necessary anymore.
- */
-
-module.exports = function (SIP) {
-
-//keep to quiet jshint, and remain consistent with other files
-SIP = SIP;
-
-var Hacks = {
-  AllBrowsers: {
-    maskDtls: function (sdp) {
-      if (sdp) {
-        sdp = sdp.replace(/ UDP\/TLS\/RTP\/SAVP/gmi, " RTP/SAVP");
-      }
-      return sdp;
-    },
-    unmaskDtls: function (sdp) {
-      /**
-       * Chrome does not handle DTLS correctly (Canaray does, but not production)
-       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)
-       *
-       * UPDATE: May 21, 2014
-       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES
-       *
-       * UPDATE: 2014-09-24
-       * Opera now supports DTLS by default as well.
-       *
-       **/
-      return sdp.replace(/ RTP\/SAVP/gmi, " UDP/TLS/RTP/SAVP");
-    }
-  },
-  Firefox: {
-    /* Condition to detect if hacks are applicable */
-    isFirefox: function () {
-      return typeof mozRTCPeerConnection !== 'undefined';
-    },
-
-    cannotHandleExtraWhitespace: function (sdp) {
-      if (this.isFirefox() && sdp) {
-        sdp = sdp.replace(/ \r\n/g, "\r\n");
-      }
-      return sdp;
-    },
-
-    hasMissingCLineInSDP: function (sdp) {
-      /*
-       * This is a Firefox hack to insert valid sdp when getDescription is
-       * called with the constraint offerToReceiveVideo = false.
-       * We search for either a c-line at the top of the sdp above all
-       * m-lines. If that does not exist then we search for a c-line
-       * beneath each m-line. If it is missing a c-line, we insert
-       * a fake c-line with the ip address 0.0.0.0. This is then valid
-       * sdp and no media will be sent for that m-line.
-       *
-       * Valid SDP is:
-       * m=
-       * i=
-       * c=
-       */
-      var insertAt, mlines;
-      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {
-
-        // Find all m= lines
-        mlines = sdp.match(/m=.*\r\n.*/g);
-        for (var i=0; i<mlines.length; i++) {
-
-          // If it has an i= line, check if the next line is the c= line
-          if (mlines[i].toString().search(/i=.*/) >= 0) {
-            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;
-            if (sdp.substr(insertAt,2)!=='c=') {
-              sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
-            }
-
-          // else add the C line if it's missing
-          } else if (mlines[i].toString().search(/c=.*/) < 0) {
-            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;
-            sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
-          }
-        }
-      }
-      return sdp;
-    },
-  },
-
-  Chrome: {
-    needsExplicitlyInactiveSDP: function (sdp) {
-      var sub, index;
-
-      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending
-        index = sdp.indexOf('m=video 0');
-        if (index !== -1) {
-          sub = sdp.substr(index);
-          sub = sub.replace(/\r\nc=IN IP4.*\r\n$/,
-                            '\r\nc=IN IP4 0.0.0.0\r\na=inactive\r\n');
-          return sdp.substr(0, index) + sub;
-        }
-      }
-      return sdp;
-    },
-
-    getsConfusedAboutGUM: function (session) {
-      if (session.mediaHandler) {
-        session.mediaHandler.close();
-      }
-    }
-  }
-};
-return Hacks;
-};
-
-},{}],33:[function(require,module,exports){
-"use strict";
-var levels = {
-  'error': 0,
-  'warn': 1,
-  'log': 2,
-  'debug': 3
-};
-
-module.exports = function (console) {
-
-var LoggerFactory = function () {
-  var logger,
-    level = 2,
-    builtinEnabled = true,
-    connector = null;
-
-    this.loggers = {};
-
-    logger = this.getLogger('sip.loggerfactory');
-
-
-  Object.defineProperties(this, {
-    builtinEnabled: {
-      get: function(){ return builtinEnabled; },
-      set: function(value){
-        if (typeof value === 'boolean') {
-          builtinEnabled = value;
-        } else {
-          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
-        }
-      }
-    },
-
-    level: {
-      get: function() {return level; },
-      set: function(value) {
-        if (value >= 0 && value <=3) {
-          level = value;
-        } else if (value > 3) {
-          level = 3;
-        } else if (levels.hasOwnProperty(value)) {
-          level = levels[value];
-        } else {
-          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
-        }
-      }
-    },
-
-    connector: {
-      get: function() {return connector; },
-      set: function(value){
-        if(value === null || value === "" || value === undefined) {
-          connector = null;
-        } else if (typeof value === 'function') {
-          connector = value;
-        } else {
-          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
-        }
-      }
-    }
-  });
-};
-
-LoggerFactory.prototype.print = function(target, category, label, content) {
-  if (typeof content === 'string') {
-    var prefix = [new Date(), category];
-    if (label) {
-      prefix.push(label);
-    }
-    content = prefix.concat(content).join(' | ');
-  }
-  target.call(console, content);
-};
-
-function Logger (logger, category, label) {
-  this.logger = logger;
-  this.category = category;
-  this.label = label;
-}
-
-Object.keys(levels).forEach(function (targetName) {
-  Logger.prototype[targetName] = function (content) {
-    this.logger[targetName](this.category, this.label, content);
-  };
-
-  LoggerFactory.prototype[targetName] = function (category, label, content) {
-    if (this.level >= levels[targetName]) {
-      if (this.builtinEnabled) {
-        this.print(console[targetName], category, label, content);
-      }
-
-      if (this.connector) {
-        this.connector(targetName, category, label, content);
-      }
-    }
-  };
-});
-
-LoggerFactory.prototype.getLogger = function(category, label) {
-  var logger;
-
-  if (label && this.level === 3) {
-    return new Logger(this, category, label);
-  } else if (this.loggers[category]) {
-    return this.loggers[category];
-  } else {
-    logger = new Logger(this, category);
-    this.loggers[category] = logger;
-    return logger;
-  }
-};
-
-return LoggerFactory;
-};
-
-},{}],34:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview MediaHandler
- */
-
-/* MediaHandler
- * @class PeerConnection helper Class.
- * @param {SIP.Session} session
- * @param {Object} [options]
- */
-module.exports = function (EventEmitter) {
-var MediaHandler = function(session, options) {
-  // keep jshint happy
-  session = session;
-  options = options;
-};
-
-MediaHandler.prototype = Object.create(EventEmitter.prototype, {
-  isReady: {value: function isReady () {}},
-
-  close: {value: function close () {}},
-
-  /**
-   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.
-   */
-  getDescription: {value: function getDescription (mediaHint) {
-    // keep jshint happy
-    mediaHint = mediaHint;
-  }},
-
-  /**
-   * Check if a SIP message contains a session description.
-   * @param {SIP.SIPMessage} message
-   * @returns {boolean}
-   */
-  hasDescription: {value: function hasDescription (message) {
-    // keep jshint happy
-    message = message;
-  }},
-
-  /**
-   * Set the session description contained in a SIP message.
-   * @param {SIP.SIPMessage} message
-   * @returns {Promise}
-   */
-  setDescription: {value: function setDescription (message) {
-    // keep jshint happy
-    message = message;
-  }}
-});
-
-return MediaHandler;
-};
-
-},{}],35:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP NameAddrHeader
- */
-
-/**
- * @augments SIP
- * @class Class creating a Name Address SIP header.
- *
- * @param {SIP.URI} uri
- * @param {String} [displayName]
- * @param {Object} [parameters]
- *
- */
-module.exports = function (SIP) {
-var NameAddrHeader;
-
-NameAddrHeader = function(uri, displayName, parameters) {
-  var param;
-
-  // Checks
-  if(!uri || !(uri instanceof SIP.URI)) {
-    throw new TypeError('missing or invalid "uri" parameter');
-  }
-
-  // Initialize parameters
-  this.uri = uri;
-  this.parameters = {};
-
-  for (param in parameters) {
-    this.setParam(param, parameters[param]);
-  }
-
-  Object.defineProperties(this, {
-    friendlyName: {
-      get: function() { return this.displayName || uri.aor; }
-    },
-
-    displayName: {
-      get: function() { return displayName; },
-      set: function(value) {
-        displayName = (value === 0) ? '0' : value;
-      }
-    }
-  });
-};
-NameAddrHeader.prototype = {
-  setParam: function (key, value) {
-    if(key) {
-      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
-    }
-  },
-  getParam: SIP.URI.prototype.getParam,
-  hasParam: SIP.URI.prototype.hasParam,
-  deleteParam: SIP.URI.prototype.deleteParam,
-  clearParams: SIP.URI.prototype.clearParams,
-
-  clone: function() {
-    return new NameAddrHeader(
-      this.uri.clone(),
-      this.displayName,
-      JSON.parse(JSON.stringify(this.parameters)));
-  },
-
-  toString: function() {
-    var body, parameter;
-
-    body  = (this.displayName || this.displayName === 0) ? '"' + this.displayName + '" ' : '';
-    body += '<' + this.uri.toString() + '>';
-
-    for (parameter in this.parameters) {
-      body += ';' + parameter;
-
-      if (this.parameters[parameter] !== null) {
-        body += '='+ this.parameters[parameter];
-      }
-    }
-
-    return body;
-  }
-};
-
-
-/**
-  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
-  * it is an invalid NameAddrHeader.
-  * @public
-  * @param {String} name_addr_header
-  */
-NameAddrHeader.parse = function(name_addr_header) {
-  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');
-
-  if (name_addr_header !== -1) {
-    return name_addr_header;
-  } else {
-    return undefined;
-  }
-};
-
-SIP.NameAddrHeader = NameAddrHeader;
-};
-
-},{}],36:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP Message Parser
- */
-
-/**
- * Extract and parse every header of a SIP message.
- * @augments SIP
- * @namespace
- */
-module.exports = function (SIP) {
-var Parser;
-
-function getHeader(data, headerStart) {
-  var
-    // 'start' position of the header.
-    start = headerStart,
-    // 'end' position of the header.
-    end = 0,
-    // 'partial end' position of the header.
-    partialEnd = 0;
-
-  //End of message.
-  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
-    return -2;
-  }
-
-  while(end === 0) {
-    // Partial End of Header.
-    partialEnd = data.indexOf('\r\n', start);
-
-    // 'indexOf' returns -1 if the value to be found never occurs.
-    if (partialEnd === -1) {
-      return partialEnd;
-    }
-
-    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
-      // Not the end of the message. Continue from the next position.
-      start = partialEnd + 2;
-    } else {
-      end = partialEnd;
-    }
-  }
-
-  return end;
-}
-
-function parseHeader(message, data, headerStart, headerEnd) {
-  var header, idx, length, parsed,
-    hcolonIndex = data.indexOf(':', headerStart),
-    headerName = data.substring(headerStart, hcolonIndex).trim(),
-    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
-
-  // If header-field is well-known, parse it.
-  switch(headerName.toLowerCase()) {
-    case 'via':
-    case 'v':
-      message.addHeader('via', headerValue);
-      if(message.getHeaders('via').length === 1) {
-        parsed = message.parseHeader('Via');
-        if(parsed) {
-          message.via = parsed;
-          message.via_branch = parsed.branch;
-        }
-      } else {
-        parsed = 0;
-      }
-      break;
-    case 'from':
-    case 'f':
-      message.setHeader('from', headerValue);
-      parsed = message.parseHeader('from');
-      if(parsed) {
-        message.from = parsed;
-        message.from_tag = parsed.getParam('tag');
-      }
-      break;
-    case 'to':
-    case 't':
-      message.setHeader('to', headerValue);
-      parsed = message.parseHeader('to');
-      if(parsed) {
-        message.to = parsed;
-        message.to_tag = parsed.getParam('tag');
-      }
-      break;
-    case 'record-route':
-      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');
-
-      if (parsed === -1) {
-        parsed = undefined;
-        break;
-      }
-
-      length = parsed.length;
-      for (idx = 0; idx < length; idx++) {
-        header = parsed[idx];
-        message.addHeader('record-route', headerValue.substring(header.position, header.offset));
-        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
-      }
-      break;
-    case 'call-id':
-    case 'i':
-      message.setHeader('call-id', headerValue);
-      parsed = message.parseHeader('call-id');
-      if(parsed) {
-        message.call_id = headerValue;
-      }
-      break;
-    case 'contact':
-    case 'm':
-      parsed = SIP.Grammar.parse(headerValue, 'Contact');
-
-      if (parsed === -1) {
-        parsed = undefined;
-        break;
-      }
-
-      length = parsed.length;
-      for (idx = 0; idx < length; idx++) {
-        header = parsed[idx];
-        message.addHeader('contact', headerValue.substring(header.position, header.offset));
-        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;
-      }
-      break;
-    case 'content-length':
-    case 'l':
-      message.setHeader('content-length', headerValue);
-      parsed = message.parseHeader('content-length');
-      break;
-    case 'content-type':
-    case 'c':
-      message.setHeader('content-type', headerValue);
-      parsed = message.parseHeader('content-type');
-      break;
-    case 'cseq':
-      message.setHeader('cseq', headerValue);
-      parsed = message.parseHeader('cseq');
-      if(parsed) {
-        message.cseq = parsed.value;
-      }
-      if(message instanceof SIP.IncomingResponse) {
-        message.method = parsed.method;
-      }
-      break;
-    case 'max-forwards':
-      message.setHeader('max-forwards', headerValue);
-      parsed = message.parseHeader('max-forwards');
-      break;
-    case 'www-authenticate':
-      message.setHeader('www-authenticate', headerValue);
-      parsed = message.parseHeader('www-authenticate');
-      break;
-    case 'proxy-authenticate':
-      message.setHeader('proxy-authenticate', headerValue);
-      parsed = message.parseHeader('proxy-authenticate');
-      break;
-    case 'refer-to':
-    case 'r':
-      message.setHeader('refer-to', headerValue);
-      parsed = message.parseHeader('refer-to');
-      if (parsed) {
-        message.refer_to = parsed;
-      }
-      break;
-    default:
-      // Do not parse this header.
-      message.setHeader(headerName, headerValue);
-      parsed = 0;
-  }
-
-  if (parsed === undefined) {
-    return {
-      error: 'error parsing header "'+ headerName +'"'
-    };
-  } else {
-    return true;
-  }
-}
-
-/** Parse SIP Message
- * @function
- * @param {String} message SIP message.
- * @param {Object} logger object.
- * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}
- */
-Parser = {};
-Parser.parseMessage = function(data, ua) {
-  var message, firstLine, contentLength, bodyStart, parsed,
-    headerStart = 0,
-    headerEnd = data.indexOf('\r\n'),
-    logger = ua.getLogger('sip.parser');
-
-  if(headerEnd === -1) {
-    logger.warn('no CRLF found, not a SIP message, discarded');
-    return;
-  }
-
-  // Parse first line. Check if it is a Request or a Reply.
-  firstLine = data.substring(0, headerEnd);
-  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');
-
-  if(parsed === -1) {
-    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
-    return;
-  } else if(!parsed.status_code) {
-    message = new SIP.IncomingRequest(ua);
-    message.method = parsed.method;
-    message.ruri = parsed.uri;
-  } else {
-    message = new SIP.IncomingResponse(ua);
-    message.status_code = parsed.status_code;
-    message.reason_phrase = parsed.reason_phrase;
-  }
-
-  message.data = data;
-  headerStart = headerEnd + 2;
-
-  /* Loop over every line in data. Detect the end of each header and parse
-  * it or simply add to the headers collection.
-  */
-  while(true) {
-    headerEnd = getHeader(data, headerStart);
-
-    // The SIP message has normally finished.
-    if(headerEnd === -2) {
-      bodyStart = headerStart + 2;
-      break;
-    }
-    // data.indexOf returned -1 due to a malformed message.
-    else if(headerEnd === -1) {
-      logger.error('malformed message');
-      return;
-    }
-
-    parsed = parseHeader(message, data, headerStart, headerEnd);
-
-    if(parsed !== true) {
-      logger.error(parsed.error);
-      return;
-    }
-
-    headerStart = headerEnd + 2;
-  }
-
-  /* RFC3261 18.3.
-   * If there are additional bytes in the transport packet
-   * beyond the end of the body, they MUST be discarded.
-   */
-  if(message.hasHeader('content-length')) {
-    contentLength = message.getHeader('content-length');
-    message.body = data.substr(bodyStart, contentLength);
-  } else {
-    message.body = data.substring(bodyStart);
-  }
-
-  return message;
-};
-
-SIP.Parser = Parser;
-};
-
-},{}],37:[function(require,module,exports){
-var localMinSE = 90;
-
-module.exports = function (Timers) {
-
-// http://tools.ietf.org/html/rfc4028#section-9
-function hasSmallMinSE (message) {
-  var supportedOptions = message.parseHeader('Supported') || [];
-  var sessionExpires = message.parseHeader('Session-Expires') || {};
-  return supportedOptions.indexOf('timer') >= 0 && sessionExpires.deltaSeconds < localMinSE;
-}
-
-// `response` is an IncomingResponse or a String (outgoing response)
-function updateState (dialog, response, parseMessage, ua) {
-  dialog.sessionTimerState = dialog.sessionTimerState || {};
-  Timers.clearTimeout(dialog.sessionTimerState.timeout);
-
-  var isUAS = typeof response === 'string';
-  if (isUAS) {
-    response = parseMessage(response, ua);
-  }
-
-  var sessionExpires = response.parseHeader('Session-Expires');
-  // If the most recent 2xx response had no Session-Expires header field, there
-  // is no session expiration, and no refreshes have to be performed
-  if (!sessionExpires) {
-    dialog.sessionTimerState = null;
-    return;
-  }
-
-  var interval = sessionExpires.deltaSeconds;
-  var isRefresher = isUAS === (sessionExpires.refresher === 'uas');
-
-  dialog.sessionTimerState = {
-    interval: interval,
-    isRefresher: isRefresher
-  };
-
-  var intervalMilliseconds = interval * 1000;
-  var self = this;
-  if (isRefresher) {
-    dialog.sessionTimerState.timeout = Timers.setInterval(function sendRefresh () {
-      var exists = dialog.owner.ua.dialogs[dialog.id.toString()] || false;
-      if (exists) {
-        dialog.sendRequest(self, "UPDATE", { extraHeaders: ["Session-Expires: " + interval]});
-      } else {
-        Timers.clearInterval(dialog.sessionTimerState.timeout);
-      }
-    }, intervalMilliseconds / 2);
-  } else {
-    var before = Math.min(32 * 1000, intervalMilliseconds / 3);
-    dialog.sessionTimerState.timeout = Timers.setTimeout(function sendBye () {
-      // TODO
-    }, intervalMilliseconds - before);
-  }
-}
-
-function receiveResponse(response) {
-  /* jshint unused: false */
-}
-
-function onDialogError(response) {
-  /* jshint unused: false */
-}
-
-function onRequestTimeout() {
-  /* jshint unused: false */
-}
-
-function onTransportError() {
-  /* jshint unused: false */
-}
-
-return {
-  localMinSE: localMinSE,
-  hasSmallMinSE: hasSmallMinSE,
-  updateState: updateState,
-  receiveResponse: receiveResponse,
-  onDialogError: onDialogError,
-  onRequestTimeout: onRequestTimeout,
-  onTransportError: onTransportError
-};
-
-};
-
-},{}],38:[function(require,module,exports){
-"use strict";
-module.exports = function (SIP) {
-
-var RegisterContext;
-
-RegisterContext = function (ua) {
-  var params = {},
-      regId = 1;
-
-  this.registrar = ua.configuration.registrarServer;
-  this.expires = ua.configuration.registerExpires;
-
-
-  // Contact header
-  this.contact = ua.contact.toString();
-
-  if(regId) {
-    this.contact += ';reg-id='+ regId;
-    this.contact += ';+sip.instance="<urn:uuid:'+ ua.configuration.instanceId+'>"';
-  }
-
-  // Call-ID and CSeq values RFC3261 10.2
-  this.call_id = SIP.Utils.createRandomToken(22);
-  this.cseq = 80;
-
-  this.to_uri = ua.configuration.uri;
-
-  params.to_uri = this.to_uri;
-  params.to_displayName = ua.configuration.displayName;
-  params.call_id = this.call_id;
-  params.cseq = this.cseq;
-
-  // Extends ClientContext
-  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);
-
-  this.registrationTimer = null;
-  this.registrationExpiredTimer = null;
-
-  // Set status
-  this.registered = false;
-
-  this.logger = ua.getLogger('sip.registercontext');
-};
-
-RegisterContext.prototype = {
-  register: function (options) {
-    var self = this, extraHeaders;
-
-    // Handle Options
-    this.options = options || {};
-    extraHeaders = (this.options.extraHeaders || []).slice();
-    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);
-    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
-
-    // Save original extraHeaders to be used in .close
-    this.closeHeaders = this.options.closeWithHeaders ?
-      (this.options.extraHeaders || []).slice() : [];
-
-    this.receiveResponse = function(response) {
-      var contact, expires,
-        contacts = response.getHeaders('contact').length,
-        cause;
-
-      // Discard responses to older REGISTER/un-REGISTER requests.
-      if(response.cseq !== this.cseq) {
-        return;
-      }
-
-      // Clear registration timer
-      if (this.registrationTimer !== null) {
-        SIP.Timers.clearTimeout(this.registrationTimer);
-        this.registrationTimer = null;
-      }
-
-      switch(true) {
-        case /^1[0-9]{2}$/.test(response.status_code):
-          this.emit('progress', response);
-          break;
-        case /^2[0-9]{2}$/.test(response.status_code):
-          this.emit('accepted', response);
-
-          if(response.hasHeader('expires')) {
-            expires = response.getHeader('expires');
-          }
-
-          if (this.registrationExpiredTimer !== null) {
-            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
-            this.registrationExpiredTimer = null;
-          }
-
-          // Search the Contact pointing to us and update the expires value accordingly.
-          if (!contacts) {
-            this.logger.warn('no Contact header in response to REGISTER, response ignored');
-            break;
-          }
-
-          while(contacts--) {
-            contact = response.parseHeader('contact', contacts);
-            if(contact.uri.user === this.ua.contact.uri.user) {
-              expires = contact.getParam('expires');
-              break;
-            } else {
-              contact = null;
-            }
-          }
-
-          if (!contact) {
-            this.logger.warn('no Contact header pointing to us, response ignored');
-            break;
-          }
-
-          if(!expires) {
-            expires = this.expires;
-          }
-
-          // Re-Register before the expiration interval has elapsed.
-          // For that, decrease the expires value. ie: 3 seconds
-          this.registrationTimer = SIP.Timers.setTimeout(function() {
-            self.registrationTimer = null;
-            self.register(self.options);
-          }, (expires * 1000) - 3000);
-          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {
-            self.logger.warn('registration expired');
-            if (self.registered) {
-              self.unregistered(null, SIP.C.causes.EXPIRES);
-            }
-          }, expires * 1000);
-
-          //Save gruu values
-          if (contact.hasParam('temp-gruu')) {
-            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/"/g,''));
-          }
-          if (contact.hasParam('pub-gruu')) {
-            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/"/g,''));
-          }
-
-          this.registered = true;
-          this.emit('registered', response || null);
-          break;
-        // Interval too brief RFC3261 10.2.8
-        case /^423$/.test(response.status_code):
-          if(response.hasHeader('min-expires')) {
-            // Increase our registration interval to the suggested minimum
-            this.expires = response.getHeader('min-expires');
-            // Attempt the registration again immediately
-            this.register(this.options);
-          } else { //This response MUST contain a Min-Expires header field
-            this.logger.warn('423 response received for REGISTER without Min-Expires');
-            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);
-          }
-          break;
-        default:
-          cause = SIP.Utils.sipErrorCause(response.status_code);
-          this.registrationFailure(response, cause);
-      }
-    };
-
-    this.onRequestTimeout = function() {
-      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);
-    };
-
-    this.onTransportError = function() {
-      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);
-    };
-
-    this.cseq++;
-    this.request.cseq = this.cseq;
-    this.request.setHeader('cseq', this.cseq + ' REGISTER');
-    this.request.extraHeaders = extraHeaders;
-    this.send();
-  },
-
-  registrationFailure: function (response, cause) {
-    this.emit('failed', response || null, cause || null);
-  },
-
-  onTransportClosed: function() {
-    this.registered_before = this.registered;
-    if (this.registrationTimer !== null) {
-      SIP.Timers.clearTimeout(this.registrationTimer);
-      this.registrationTimer = null;
-    }
-
-    if (this.registrationExpiredTimer !== null) {
-      SIP.Timers.clearTimeout(this.registrationExpiredTimer);
-      this.registrationExpiredTimer = null;
-    }
-
-    if(this.registered) {
-      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
-    }
-  },
-
-  onTransportConnected: function() {
-    this.register(this.options);
-  },
-
-  close: function() {
-    var options = {
-      all: false,
-      extraHeaders: this.closeHeaders
-    };
-
-    this.registered_before = this.registered;
-    this.unregister(options);
-  },
-
-  unregister: function(options) {
-    var extraHeaders;
-
-    options = options || {};
-
-    if(!this.registered && !options.all) {
-      this.logger.warn('already unregistered');
-      return;
-    }
-
-    extraHeaders = (options.extraHeaders || []).slice();
-
-    this.registered = false;
-
-    // Clear the registration timer.
-    if (this.registrationTimer !== null) {
-      SIP.Timers.clearTimeout(this.registrationTimer);
-      this.registrationTimer = null;
-    }
-
-    if(options.all) {
-      extraHeaders.push('Contact: *');
-      extraHeaders.push('Expires: 0');
-    } else {
-      extraHeaders.push('Contact: '+ this.contact + ';expires=0');
-    }
-
-
-    this.receiveResponse = function(response) {
-      var cause;
-
-      switch(true) {
-        case /^1[0-9]{2}$/.test(response.status_code):
-          this.emit('progress', response);
-          break;
-        case /^2[0-9]{2}$/.test(response.status_code):
-          this.emit('accepted', response);
-          if (this.registrationExpiredTimer !== null) {
-            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
-            this.registrationExpiredTimer = null;
-          }
-          this.unregistered(response);
-          break;
-        default:
-          cause = SIP.Utils.sipErrorCause(response.status_code);
-          this.unregistered(response,cause);
-      }
-    };
-
-    this.onRequestTimeout = function() {
-      // Not actually unregistered...
-      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);
-    };
-
-    this.onTransportError = function() {
-      // Not actually unregistered...
-      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
-    };
-
-    this.cseq++;
-    this.request.cseq = this.cseq;
-    this.request.setHeader('cseq', this.cseq + ' REGISTER');
-    this.request.extraHeaders = extraHeaders;
-
-    this.send();
-  },
-
-  unregistered: function(response, cause) {
-    this.registered = false;
-    this.emit('unregistered', response || null, cause || null);
-  }
-
-};
-
-
-SIP.RegisterContext = RegisterContext;
-};
-
-},{}],39:[function(require,module,exports){
-"use strict";
-
-/**
- * @fileoverview Request Sender
- */
-
-/**
- * @augments SIP
- * @class Class creating a request sender.
- * @param {Object} applicant
- * @param {SIP.UA} ua
- */
-module.exports = function (SIP) {
-var RequestSender;
-
-RequestSender = function(applicant, ua) {
-  this.logger = ua.getLogger('sip.requestsender');
-  this.ua = ua;
-  this.applicant = applicant;
-  this.method = applicant.request.method;
-  this.request = applicant.request;
-  this.credentials = null;
-  this.challenged = false;
-  this.staled = false;
-
-  // If ua is in closing process or even closed just allow sending Bye and ACK
-  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {
-    this.onTransportError();
-  }
-};
-
-/**
-* Create the client transaction and send the message.
-*/
-RequestSender.prototype = {
-  send: function() {
-    switch(this.method) {
-      case "INVITE":
-        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
-        break;
-      case "ACK":
-        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);
-        break;
-      default:
-        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
-    }
-    this.clientTransaction.send();
-
-    return this.clientTransaction;
-  },
-
-  /**
-  * Callback fired when receiving a request timeout error from the client transaction.
-  * To be re-defined by the applicant.
-  * @event
-  */
-  onRequestTimeout: function() {
-    this.applicant.onRequestTimeout();
-  },
-
-  /**
-  * Callback fired when receiving a transport error from the client transaction.
-  * To be re-defined by the applicant.
-  * @event
-  */
-  onTransportError: function() {
-    this.applicant.onTransportError();
-  },
-
-  /**
-  * Called from client transaction when receiving a correct response to the request.
-  * Authenticate request if needed or pass the response back to the applicant.
-  * @param {SIP.IncomingResponse} response
-  */
-  receiveResponse: function(response) {
-    var cseq, challenge, authorization_header_name,
-      status_code = response.status_code;
-
-    /*
-    * Authentication
-    * Authenticate once. _challenged_ flag used to avoid infinite authentications.
-    */
-    if (status_code === 401 || status_code === 407) {
-
-      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
-      if (response.status_code === 401) {
-        challenge = response.parseHeader('www-authenticate');
-        authorization_header_name = 'authorization';
-      } else {
-        challenge = response.parseHeader('proxy-authenticate');
-        authorization_header_name = 'proxy-authorization';
-      }
-
-      // Verify it seems a valid challenge.
-      if (! challenge) {
-        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
-        this.applicant.receiveResponse(response);
-        return;
-      }
-
-      if (!this.challenged || (!this.staled && challenge.stale === true)) {
-        if (!this.credentials) {
-          this.credentials = this.ua.configuration.authenticationFactory(this.ua);
-        }
-
-        // Verify that the challenge is really valid.
-        if (!this.credentials.authenticate(this.request, challenge)) {
-          this.applicant.receiveResponse(response);
-          return;
-        }
-        this.challenged = true;
-
-        if (challenge.stale) {
-          this.staled = true;
-        }
-
-        if (response.method === SIP.C.REGISTER) {
-          cseq = this.applicant.cseq += 1;
-        } else if (this.request.dialog){
-          cseq = this.request.dialog.local_seqnum += 1;
-        } else {
-          cseq = this.request.cseq + 1;
-          this.request.cseq = cseq;
-        }
-        this.request.setHeader('cseq', cseq +' '+ this.method);
-
-        this.request.setHeader(authorization_header_name, this.credentials.toString());
-        this.send();
-      } else {
-        this.applicant.receiveResponse(response);
-      }
-    } else {
-      this.applicant.receiveResponse(response);
-    }
-  }
-};
-
-SIP.RequestSender = RequestSender;
-};
-
-},{}],40:[function(require,module,exports){
-/**
- * @name SIP
- * @namespace
- */
-"use strict";
-
-module.exports = function (environment) {
-
-var pkg = require('../package.json');
-
-var SIP = Object.defineProperties({}, {
-  version: {
-    get: function(){ return pkg.version; }
-  },
-  name: {
-    get: function(){ return pkg.title; }
-  }
-});
-
-require('./Utils')(SIP, environment);
-SIP.LoggerFactory = require('./LoggerFactory')(environment.console);
-SIP.EventEmitter = require('./EventEmitter')(environment.console);
-SIP.C = require('./Constants')(SIP.name, SIP.version);
-SIP.Exceptions = require('./Exceptions');
-SIP.Timers = require('./Timers')(environment.timers);
-SIP.Transport = environment.Transport(SIP, environment.WebSocket);
-require('./Parser')(SIP);
-require('./SIPMessage')(SIP);
-require('./URI')(SIP);
-require('./NameAddrHeader')(SIP);
-require('./Transactions')(SIP);
-require('./Dialogs')(SIP);
-require('./RequestSender')(SIP);
-require('./RegisterContext')(SIP);
-SIP.MediaHandler = require('./MediaHandler')(SIP.EventEmitter);
-require('./ClientContext')(SIP);
-require('./ServerContext')(SIP);
-require('./Session')(SIP, environment);
-require('./Subscription')(SIP);
-SIP.WebRTC = require('./WebRTC')(SIP, environment);
-require('./UA')(SIP, environment);
-SIP.Hacks = require('./Hacks')(SIP);
-require('./SanityCheck')(SIP);
-SIP.DigestAuthentication = require('./DigestAuthentication')(SIP.Utils);
-SIP.Grammar = require('./Grammar')(SIP);
-
-return SIP;
-};
-
-},{"../package.json":22,"./ClientContext":23,"./Constants":24,"./Dialogs":26,"./DigestAuthentication":27,"./EventEmitter":28,"./Exceptions":29,"./Grammar":30,"./Hacks":32,"./LoggerFactory":33,"./MediaHandler":34,"./NameAddrHeader":35,"./Parser":36,"./RegisterContext":38,"./RequestSender":39,"./SIPMessage":41,"./SanityCheck":42,"./ServerContext":43,"./Session":44,"./Subscription":46,"./Timers":47,"./Transactions":48,"./UA":50,"./URI":51,"./Utils":52,"./WebRTC":53}],41:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP Message
- */
-
-module.exports = function (SIP) {
-var
-  OutgoingRequest,
-  IncomingMessage,
-  IncomingRequest,
-  IncomingResponse;
-
-function getSupportedHeader (request) {
-  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;
-  var optionTags = [];
-  var optionTagSet = {};
-
-  if (request.method === SIP.C.REGISTER) {
-    optionTags.push('path', 'gruu');
-  } else if (request.method === SIP.C.INVITE &&
-             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {
-    optionTags.push('gruu');
-  }
-
-  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {
-    optionTags.push('100rel');
-  }
-  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {
-    optionTags.push('replaces');
-  }
-
-  optionTags.push('outbound');
-
-  optionTags = optionTags.concat(request.ua.configuration.extraSupported);
-
-  optionTags = optionTags.filter(function(optionTag) {
-    var registered = SIP.C.OPTION_TAGS[optionTag];
-    var unique = !optionTagSet[optionTag];
-    optionTagSet[optionTag] = true;
-    return (registered || allowUnregistered) && unique;
-  });
-
-  return 'Supported: ' + optionTags.join(', ') + '\r\n';
-}
-
-/**
- * @augments SIP
- * @class Class for outgoing SIP request.
- * @param {String} method request method
- * @param {String} ruri request uri
- * @param {SIP.UA} ua
- * @param {Object} params parameters that will have priority over ua.configuration parameters:
- * <br>
- *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set
- * @param {Object} [headers] extra headers
- * @param {String} [body]
- */
-OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {
-  var
-    to,
-    from,
-    call_id,
-    cseq,
-    to_uri,
-    from_uri;
-
-  params = params || {};
-
-  // Mandatory parameters check
-  if(!method || !ruri || !ua) {
-    return null;
-  }
-
-  this.logger = ua.getLogger('sip.sipmessage');
-  this.ua = ua;
-  this.headers = {};
-  this.method = method;
-  this.ruri = ruri;
-  this.body = body;
-  this.extraHeaders = (extraHeaders || []).slice();
-  this.statusCode = params.status_code;
-  this.reasonPhrase = params.reason_phrase;
-
-  // Fill the Common SIP Request Headers
-
-  // Route
-  if (params.route_set) {
-    this.setHeader('route', params.route_set);
-  } else if (ua.configuration.usePreloadedRoute){
-    this.setHeader('route', ua.transport.server.sip_uri);
-  }
-
-  // Via
-  // Empty Via header. Will be filled by the client transaction.
-  this.setHeader('via', '');
-
-  // Max-Forwards
-  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);
-
-  // To
-  to_uri = params.to_uri || ruri;
-  to = (params.to_displayName || params.to_displayName === 0) ? '"' + params.to_displayName + '" ' : '';
-  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';
-  to += params.to_tag ? ';tag=' + params.to_tag : '';
-  this.to = new SIP.NameAddrHeader.parse(to);
-  this.setHeader('to', to);
-
-  // From
-  from_uri = params.from_uri || ua.configuration.uri;
-  if (params.from_displayName || params.from_displayName === 0) {
-    from = '"' + params.from_displayName + '" ';
-  } else if (ua.configuration.displayName) {
-    from = '"' + ua.configuration.displayName + '" ';
-  } else {
-    from = '';
-  }
-  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';
-  from += params.from_tag || SIP.Utils.newTag();
-  this.from = new SIP.NameAddrHeader.parse(from);
-  this.setHeader('from', from);
-
-  // Call-ID
-  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));
-  this.call_id = call_id;
-  this.setHeader('call-id', call_id);
-
-  // CSeq
-  cseq = params.cseq || Math.floor(Math.random() * 10000);
-  this.cseq = cseq;
-  this.setHeader('cseq', cseq + ' ' + method);
-};
-
-OutgoingRequest.prototype = {
-  /**
-   * Replace the the given header by the given value.
-   * @param {String} name header name
-   * @param {String | Array} value header value
-   */
-  setHeader: function(name, value) {
-    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
-  },
-
-  /**
-   * Get the value of the given header name at the given position.
-   * @param {String} name header name
-   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
-   */
-  getHeader: function(name) {
-    var regexp, idx,
-      length = this.extraHeaders.length,
-      header = this.headers[SIP.Utils.headerize(name)];
-
-    if(header) {
-      if(header[0]) {
-        return header[0];
-      }
-    } else {
-      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
-      for (idx = 0; idx < length; idx++) {
-        header = this.extraHeaders[idx];
-        if (regexp.test(header)) {
-          return header.substring(header.indexOf(':')+1).trim();
-        }
-      }
-    }
-
-    return;
-  },
-
-  /**
-   * Get the header/s of the given name.
-   * @param {String} name header name
-   * @returns {Array} Array with all the headers of the specified name.
-   */
-  getHeaders: function(name) {
-    var idx, length, regexp,
-      header = this.headers[SIP.Utils.headerize(name)],
-      result = [];
-
-    if(header) {
-      length = header.length;
-      for (idx = 0; idx < length; idx++) {
-        result.push(header[idx]);
-      }
-      return result;
-    } else {
-      length = this.extraHeaders.length;
-      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
-      for (idx = 0; idx < length; idx++) {
-        header = this.extraHeaders[idx];
-        if (regexp.test(header)) {
-          result.push(header.substring(header.indexOf(':')+1).trim());
-        }
-      }
-      return result;
-    }
-  },
-
-  /**
-   * Verify the existence of the given header.
-   * @param {String} name header name
-   * @returns {boolean} true if header with given name exists, false otherwise
-   */
-  hasHeader: function(name) {
-    var regexp, idx,
-      length = this.extraHeaders.length;
-
-    if (this.headers[SIP.Utils.headerize(name)]) {
-      return true;
-    } else {
-      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
-      for (idx = 0; idx < length; idx++) {
-        if (regexp.test(this.extraHeaders[idx])) {
-          return true;
-        }
-      }
-    }
-
-    return false;
-  },
-
-  toString: function() {
-    var msg = '', header, length, idx;
-
-    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\r\n';
-
-    for (header in this.headers) {
-      length = this.headers[header].length;
-      for (idx = 0; idx < length; idx++) {
-        msg += header + ': ' + this.headers[header][idx] + '\r\n';
-      }
-    }
-
-    length = this.extraHeaders.length;
-    for (idx = 0; idx < length; idx++) {
-      msg += this.extraHeaders[idx].trim() +'\r\n';
-    }
-
-    msg += getSupportedHeader(this);
-    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
-
-    if (this.body) {
-      if (typeof this.body === 'string') {
-        length = SIP.Utils.str_utf8_length(this.body);
-        msg += 'Content-Length: ' + length + '\r\n\r\n';
-        msg += this.body;
-      } else {
-        if (this.body.body && this.body.contentType) {
-          length = SIP.Utils.str_utf8_length(this.body.body);
-          msg += 'Content-Type: ' + this.body.contentType + '\r\n';
-          msg += 'Content-Length: ' + length + '\r\n\r\n';
-          msg += this.body.body;
-        } else {
-          msg += 'Content-Length: ' + 0 + '\r\n\r\n';
-        }
-      }
-    } else {
-      msg += 'Content-Length: ' + 0 + '\r\n\r\n';
-    }
-
-    return msg;
-  }
-};
-
-/**
- * @augments SIP
- * @class Class for incoming SIP message.
- */
-IncomingMessage = function(){
-  this.data = null;
-  this.headers = null;
-  this.method =  null;
-  this.via = null;
-  this.via_branch = null;
-  this.call_id = null;
-  this.cseq = null;
-  this.from = null;
-  this.from_tag = null;
-  this.to = null;
-  this.to_tag = null;
-  this.body = null;
-};
-
-IncomingMessage.prototype = {
-  /**
-  * Insert a header of the given name and value into the last position of the
-  * header array.
-  * @param {String} name header name
-  * @param {String} value header value
-  */
-  addHeader: function(name, value) {
-    var header = { raw: value };
-
-    name = SIP.Utils.headerize(name);
-
-    if(this.headers[name]) {
-      this.headers[name].push(header);
-    } else {
-      this.headers[name] = [header];
-    }
-  },
-
-  /**
-   * Get the value of the given header name at the given position.
-   * @param {String} name header name
-   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.
-   */
-  getHeader: function(name) {
-    var header = this.headers[SIP.Utils.headerize(name)];
-
-    if(header) {
-      if(header[0]) {
-        return header[0].raw;
-      }
-    } else {
-      return;
-    }
-  },
-
-  /**
-   * Get the header/s of the given name.
-   * @param {String} name header name
-   * @returns {Array} Array with all the headers of the specified name.
-   */
-  getHeaders: function(name) {
-    var idx, length,
-      header = this.headers[SIP.Utils.headerize(name)],
-      result = [];
-
-    if(!header) {
-      return [];
-    }
-
-    length = header.length;
-    for (idx = 0; idx < length; idx++) {
-      result.push(header[idx].raw);
-    }
-
-    return result;
-  },
-
-  /**
-   * Verify the existence of the given header.
-   * @param {String} name header name
-   * @returns {boolean} true if header with given name exists, false otherwise
-   */
-  hasHeader: function(name) {
-    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;
-  },
-
-  /**
-  * Parse the given header on the given index.
-  * @param {String} name header name
-  * @param {Number} [idx=0] header index
-  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
-  */
-  parseHeader: function(name, idx) {
-    var header, value, parsed;
-
-    name = SIP.Utils.headerize(name);
-
-    idx = idx || 0;
-
-    if(!this.headers[name]) {
-      this.logger.log('header "' + name + '" not present');
-      return;
-    } else if(idx >= this.headers[name].length) {
-      this.logger.log('not so many "' + name + '" headers present');
-      return;
-    }
-
-    header = this.headers[name][idx];
-    value = header.raw;
-
-    if(header.parsed) {
-      return header.parsed;
-    }
-
-    //substitute '-' by '_' for grammar rule matching.
-    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));
-
-    if(parsed === -1) {
-      this.headers[name].splice(idx, 1); //delete from headers
-      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
-      return;
-    } else {
-      header.parsed = parsed;
-      return parsed;
-    }
-  },
-
-  /**
-   * Message Header attribute selector. Alias of parseHeader.
-   * @param {String} name header name
-   * @param {Number} [idx=0] header index
-   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
-   *
-   * @example
-   * message.s('via',3).port
-   */
-  s: function(name, idx) {
-    return this.parseHeader(name, idx);
-  },
-
-  /**
-  * Replace the value of the given header by the value.
-  * @param {String} name header name
-  * @param {String} value header value
-  */
-  setHeader: function(name, value) {
-    var header = { raw: value };
-    this.headers[SIP.Utils.headerize(name)] = [header];
-  },
-
-  toString: function() {
-    return this.data;
-  }
-};
-
-/**
- * @augments IncomingMessage
- * @class Class for incoming SIP request.
- */
-IncomingRequest = function(ua) {
-  this.logger = ua.getLogger('sip.sipmessage');
-  this.ua = ua;
-  this.headers = {};
-  this.ruri = null;
-  this.transport = null;
-  this.server_transaction = null;
-};
-IncomingRequest.prototype = new IncomingMessage();
-
-/**
-* Stateful reply.
-* @param {Number} code status code
-* @param {String} reason reason phrase
-* @param {Object} headers extra headers
-* @param {String} body body
-* @param {Function} [onSuccess] onSuccess callback
-* @param {Function} [onFailure] onFailure callback
-*/
-IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
-  var rr, vias, length, idx, response,
-    to = this.getHeader('To'),
-    r = 0,
-    v = 0;
-
-  response = SIP.Utils.buildStatusLine(code, reason);
-  extraHeaders = (extraHeaders || []).slice();
-
-  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {
-    rr = this.getHeaders('record-route');
-    length = rr.length;
-
-    for(r; r < length; r++) {
-      response += 'Record-Route: ' + rr[r] + '\r\n';
-    }
-  }
-
-  vias = this.getHeaders('via');
-  length = vias.length;
-
-  for(v; v < length; v++) {
-    response += 'Via: ' + vias[v] + '\r\n';
-  }
-
-  if(!this.to_tag && code > 100) {
-    to += ';tag=' + SIP.Utils.newTag();
-  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
-    to += ';tag=' + this.to_tag;
-  }
-
-  response += 'To: ' + to + '\r\n';
-  response += 'From: ' + this.getHeader('From') + '\r\n';
-  response += 'Call-ID: ' + this.call_id + '\r\n';
-  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
-
-  length = extraHeaders.length;
-  for (idx = 0; idx < length; idx++) {
-    response += extraHeaders[idx].trim() +'\r\n';
-  }
-
-  response += getSupportedHeader(this);
-  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
-
-  if (body) {
-    if (typeof body === 'string') {
-      length = SIP.Utils.str_utf8_length(body);
-      response += 'Content-Type: application/sdp\r\n';
-      response += 'Content-Length: ' + length + '\r\n\r\n';
-      response += body;
-    } else {
-      if (body.body && body.contentType) {
-        length = SIP.Utils.str_utf8_length(body.body);
-        response += 'Content-Type: ' + body.contentType + '\r\n';
-        response += 'Content-Length: ' + length + '\r\n\r\n';
-        response += body.body;
-      } else {
-        response += 'Content-Length: ' + 0 + '\r\n\r\n';
-      }
-    }
-  } else {
-    response += 'Content-Length: ' + 0 + '\r\n\r\n';
-  }
-
-  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);
-
-  return response;
-};
-
-/**
-* Stateless reply.
-* @param {Number} code status code
-* @param {String} reason reason phrase
-*/
-IncomingRequest.prototype.reply_sl = function(code, reason) {
-  var to, response,
-    v = 0,
-    vias = this.getHeaders('via'),
-    length = vias.length;
-
-  response = SIP.Utils.buildStatusLine(code, reason);
-
-  for(v; v < length; v++) {
-    response += 'Via: ' + vias[v] + '\r\n';
-  }
-
-  to = this.getHeader('To');
-
-  if(!this.to_tag && code > 100) {
-    to += ';tag=' + SIP.Utils.newTag();
-  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
-    to += ';tag=' + this.to_tag;
-  }
-
-  response += 'To: ' + to + '\r\n';
-  response += 'From: ' + this.getHeader('From') + '\r\n';
-  response += 'Call-ID: ' + this.call_id + '\r\n';
-  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
-  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
-  response += 'Content-Length: ' + 0 + '\r\n\r\n';
-
-  this.transport.send(response);
-};
-
-
-/**
- * @augments IncomingMessage
- * @class Class for incoming SIP response.
- */
-IncomingResponse = function(ua) {
-  this.logger = ua.getLogger('sip.sipmessage');
-  this.headers = {};
-  this.status_code = null;
-  this.reason_phrase = null;
-};
-IncomingResponse.prototype = new IncomingMessage();
-
-SIP.OutgoingRequest = OutgoingRequest;
-SIP.IncomingRequest = IncomingRequest;
-SIP.IncomingResponse = IncomingResponse;
-};
-
-},{}],42:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview Incoming SIP Message Sanity Check
- */
-
-/**
- * SIP message sanity check.
- * @augments SIP
- * @function
- * @param {SIP.IncomingMessage} message
- * @param {SIP.UA} ua
- * @param {SIP.Transport} transport
- * @returns {Boolean}
- */
-module.exports = function (SIP) {
-var sanityCheck,
- requests = [],
- responses = [],
- all = [];
-
-// Reply
-function reply(status_code, message, transport) {
-  var to,
-    response = SIP.Utils.buildStatusLine(status_code),
-    vias = message.getHeaders('via'),
-    length = vias.length,
-    idx = 0;
-
-  for(idx; idx < length; idx++) {
-    response += "Via: " + vias[idx] + "\r\n";
-  }
-
-  to = message.getHeader('To');
-
-  if(!message.to_tag) {
-    to += ';tag=' + SIP.Utils.newTag();
-  }
-
-  response += "To: " + to + "\r\n";
-  response += "From: " + message.getHeader('From') + "\r\n";
-  response += "Call-ID: " + message.call_id + "\r\n";
-  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
-  response += "\r\n";
-
-  transport.send(response);
-}
-
-/*
- * Sanity Check for incoming Messages
- *
- * Requests:
- *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
- *  - _rfc3261_16_3_4_ Receive a Request already sent by us
- *   Does not look at via sent-by but at sipjsId, which is inserted as
- *   a prefix in all initial requests generated by the ua
- *  - _rfc3261_18_3_request_ Body Content-Length
- *  - _rfc3261_8_2_2_2_ Merged Requests
- *
- * Responses:
- *  - _rfc3261_8_1_3_3_ Multiple Via headers
- *  - _rfc3261_18_1_2_ sent-by mismatch
- *  - _rfc3261_18_3_response_ Body Content-Length
- *
- * All:
- *  - Minimum headers in a SIP message
- */
-
-// Sanity Check functions for requests
-function rfc3261_8_2_2_1(message, ua, transport) {
-  if(!message.ruri || message.ruri.scheme !== 'sip') {
-    reply(416, message, transport);
-    return false;
-  }
-}
-
-function rfc3261_16_3_4(message, ua, transport) {
-  if(!message.to_tag) {
-    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {
-      reply(482, message, transport);
-      return false;
-    }
-  }
-}
-
-function rfc3261_18_3_request(message, ua, transport) {
-  var len = SIP.Utils.str_utf8_length(message.body),
-  contentLength = message.getHeader('content-length');
-
-  if(len < contentLength) {
-    reply(400, message, transport);
-    return false;
-  }
-}
-
-function rfc3261_8_2_2_2(message, ua, transport) {
-  var tr, idx,
-    fromTag = message.from_tag,
-    call_id = message.call_id,
-    cseq = message.cseq;
-
-  if(!message.to_tag) {
-    if(message.method === SIP.C.INVITE) {
-      tr = ua.transactions.ist[message.via_branch];
-      if(tr) {
-        return;
-      } else {
-        for(idx in ua.transactions.ist) {
-          tr = ua.transactions.ist[idx];
-          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
-            reply(482, message, transport);
-            return false;
-          }
-        }
-      }
-    } else {
-      tr = ua.transactions.nist[message.via_branch];
-      if(tr) {
-        return;
-      } else {
-        for(idx in ua.transactions.nist) {
-          tr = ua.transactions.nist[idx];
-          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
-            reply(482, message, transport);
-            return false;
-          }
-        }
-      }
-    }
-  }
-}
-
-// Sanity Check functions for responses
-function rfc3261_8_1_3_3(message, ua) {
-  if(message.getHeaders('via').length > 1) {
-    ua.getLogger('sip.sanitycheck').warn('More than one Via header field present in the response. Dropping the response');
-    return false;
-  }
-}
-
-function rfc3261_18_3_response(message, ua) {
-  var
-    len = SIP.Utils.str_utf8_length(message.body),
-    contentLength = message.getHeader('content-length');
-
-    if(len < contentLength) {
-      ua.getLogger('sip.sanitycheck').warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
-      return false;
-    }
-}
-
-// Sanity Check functions for requests and responses
-function minimumHeaders(message, ua) {
-  var
-    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
-    idx = mandatoryHeaders.length;
-
-  while(idx--) {
-    if(!message.hasHeader(mandatoryHeaders[idx])) {
-      ua.getLogger('sip.sanitycheck').warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
-      return false;
-    }
-  }
-}
-
-requests.push(rfc3261_8_2_2_1);
-requests.push(rfc3261_16_3_4);
-requests.push(rfc3261_18_3_request);
-requests.push(rfc3261_8_2_2_2);
-
-responses.push(rfc3261_8_1_3_3);
-// responses.push(rfc3261_18_1_2);
-responses.push(rfc3261_18_3_response);
-
-all.push(minimumHeaders);
-
-sanityCheck = function(message, ua, transport) {
-  var len, pass;
-
-  len = all.length;
-  while(len--) {
-    pass = all[len](message, ua, transport);
-    if(pass === false) {
-      return false;
-    }
-  }
-
-  if(message instanceof SIP.IncomingRequest) {
-    len = requests.length;
-    while(len--) {
-      pass = requests[len](message, ua, transport);
-      if(pass === false) {
-        return false;
-      }
-    }
-  }
-
-  else if(message instanceof SIP.IncomingResponse) {
-    len = responses.length;
-    while(len--) {
-      pass = responses[len](message, ua, transport);
-      if(pass === false) {
-        return false;
-      }
-    }
-  }
-
-  //Everything is OK
-  return true;
-};
-
-SIP.sanityCheck = sanityCheck;
-};
-
-},{}],43:[function(require,module,exports){
-"use strict";
-module.exports = function (SIP) {
-var ServerContext;
-
-ServerContext = function (ua, request) {
-  this.ua = ua;
-  this.logger = ua.getLogger('sip.servercontext');
-  this.request = request;
-  if (request.method === SIP.C.INVITE) {
-    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);
-  } else {
-    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);
-  }
-
-  if (request.body) {
-    this.body = request.body;
-  }
-  if (request.hasHeader('Content-Type')) {
-    this.contentType = request.getHeader('Content-Type');
-  }
-  this.method = request.method;
-
-  this.data = {};
-
-  this.localIdentity = request.to;
-  this.remoteIdentity = request.from;
-};
-
-ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);
-
-ServerContext.prototype.progress = function (options) {
-  options = Object.create(options || Object.prototype);
-  options.statusCode || (options.statusCode = 180);
-  options.minCode = 100;
-  options.maxCode = 199;
-  options.events = ['progress'];
-  return this.reply(options);
-};
-
-ServerContext.prototype.accept = function (options) {
-  options = Object.create(options || Object.prototype);
-  options.statusCode || (options.statusCode = 200);
-  options.minCode = 200;
-  options.maxCode = 299;
-  options.events = ['accepted'];
-  return this.reply(options);
-};
-
-ServerContext.prototype.reject = function (options) {
-  options = Object.create(options || Object.prototype);
-  options.statusCode || (options.statusCode = 480);
-  options.minCode = 300;
-  options.maxCode = 699;
-  options.events = ['rejected', 'failed'];
-  return this.reply(options);
-};
-
-ServerContext.prototype.reply = function (options) {
-  options = options || {}; // This is okay, so long as we treat options as read-only in this method
-  var
-    statusCode = options.statusCode || 100,
-    minCode = options.minCode || 100,
-    maxCode = options.maxCode || 699,
-    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),
-    extraHeaders = options.extraHeaders || [],
-    body = options.body,
-    events = options.events || [],
-    response;
-
-  if (statusCode < minCode || statusCode > maxCode) {
-    throw new TypeError('Invalid statusCode: ' + statusCode);
-  }
-  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
-  events.forEach(function (event) {
-    this.emit(event, response, reasonPhrase);
-  }, this);
-
-  return this;
-};
-
-ServerContext.prototype.onRequestTimeout = function () {
-  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
-};
-
-ServerContext.prototype.onTransportError = function () {
-  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
-};
-
-SIP.ServerContext = ServerContext;
-};
-
-},{}],44:[function(require,module,exports){
-"use strict";
-module.exports = function (SIP, environment) {
-
-var DTMF = require('./Session/DTMF')(SIP);
-var RFC4028 = require('./RFC4028')(SIP.Timers);
-
-var Session, InviteServerContext, InviteClientContext,
- C = {
-    //Session states
-    STATUS_NULL:                        0,
-    STATUS_INVITE_SENT:                 1,
-    STATUS_1XX_RECEIVED:                2,
-    STATUS_INVITE_RECEIVED:             3,
-    STATUS_WAITING_FOR_ANSWER:          4,
-    STATUS_ANSWERED:                    5,
-    STATUS_WAITING_FOR_PRACK:           6,
-    STATUS_WAITING_FOR_ACK:             7,
-    STATUS_CANCELED:                    8,
-    STATUS_TERMINATED:                  9,
-    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,
-    STATUS_EARLY_MEDIA:                11,
-    STATUS_CONFIRMED:                  12
-  };
-
-/*
- * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]
- *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)
- */
-Session = function (mediaHandlerFactory) {
-  this.status = C.STATUS_NULL;
-  this.dialog = null;
-  this.earlyDialogs = {};
-  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;
-  // this.mediaHandler gets set by ICC/ISC constructors
-  this.hasOffer = false;
-  this.hasAnswer = false;
-
-  // Session Timers
-  this.timers = {
-    ackTimer: null,
-    expiresTimer: null,
-    invite2xxTimer: null,
-    userNoAnswerTimer: null,
-    rel1xxTimer: null,
-    prackTimer: null
-  };
-
-  // Session info
-  this.startTime = null;
-  this.endTime = null;
-  this.tones = null;
-
-  // Mute/Hold state
-  this.local_hold = false;
-  this.remote_hold = false;
-
-  this.pending_actions = {
-    actions: [],
-
-    length: function() {
-      return this.actions.length;
-    },
-
-    isPending: function(name){
-      var
-      idx = 0,
-      length = this.actions.length;
-
-      for (idx; idx<length; idx++) {
-        if (this.actions[idx].name === name) {
-          return true;
-        }
-      }
-      return false;
-    },
-
-    shift: function() {
-      return this.actions.shift();
-    },
-
-    push: function(name) {
-      this.actions.push({
-        name: name
-      });
-    },
-
-    pop: function(name) {
-      var
-      idx = 0,
-      length = this.actions.length;
-
-      for (idx; idx<length; idx++) {
-        if (this.actions[idx].name === name) {
-          this.actions.splice(idx,1);
-          length --;
-          idx--;
-        }
-      }
-    }
-   };
-
-  this.early_sdp = null;
-  this.rel100 = SIP.C.supported.UNSUPPORTED;
-};
-
-Session.prototype = {
-  dtmf: function(tones, options) {
-    var tone, dtmfs = [],
-        self = this;
-
-    options = options || {};
-
-    if (tones === undefined) {
-      throw new TypeError('Not enough arguments');
-    }
-
-    // Check Session Status
-    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
-      throw new SIP.Exceptions.InvalidStateError(this.status);
-    }
-
-    // Check tones
-    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
-      throw new TypeError('Invalid tones: '+ tones);
-    }
-
-    tones = tones.toString().split('');
-
-    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }
-
-    if (this.tones) {
-      // Tones are already queued, just add to the queue
-      this.tones =  this.tones.concat(dtmfs);
-      return this;
-    }
-
-    var sendDTMF = function () {
-      var dtmf, timeout;
-
-      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {
-        // Stop sending DTMF
-        self.tones = null;
-        return this;
-      }
-
-      dtmf = self.tones.shift();
-
-      if (tone === ',') {
-        timeout = 2000;
-      } else {
-        dtmf.on('failed', function(){self.tones = null;});
-        dtmf.send(options);
-        timeout = dtmf.duration + dtmf.interToneGap;
-      }
-
-      // Set timeout for the next tone
-      SIP.Timers.setTimeout(sendDTMF, timeout);
-    };
-
-    this.tones = dtmfs;
-    sendDTMF();
-    return this;
-  },
-
-  bye: function(options) {
-    options = Object.create(options || Object.prototype);
-    var statusCode = options.statusCode;
-
-    // Check Session Status
-    if (this.status === C.STATUS_TERMINATED) {
-      this.logger.error('Error: Attempted to send BYE in a terminated session.');
-      return this;
-    }
-
-    this.logger.log('terminating Session');
-
-    if (statusCode && (statusCode < 200 || statusCode >= 700)) {
-      throw new TypeError('Invalid statusCode: '+ statusCode);
-    }
-
-    options.receiveResponse = function () {};
-
-    return this.
-      sendRequest(SIP.C.BYE, options).
-      terminated();
-  },
-
-  refer: function(target, options) {
-    options = options || {};
-    var extraHeaders = (options.extraHeaders || []).slice(),
-        withReplaces =
-          target instanceof SIP.InviteServerContext ||
-          target instanceof SIP.InviteClientContext,
-        originalTarget = target;
-
-    if (target === undefined) {
-      throw new TypeError('Not enough arguments');
-    }
-
-    // Check Session Status
-    if (this.status !== C.STATUS_CONFIRMED) {
-      throw new SIP.Exceptions.InvalidStateError(this.status);
-    }
-
-    // transform `target` so that it can be a Refer-To header value
-    if (withReplaces) {
-      //Attended Transfer
-      // B.transfer(C)
-      target = '"' + target.remoteIdentity.friendlyName + '" ' +
-        '<' + target.dialog.remote_target.toString() +
-        '?Replaces=' + target.dialog.id.call_id +
-        '%3Bto-tag%3D' + target.dialog.id.remote_tag +
-        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';
-    } else {
-      //Blind Transfer
-      // normalizeTarget allows instances of SIP.URI to pass through unaltered,
-      // so try to make one ahead of time
-      try {
-        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
-      } catch (e) {
-        this.logger.debug(".refer() cannot parse Refer_To from", target);
-        this.logger.debug("...falling through to normalizeTarget()");
-      }
-
-      // Check target validity
-      target = this.ua.normalizeTarget(target);
-      if (!target) {
-        throw new TypeError('Invalid target: ' + originalTarget);
-      }
-    }
-
-    extraHeaders.push('Contact: '+ this.contact);
-    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
-    extraHeaders.push('Refer-To: '+ target);
-
-    // Send the request
-    this.sendRequest(SIP.C.REFER, {
-      extraHeaders: extraHeaders,
-      body: options.body,
-      receiveResponse: function (response) {
-        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {
-          return;
-        }
-        // hang up only if we transferred to a SIP address
-        if (withReplaces || (target.scheme && target.scheme.match("^sips?$"))) {
-          this.terminate();
-        }
-      }.bind(this)
-    });
-    return this;
-  },
-
-  followRefer: function followRefer (callback) {
-    return function referListener (callback, request) {
-      // open non-SIP URIs if possible and keep session open
-      var referTo = request.parseHeader('refer-to');
-      var target = referTo.uri;
-      if (!target.scheme.match("^sips?$")) {
-        var targetString = target.toString();
-        if (typeof environment.open === "function") {
-          environment.open(targetString);
-        } else {
-          this.logger.warn("referred to non-SIP URI but `open` isn't in the environment: " + targetString);
-        }
-        return;
-      }
-
-      var extraHeaders = [];
-
-      /* Copy the Replaces query into a Replaces header */
-      /* TODO - make sure we don't copy a poorly formatted header? */
-      var replaces = target.getHeader('Replaces');
-      if (replaces !== undefined) {
-        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));
-      }
-
-      // don't embed headers into Request-URI of INVITE
-      target.clearHeaders();
-
-      /*
-        Harmless race condition.  Both sides of REFER
-        may send a BYE, but in the end the dialogs are destroyed.
-      */
-      var getReferMedia = this.mediaHandler.getReferMedia;
-      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;
-
-      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);
-
-      var referSession = this.ua.invite(target, {
-        media: mediaHint,
-        params: {
-          to_displayName: referTo.friendlyName
-        },
-        extraHeaders: extraHeaders
-      });
-
-      callback.call(this, request, referSession);
-
-      this.terminate();
-    }.bind(this, callback);
-  },
-
-  sendRequest: function(method,options) {
-    options = options || {};
-    var self = this;
-
-    var request = new SIP.OutgoingRequest(
-      method,
-      this.dialog.remote_target,
-      this.ua,
-      {
-        cseq: options.cseq || (this.dialog.local_seqnum += 1),
-        call_id: this.dialog.id.call_id,
-        from_uri: this.dialog.local_uri,
-        from_tag: this.dialog.id.local_tag,
-        to_uri: this.dialog.remote_uri,
-        to_tag: this.dialog.id.remote_tag,
-        route_set: this.dialog.route_set,
-        statusCode: options.statusCode,
-        reasonPhrase: options.reasonPhrase
-      },
-      options.extraHeaders || [],
-      options.body
-    );
-
-    new SIP.RequestSender({
-      request: request,
-      onRequestTimeout: function() {
-        self.onRequestTimeout();
-      },
-      onTransportError: function() {
-        self.onTransportError();
-      },
-      receiveResponse: options.receiveResponse || function(response) {
-        self.receiveNonInviteResponse(response);
-      }
-    }, this.ua).send();
-
-    // Emit the request event
-    this.emit(method.toLowerCase(), request);
-
-    return this;
-  },
-
-  close: function() {
-    var idx;
-
-    if(this.status === C.STATUS_TERMINATED) {
-      return this;
-    }
-
-    this.logger.log('closing INVITE session ' + this.id);
-
-    // 1st Step. Terminate media.
-    if (this.mediaHandler){
-      this.mediaHandler.close();
-    }
-
-    // 2nd Step. Terminate signaling.
-
-    // Clear session timers
-    for(idx in this.timers) {
-      SIP.Timers.clearTimeout(this.timers[idx]);
-    }
-
-    // Terminate dialogs
-
-    // Terminate confirmed dialog
-    if(this.dialog) {
-      this.dialog.terminate();
-      delete this.dialog;
-    }
-
-    // Terminate early dialogs
-    for(idx in this.earlyDialogs) {
-      this.earlyDialogs[idx].terminate();
-      delete this.earlyDialogs[idx];
-    }
-
-    this.status = C.STATUS_TERMINATED;
-
-    delete this.ua.sessions[this.id];
-    return this;
-  },
-
-  createDialog: function(message, type, early) {
-    var dialog, early_dialog,
-      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],
-      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],
-      id = message.call_id + local_tag + remote_tag;
-
-    early_dialog = this.earlyDialogs[id];
-
-    // Early Dialog
-    if (early) {
-      if (early_dialog) {
-        return true;
-      } else {
-        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);
-
-        // Dialog has been successfully created.
-        if(early_dialog.error) {
-          this.logger.error(early_dialog.error);
-          this.failed(message, SIP.C.causes.INTERNAL_ERROR);
-          return false;
-        } else {
-          this.earlyDialogs[id] = early_dialog;
-          return true;
-        }
-      }
-    }
-    // Confirmed Dialog
-    else {
-      // In case the dialog is in _early_ state, update it
-      if (early_dialog) {
-        early_dialog.update(message, type);
-        this.dialog = early_dialog;
-        delete this.earlyDialogs[id];
-        for (var dia in this.earlyDialogs) {
-          this.earlyDialogs[dia].terminate();
-          delete this.earlyDialogs[dia];
-        }
-        return true;
-      }
-
-      // Otherwise, create a _confirmed_ dialog
-      dialog = new SIP.Dialog(this, message, type);
-
-      if(dialog.error) {
-        this.logger.error(dialog.error);
-        this.failed(message, SIP.C.causes.INTERNAL_ERROR);
-        return false;
-      } else {
-        this.to_tag = message.to_tag;
-        this.dialog = dialog;
-        return true;
-      }
-    }
-  },
-
-  /**
-  * Check if Session is ready for a re-INVITE
-  *
-  * @returns {Boolean}
-  */
-  isReadyToReinvite: function() {
-    return this.mediaHandler.isReady() &&
-      !this.dialog.uac_pending_reply &&
-      !this.dialog.uas_pending_reply;
-  },
-
-  /**
-   * Mute
-   */
-  mute: function(options) {
-    var ret = this.mediaHandler.mute(options);
-    if (ret) {
-      this.onmute(ret);
-    }
-  },
-
-  /**
-   * Unmute
-   */
-  unmute: function(options) {
-    var ret = this.mediaHandler.unmute(options);
-    if (ret) {
-      this.onunmute(ret);
-    }
-  },
-
-  /**
-   * Hold
-   */
-  hold: function() {
-
-    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
-      throw new SIP.Exceptions.InvalidStateError(this.status);
-    }
-
-    this.mediaHandler.hold();
-
-    // Check if RTCSession is ready to send a reINVITE
-    if (!this.isReadyToReinvite()) {
-      /* If there is a pending 'unhold' action, cancel it and don't queue this one
-       * Else, if there isn't any 'hold' action, add this one to the queue
-       * Else, if there is already a 'hold' action, skip
-       */
-      if (this.pending_actions.isPending('unhold')) {
-        this.pending_actions.pop('unhold');
-      } else if (!this.pending_actions.isPending('hold')) {
-        this.pending_actions.push('hold');
-      }
-      return;
-    } else if (this.local_hold === true) {
-        return;
-    }
-
-    this.onhold('local');
-
-    this.sendReinvite();
-  },
-
-  /**
-   * Unhold
-   */
-  unhold: function(options) {
-
-    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
-      throw new SIP.Exceptions.InvalidStateError(this.status);
-    }
-
-    this.mediaHandler.unhold();
-
-    if (!this.isReadyToReinvite()) {
-      /* If there is a pending 'hold' action, cancel it and don't queue this one
-       * Else, if there isn't any 'unhold' action, add this one to the queue
-       * Else, if there is already a 'unhold' action, skip
-       */
-      if (this.pending_actions.isPending('hold')) {
-        this.pending_actions.pop('hold');
-      } else if (!this.pending_actions.isPending('unhold')) {
-        this.pending_actions.push('unhold');
-      }
-      return;
-    } else if (this.local_hold === false) {
-      return;
-    }
-
-    this.onunhold('local');
-
-    this.sendReinvite(options);
-  },
-
-  /**
-   * isOnHold
-   */
-  isOnHold: function() {
-    return {
-      local: this.local_hold,
-      remote: this.remote_hold
-    };
-  },
-
-  /**
-   * In dialog INVITE Reception
-   * @private
-   */
-  receiveReinvite: function(request) {
-    var self = this;
-
-    if (!this.mediaHandler.hasDescription(request)) {
-      this.logger.warn('invalid Content-Type');
-      request.reply(415);
-      return;
-    }
-
-    this.mediaHandler.setDescription(request)
-    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
-    .then(function(description) {
-      var extraHeaders = ['Contact: ' + self.contact];
-      request.reply(200, null, extraHeaders, description,
-        function() {
-          self.status = C.STATUS_WAITING_FOR_ACK;
-          self.setInvite2xxTimer(request, description);
-          self.setACKTimer();
-
-          if (self.remote_hold && !self.mediaHandler.remote_hold) {
-            self.onunhold('remote');
-          } else if (!self.remote_hold && self.mediaHandler.remote_hold) {
-            self.onhold('remote');
-          }
-        });
-    })
-    .catch(function onFailure (e) {
-      var statusCode;
-      if (e instanceof SIP.Exceptions.GetDescriptionError) {
-        statusCode = 500;
-      } else {
-        self.logger.error(e);
-        statusCode = 488;
-      }
-      request.reply(statusCode);
-    });
-  },
-
-  sendReinvite: function(options) {
-    options = options || {};
-
-    var
-      self = this,
-       extraHeaders = (options.extraHeaders || []).slice(),
-       eventHandlers = options.eventHandlers || {},
-       succeeded;
-
-    if (eventHandlers.succeeded) {
-      succeeded = eventHandlers.succeeded;
-    }
-    this.reinviteSucceeded = function(){
-      SIP.Timers.clearTimeout(self.timers.ackTimer);
-      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
-      self.status = C.STATUS_CONFIRMED;
-      succeeded && succeeded.apply(this, arguments);
-    };
-    if (eventHandlers.failed) {
-      this.reinviteFailed = eventHandlers.failed;
-    } else {
-      this.reinviteFailed = function(){};
-    }
-
-    extraHeaders.push('Contact: ' + this.contact);
-    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
-
-    this.receiveResponse = this.receiveReinviteResponse;
-    //REVISIT
-    this.mediaHandler.getDescription(self.mediaHint)
-    .then(
-      function(description){
-        self.dialog.sendRequest(self, SIP.C.INVITE, {
-          extraHeaders: extraHeaders,
-          body: description
-        });
-      },
-      function() {
-        if (self.isReadyToReinvite()) {
-          self.onReadyToReinvite();
-        }
-        self.reinviteFailed();
-      }
-    );
-  },
-
-  receiveRequest: function (request) {
-    switch (request.method) {
-      case SIP.C.BYE:
-        request.reply(200);
-        if(this.status === C.STATUS_CONFIRMED) {
-          this.emit('bye', request);
-          this.terminated(request, SIP.C.causes.BYE);
-        }
-        break;
-      case SIP.C.INVITE:
-        if(this.status === C.STATUS_CONFIRMED) {
-          this.logger.log('re-INVITE received');
-          this.receiveReinvite(request);
-        }
-        break;
-      case SIP.C.INFO:
-        if (this.status === C.STATUS_1XX_RECEIVED ||
-            this.status === C.STATUS_WAITING_FOR_PRACK ||
-            this.status === C.STATUS_WAITING_FOR_ACK ||
-            this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||
-            this.status === C.STATUS_EARLY_MEDIA ||
-            this.status === C.STATUS_CONFIRMED ||
-            this.dialog) {
-          if (this.onInfo) {
-            return this.onInfo(request);
-          }
-
-          var body, tone, duration,
-              contentType = request.getHeader('content-type'),
-              reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
-              reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
-
-          if (contentType) {
-            if (contentType.match(/^application\/dtmf-relay/i)) {
-              if (request.body) {
-                body = request.body.split('\r\n', 2);
-                if (body.length === 2) {
-                  if (reg_tone.test(body[0])) {
-                    tone = body[0].replace(reg_tone,"$2");
-                  }
-                  if (reg_duration.test(body[1])) {
-                    duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
-                  }
-                }
-              }
-
-              new DTMF(this, tone, {duration: duration}).init_incoming(request);
-            } else {
-              request.reply(415, null, ["Accept: application/dtmf-relay"]);
-            }
-          }
-        }
-        break;
-      case SIP.C.REFER:
-        if(this.status ===  C.STATUS_CONFIRMED) {
-          this.logger.log('REFER received');
-          var hasReferListener = this.listeners('refer').length,
-              notifyBody;
-
-          if (hasReferListener) {
-            request.reply(202, 'Accepted');
-            notifyBody = 'SIP/2.0 100 Trying';
-
-            this.sendRequest(SIP.C.NOTIFY, {
-              extraHeaders:[
-                'Event: refer',
-                'Subscription-State: terminated',
-                'Content-Type: message/sipfrag'
-              ],
-              body: notifyBody,
-              receiveResponse: function() {}
-            });
-
-            this.emit('refer', request);
-          } else {
-            // RFC 3515.2.4.2: 'the UA MAY decline the request.'
-            request.reply(603, 'Declined');
-          }
-        }
-        break;
-      case SIP.C.NOTIFY:
-        request.reply(200, 'OK');
-        this.emit('notify', request);
-        break;
-    }
-  },
-
-  /**
-   * Reception of Response for in-dialog INVITE
-   * @private
-   */
-  receiveReinviteResponse: function(response) {
-    var self = this;
-
-    if (this.status === C.STATUS_TERMINATED) {
-      return;
-    }
-
-    switch(true) {
-      case /^1[0-9]{2}$/.test(response.status_code):
-        break;
-      case /^2[0-9]{2}$/.test(response.status_code):
-        this.status = C.STATUS_CONFIRMED;
-
-        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});
-
-        if (!this.mediaHandler.hasDescription(response)) {
-          this.reinviteFailed();
-          break;
-        }
-
-        //REVISIT
-        this.mediaHandler.setDescription(response)
-        .then(
-          function onSuccess () {
-            self.reinviteSucceeded();
-          },
-          function onFailure () {
-            self.reinviteFailed();
-          }
-        );
-        break;
-      default:
-        this.reinviteFailed();
-    }
-  },
-
-  acceptAndTerminate: function(response, status_code, reason_phrase) {
-    var extraHeaders = [];
-
-    if (status_code) {
-      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));
-    }
-
-    // An error on dialog creation will fire 'failed' event
-    if (this.dialog || this.createDialog(response, 'UAC')) {
-      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
-      this.sendRequest(SIP.C.BYE, {
-        extraHeaders: extraHeaders
-      });
-    }
-
-    return this;
-  },
-
-  /**
-   * RFC3261 13.3.1.4
-   * Response retransmissions cannot be accomplished by transaction layer
-   *  since it is destroyed when receiving the first 2xx answer
-   */
-  setInvite2xxTimer: function(request, description) {
-    var self = this,
-        timeout = SIP.Timers.T1;
-
-    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {
-      if (self.status !== C.STATUS_WAITING_FOR_ACK) {
-        return;
-      }
-
-      self.logger.log('no ACK received, attempting to retransmit OK');
-
-      var extraHeaders = ['Contact: ' + self.contact];
-
-      request.reply(200, null, extraHeaders, description);
-
-      timeout = Math.min(timeout * 2, SIP.Timers.T2);
-
-      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);
-    }, timeout);
-  },
-
-  /**
-   * RFC3261 14.2
-   * If a UAS generates a 2xx response and never receives an ACK,
-   *  it SHOULD generate a BYE to terminate the dialog.
-   */
-  setACKTimer: function() {
-    var self = this;
-
-    this.timers.ackTimer = SIP.Timers.setTimeout(function() {
-      if(self.status === C.STATUS_WAITING_FOR_ACK) {
-        self.logger.log('no ACK received for an extended period of time, terminating the call');
-        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
-        self.sendRequest(SIP.C.BYE);
-        self.terminated(null, SIP.C.causes.NO_ACK);
-      }
-    }, SIP.Timers.TIMER_H);
-  },
-
-  /*
-   * @private
-   */
-  onReadyToReinvite: function() {
-    var action = this.pending_actions.shift();
-
-    if (!action || !this[action.name]) {
-      return;
-    }
-
-    this[action.name]();
-  },
-
-  onTransportError: function() {
-    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
-      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
-    }
-  },
-
-  onRequestTimeout: function() {
-    if (this.status === C.STATUS_CONFIRMED) {
-      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
-    } else if (this.status !== C.STATUS_TERMINATED) {
-      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
-      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
-    }
-  },
-
-  onDialogError: function(response) {
-    if (this.status === C.STATUS_CONFIRMED) {
-      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
-    } else if (this.status !== C.STATUS_TERMINATED) {
-      this.failed(response, SIP.C.causes.DIALOG_ERROR);
-      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
-    }
-  },
-
-  /**
-   * @private
-   */
-  onhold: function(originator) {
-    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;
-    this.emit('hold', { originator: originator });
-  },
-
-  /**
-   * @private
-   */
-  onunhold: function(originator) {
-    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;
-    this.emit('unhold', { originator: originator });
-  },
-
-  /*
-   * @private
-   */
-  onmute: function(options) {
-    this.emit('muted', {
-      audio: options.audio,
-      video: options.video
-    });
-  },
-
-  /*
-   * @private
-   */
-  onunmute: function(options) {
-    this.emit('unmuted', {
-      audio: options.audio,
-      video: options.video
-    });
-  },
-
-  failed: function(response, cause) {
-    if (this.status === C.STATUS_TERMINATED) {
-      return this;
-    }
-    this.emit('failed', response || null, cause || null);
-    return this;
-  },
-
-  rejected: function(response, cause) {
-    this.emit('rejected',
-      response || null,
-      cause || null
-    );
-    return this;
-  },
-
-  canceled: function() {
-    this.emit('cancel');
-    return this;
-  },
-
-  accepted: function(response, cause) {
-    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);
-
-    this.startTime = new Date();
-
-    if (this.replacee) {
-      this.replacee.emit('replaced', this);
-      this.replacee.terminate();
-    }
-    if (response) {
-      RFC4028.updateState(this.dialog, response, SIP.Parser.parseMessage, this.ua);
-    }
-    this.emit('accepted', response, cause);
-    return this;
-  },
-
-  terminated: function(message, cause) {
-    if (this.status === C.STATUS_TERMINATED) {
-      return this;
-    }
-
-    this.endTime = new Date();
-
-    this.close();
-    this.emit('terminated',
-      message || null,
-      cause || null
-    );
-    return this;
-  },
-
-  connecting: function(request) {
-    this.emit('connecting', { request: request });
-    return this;
-  }
-};
-
-Session.desugar = function desugar(options) {
-  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {
-    options = {
-      media: {
-        constraints: {
-          audio: true,
-          video: options.tagName === 'VIDEO'
-        },
-        render: {
-          remote: options
-        }
-      }
-    };
-  }
-  return options || {};
-};
-
-
-Session.C = C;
-SIP.Session = Session;
-
-
-InviteServerContext = function(ua, request) {
-  var expires,
-    self = this,
-    contentType = request.getHeader('Content-Type'),
-    contentDisp = request.parseHeader('Content-Disposition');
-
-  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);
-  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);
-
-  //Initialize Media Session
-  this.mediaHandler = this.mediaHandlerFactory(this, {
-    RTCConstraints: {"optional": [{'DtlsSrtpKeyAgreement': 'true'}]}
-  });
-
-  // Check body and content type
-  if ((!contentDisp && !this.mediaHandler.hasDescription(request)) || (contentDisp && contentDisp.type === 'render')) {
-    this.renderbody = request.body;
-    this.rendertype = contentType;
-  } else if (!this.mediaHandler.hasDescription(request) && (contentDisp && contentDisp.type === 'session')) {
-    request.reply(415);
-    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it
-    return;
-  }
-
-  // TODO test
-  // http://tools.ietf.org/html/rfc4028#section-9
-  if (RFC4028.hasSmallMinSE(request)) {
-    request.reply(422, null, ['Min-SE: ' + RFC4028.localMinSE]);
-    return;
-  }
-
-  this.status = C.STATUS_INVITE_RECEIVED;
-  this.from_tag = request.from_tag;
-  this.id = request.call_id + this.from_tag;
-  this.request = request;
-  this.contact = this.ua.contact.toString();
-
-  this.receiveNonInviteResponse = function () {}; // intentional no-op
-
-  this.logger = ua.getLogger('sip.inviteservercontext', this.id);
-
-  //Save the session into the ua sessions collection.
-  this.ua.sessions[this.id] = this;
-
-  //Get the Expires header value if exists
-  if(request.hasHeader('expires')) {
-    expires = request.getHeader('expires') * 1000;
-  }
-
-  //Set 100rel if necessary
-  function set100rel(h,c) {
-    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {
-      self.rel100 = c;
-    }
-  }
-  set100rel('require', SIP.C.supported.REQUIRED);
-  set100rel('supported', SIP.C.supported.SUPPORTED);
-
-  /* Set the to_tag before
-   * replying a response code that will create a dialog.
-   */
-  request.to_tag = SIP.Utils.newTag();
-
-  // An error on dialog creation will fire 'failed' event
-  if(!this.createDialog(request, 'UAS', true)) {
-    request.reply(500, 'Missing Contact header field');
-    return;
-  }
-
-  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
-    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
-    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
-  }
-
-  function fireNewSession() {
-    var options = {extraHeaders: ['Contact: ' + self.contact]};
-
-    if (self.rel100 !== SIP.C.supported.REQUIRED) {
-      self.progress(options);
-    }
-    self.status = C.STATUS_WAITING_FOR_ANSWER;
-
-    // Set userNoAnswerTimer
-    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {
-      request.reply(408);
-      self.failed(request, SIP.C.causes.NO_ANSWER);
-      self.terminated(request, SIP.C.causes.NO_ANSWER);
-    }, self.ua.configuration.noAnswerTimeout);
-
-    /* Set expiresTimer
-     * RFC3261 13.3.1
-     */
-    if (expires) {
-      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {
-        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {
-          request.reply(487);
-          self.failed(request, SIP.C.causes.EXPIRES);
-          self.terminated(request, SIP.C.causes.EXPIRES);
-        }
-      }, expires);
-    }
-
-    self.emit('invite',request);
-  }
-
-  if (!this.mediaHandler.hasDescription(request) || this.renderbody) {
-    SIP.Timers.setTimeout(fireNewSession, 0);
-  } else {
-    this.hasOffer = true;
-    this.mediaHandler.setDescription(request)
-    .then(
-      fireNewSession,
-      function onFailure (e) {
-        self.logger.warn('invalid description');
-        self.logger.warn(e);
-        request.reply(488);
-      }
-    );
-  }
-};
-
-InviteServerContext.prototype = {
-  reject: function(options) {
-    // Check Session Status
-    if (this.status === C.STATUS_TERMINATED) {
-      throw new SIP.Exceptions.InvalidStateError(this.status);
-    }
-
-    this.logger.log('rejecting RTCSession');
-
-    SIP.ServerContext.prototype.reject.call(this, options);
-    return this.terminated();
-  },
-
-  terminate: function(options) {
-    options = options || {};
-
-    var
-    extraHeaders = (options.extraHeaders || []).slice(),
-    body = options.body,
-    dialog,
-    self = this;
-
-    if (this.status === C.STATUS_WAITING_FOR_ACK &&
-       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
-      dialog = this.dialog;
-
-      this.receiveRequest = function(request) {
-        if (request.method === SIP.C.ACK) {
-          this.sendRequest(SIP.C.BYE, {
-            extraHeaders: extraHeaders,
-            body: body
-          });
-          dialog.terminate();
-        }
-      };
-
-      this.request.server_transaction.on('stateChanged', function(){
-        if (this.state === SIP.Transactions.C.STATUS_TERMINATED && this.dialog) {
-          this.request = new SIP.OutgoingRequest(
-            SIP.C.BYE,
-            this.dialog.remote_target,
-            this.ua,
-            {
-              'cseq': this.dialog.local_seqnum+=1,
-              'call_id': this.dialog.id.call_id,
-              'from_uri': this.dialog.local_uri,
-              'from_tag': this.dialog.id.local_tag,
-              'to_uri': this.dialog.remote_uri,
-              'to_tag': this.dialog.id.remote_tag,
-              'route_set': this.dialog.route_set
-            },
-            extraHeaders,
-            body
-          );
-
-          new SIP.RequestSender(
-            {
-              request: this.request,
-              onRequestTimeout: function() {
-                self.onRequestTimeout();
-              },
-              onTransportError: function() {
-                self.onTransportError();
-              },
-              receiveResponse: function() {
-                return;
-              }
-            },
-            this.ua
-          ).send();
-          dialog.terminate();
-        }
-      });
-
-      this.emit('bye', this.request);
-      this.terminated();
-
-      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
-      this.dialog = dialog;
-
-      // Restore the dialog into 'ua' so the ACK can reach 'this' session
-      this.ua.dialogs[dialog.id.toString()] = dialog;
-
-    } else if (this.status === C.STATUS_CONFIRMED) {
-      this.bye(options);
-    } else {
-      this.reject(options);
-    }
-
-    return this;
-  },
-
-  /*
-   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
-   */
-  progress: function (options) {
-    options = options || {};
-    var
-      statusCode = options.statusCode || 180,
-      reasonPhrase = options.reasonPhrase,
-      extraHeaders = (options.extraHeaders || []).slice(),
-      iceServers,
-      stunServers = options.stunServers || null,
-      turnServers = options.turnServers || null,
-      body = options.body,
-      response;
-
-    if (statusCode < 100 || statusCode > 199) {
-      throw new TypeError('Invalid statusCode: ' + statusCode);
-    }
-
-    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
-      return this;
-    }
-
-    if (stunServers || turnServers) {
-      if (stunServers) {
-        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
-        if (!iceServers) {
-          throw new TypeError('Invalid stunServers: '+ stunServers);
-        } else {
-          this.stunServers = iceServers;
-        }
-      }
-
-      if (turnServers) {
-        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
-        if (!iceServers) {
-          throw new TypeError('Invalid turnServers: '+ turnServers);
-        } else {
-          this.turnServers = iceServers;
-        }
-      }
-
-      this.mediaHandler.updateIceServers({
-        stunServers: this.stunServers,
-        turnServers: this.turnServers
-      });
-    }
-
-    function do100rel() {
-      /* jshint validthis: true */
-      statusCode = options.statusCode || 183;
-
-      // Set status and add extra headers
-      this.status = C.STATUS_WAITING_FOR_PRACK;
-      extraHeaders.push('Contact: '+ this.contact);
-      extraHeaders.push('Require: 100rel');
-      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));
-
-      // Save media hint for later (referred sessions)
-      this.mediaHint = options.media;
-
-      // Get the session description to add to preaccept with
-      this.mediaHandler.getDescription(options.media)
-      .then(
-        function onSuccess (description) {
-          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
-            return;
-          }
-
-          this.early_sdp = description.body;
-          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;
-
-          // Retransmit until we get a response or we time out (see prackTimer below)
-          var timeout = SIP.Timers.T1;
-          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {
-            this.request.reply(statusCode, null, extraHeaders, description);
-            timeout *= 2;
-            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);
-          }.bind(this), timeout);
-
-          // Timeout and reject INVITE if no response
-          this.timers.prackTimer = SIP.Timers.setTimeout(function () {
-            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {
-              return;
-            }
-
-            this.logger.log('no PRACK received, rejecting the call');
-            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
-            this.request.reply(504);
-            this.terminated(null, SIP.C.causes.NO_PRACK);
-          }.bind(this), SIP.Timers.T1 * 64);
-
-          // Send the initial response
-          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, description);
-          this.emit('progress', response, reasonPhrase);
-        }.bind(this),
-
-        function onFailure () {
-          this.request.reply(480);
-          this.failed(null, SIP.C.causes.WEBRTC_ERROR);
-          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);
-        }.bind(this)
-      );
-    } // end do100rel
-
-    function normalReply() {
-      /* jshint validthis:true */
-      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
-      this.emit('progress', response, reasonPhrase);
-    }
-
-    if (options.statusCode !== 100 &&
-        (this.rel100 === SIP.C.supported.REQUIRED ||
-         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||
-         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {
-      do100rel.apply(this);
-    } else {
-      normalReply.apply(this);
-    }
-    return this;
-  },
-
-  /*
-   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
-   */
-  accept: function(options) {
-    options = Object.create(Session.desugar(options));
-    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
-    this.mediaHint = options.media;
-
-    this.onInfo = options.onInfo;
-
-    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21
-    var
-      //idx, length, hasAudio, hasVideo,
-      self = this,
-      request = this.request,
-      extraHeaders = (options.extraHeaders || []).slice(),
-    //mediaStream = options.mediaStream || null,
-      iceServers,
-      stunServers = options.stunServers || null,
-      turnServers = options.turnServers || null,
-      descriptionCreationSucceeded = function(description) {
-        var
-          response,
-          // run for reply success callback
-          replySucceeded = function() {
-            self.status = C.STATUS_WAITING_FOR_ACK;
-
-            self.setInvite2xxTimer(request, description);
-            self.setACKTimer();
-          },
-
-          // run for reply failure callback
-          replyFailed = function() {
-            self.failed(null, SIP.C.causes.CONNECTION_ERROR);
-            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);
-          };
-
-        // Chrome might call onaddstream before accept() is called, which means
-        // mediaHandler.render() was called without a renderHint, so we need to
-        // re-render now that mediaHint.render has been set.
-        //
-        // Chrome seems to be in the right regarding this, see
-        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream
-        self.mediaHandler.render();
-
-        extraHeaders.push('Contact: ' + self.contact);
-        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
-
-        // TODO test
-        // http://tools.ietf.org/html/rfc4028#section-9
-        var supportedOptions = request.parseHeader('Supported') || [];
-        var sessionExpires = request.parseHeader('Session-Expires') || {};
-        var interval = sessionExpires.deltaSeconds;
-        if (interval) {
-          var refresher = sessionExpires.refresher || 'uas';
-          extraHeaders.push('Session-Expires: ' + interval + ';' + refresher);
-          if (refresher === 'uac' || supportedOptions.indexOf('timer') >= 0) {
-            extraHeaders.push('Require: timer');
-          }
-        }
-
-        if(!self.hasOffer) {
-          self.hasOffer = true;
-        } else {
-          self.hasAnswer = true;
-        }
-        response = request.reply(200, null, extraHeaders,
-                      description,
-                      replySucceeded,
-                      replyFailed
-                     );
-        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail
-          self.accepted(response, SIP.Utils.getReasonPhrase(200));
-        }
-      },
-
-      descriptionCreationFailed = function() {
-        if (self.status === C.STATUS_TERMINATED) {
-          return;
-        }
-        // TODO - fail out on error
-        self.request.reply(480);
-        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
-        self.failed(null, SIP.C.causes.WEBRTC_ERROR);
-        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
-      };
-
-    // Check Session Status
-    if (this.status === C.STATUS_WAITING_FOR_PRACK) {
-      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;
-      return this;
-    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {
-      this.status = C.STATUS_ANSWERED;
-    } else if (this.status !== C.STATUS_EARLY_MEDIA) {
-      throw new SIP.Exceptions.InvalidStateError(this.status);
-    }
-
-    if ((stunServers || turnServers) &&
-        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {
-      if (stunServers) {
-        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
-        if (!iceServers) {
-          throw new TypeError('Invalid stunServers: '+ stunServers);
-        } else {
-          this.stunServers = iceServers;
-        }
-      }
-
-      if (turnServers) {
-        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
-        if (!iceServers) {
-          throw new TypeError('Invalid turnServers: '+ turnServers);
-        } else {
-          this.turnServers = iceServers;
-        }
-      }
-
-      this.mediaHandler.updateIceServers({
-        stunServers: this.stunServers,
-        turnServers: this.turnServers
-      });
-    }
-
-    // An error on dialog creation will fire 'failed' event
-    if(!this.createDialog(request, 'UAS')) {
-      request.reply(500, 'Missing Contact header field');
-      return this;
-    }
-
-    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);
-
-    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21
-    /*
-    length = this.getRemoteStreams().length;
-
-    for (idx = 0; idx < length; idx++) {
-      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {
-        hasVideo = true;
-      }
-      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {
-        hasAudio = true;
-      }
-    }
-
-    if (!hasAudio && this.mediaConstraints.audio === true) {
-      this.mediaConstraints.audio = false;
-      if (mediaStream) {
-        length = mediaStream.getAudioTracks().length;
-        for (idx = 0; idx < length; idx++) {
-          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
-        }
-      }
-    }
-
-    if (!hasVideo && this.mediaConstraints.video === true) {
-      this.mediaConstraints.video = false;
-      if (mediaStream) {
-        length = mediaStream.getVideoTracks().length;
-        for (idx = 0; idx < length; idx++) {
-          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
-        }
-      }
-    }
-    */
-
-    if (this.status === C.STATUS_EARLY_MEDIA) {
-      descriptionCreationSucceeded({});
-    } else {
-      this.mediaHandler.getDescription(self.mediaHint)
-      .then(
-        descriptionCreationSucceeded,
-        descriptionCreationFailed
-      );
-    }
-
-    return this;
-  },
-
-  receiveRequest: function(request) {
-
-    // ISC RECEIVE REQUEST
-
-    function confirmSession() {
-      /* jshint validthis:true */
-      var contentType;
-
-      SIP.Timers.clearTimeout(this.timers.ackTimer);
-      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
-      this.status = C.STATUS_CONFIRMED;
-      this.unmute();
-
-      // TODO - this logic assumes Content-Disposition defaults
-      contentType = request.getHeader('Content-Type');
-      if (!this.mediaHandler.hasDescription(request)) {
-        this.renderbody = request.body;
-        this.rendertype = contentType;
-      }
-
-      this.emit('confirmed', request);
-    }
-
-    switch(request.method) {
-    case SIP.C.CANCEL:
-      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
-       * was in progress and that the UAC MAY continue with the session established by
-       * any 2xx response, or MAY terminate with BYE. SIP does continue with the
-       * established session. So the CANCEL is processed only if the session is not yet
-       * established.
-       */
-
-      /*
-       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the
-       *request opening the session.
-       */
-      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||
-         this.status === C.STATUS_WAITING_FOR_PRACK ||
-         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||
-         this.status === C.STATUS_EARLY_MEDIA ||
-         this.status === C.STATUS_ANSWERED) {
-
-        this.status = C.STATUS_CANCELED;
-        this.request.reply(487);
-        this.canceled(request);
-        this.rejected(request, SIP.C.causes.CANCELED);
-        this.failed(request, SIP.C.causes.CANCELED);
-        this.terminated(request, SIP.C.causes.CANCELED);
-      }
-      break;
-    case SIP.C.ACK:
-      if(this.status === C.STATUS_WAITING_FOR_ACK) {
-        if (!this.hasAnswer) {
-          if(this.mediaHandler.hasDescription(request)) {
-            // ACK contains answer to an INVITE w/o SDP negotiation
-            this.hasAnswer = true;
-            this.mediaHandler.setDescription(request)
-            .then(
-              confirmSession.bind(this),
-              function onFailure (e) {
-                this.logger.warn(e);
-                this.terminate({
-                  statusCode: '488',
-                  reasonPhrase: 'Bad Media Description'
-                });
-                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-              }.bind(this)
-            );
-          } else if (this.early_sdp) {
-            confirmSession.apply(this);
-          } else {
-            //TODO: Pass to mediahandler
-            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-          }
-        } else {
-          confirmSession.apply(this);
-        }
-      }
-      break;
-    case SIP.C.PRACK:
-      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
-        //localMedia = session.mediaHandler.localMedia;
-        if(!this.hasAnswer) {
-          if(this.mediaHandler.hasDescription(request)) {
-            this.hasAnswer = true;
-            this.mediaHandler.setDescription(request)
-            .then(
-              function onSuccess () {
-                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
-                SIP.Timers.clearTimeout(this.timers.prackTimer);
-                request.reply(200);
-                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
-                  this.status = C.STATUS_EARLY_MEDIA;
-                  this.accept();
-                }
-                this.status = C.STATUS_EARLY_MEDIA;
-                //REVISIT
-                this.mute();
-              }.bind(this),
-              function onFailure (e) {
-                //TODO: Send to media handler
-                this.logger.warn(e);
-                this.terminate({
-                  statusCode: '488',
-                  reasonPhrase: 'Bad Media Description'
-                });
-                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-              }.bind(this)
-            );
-          } else {
-            this.terminate({
-              statusCode: '488',
-              reasonPhrase: 'Bad Media Description'
-            });
-            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-          }
-        } else {
-          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
-          SIP.Timers.clearTimeout(this.timers.prackTimer);
-          request.reply(200);
-
-          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
-            this.status = C.STATUS_EARLY_MEDIA;
-            this.accept();
-          }
-          this.status = C.STATUS_EARLY_MEDIA;
-          //REVISIT
-          this.mute();
-        }
-      } else if(this.status === C.STATUS_EARLY_MEDIA) {
-        request.reply(200);
-      }
-      break;
-    default:
-      Session.prototype.receiveRequest.apply(this, [request]);
-      break;
-    }
-  },
-
-  onTransportError: function() {
-    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
-      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
-    }
-  },
-
-  onRequestTimeout: function() {
-    if (this.status === C.STATUS_CONFIRMED) {
-      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
-    } else if (this.status !== C.STATUS_TERMINATED) {
-      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
-      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
-    }
-  }
-
-};
-
-SIP.InviteServerContext = InviteServerContext;
-
-InviteClientContext = function(ua, target, options) {
-  options = Object.create(Session.desugar(options));
-  options.params = Object.create(options.params || Object.prototype);
-
-  var iceServers,
-    extraHeaders = (options.extraHeaders || []).slice(),
-    stunServers = options.stunServers || null,
-    turnServers = options.turnServers || null,
-    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,
-    isMediaSupported = mediaHandlerFactory.isSupported;
-
-  // Check WebRTC support
-  if (isMediaSupported && !isMediaSupported()) {
-    throw new SIP.Exceptions.NotSupportedError('Media not supported');
-  }
-
-  this.RTCConstraints = options.RTCConstraints || {};
-  this.inviteWithoutSdp = options.inviteWithoutSdp || false;
-
-  // Set anonymous property
-  this.anonymous = options.anonymous || false;
-
-  // Custom data to be sent either in INVITE or in ACK
-  this.renderbody = options.renderbody || null;
-  this.rendertype = options.rendertype || 'text/plain';
-
-  options.params.from_tag = this.from_tag;
-
-  /* Do not add ;ob in initial forming dialog requests if the registration over
-   *  the current connection got a GRUU URI.
-   */
-  this.contact = ua.contact.toString({
-    anonymous: this.anonymous,
-    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu
-  });
-
-  if (this.anonymous) {
-    options.params.from_displayName = 'Anonymous';
-    options.params.from_uri = 'sip:anonymous@anonymous.invalid';
-
-    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());
-    extraHeaders.push('Privacy: id');
-  }
-  extraHeaders.push('Contact: '+ this.contact);
-  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
-  if (this.inviteWithoutSdp && this.renderbody) {
-    extraHeaders.push('Content-Type: ' + this.rendertype);
-    extraHeaders.push('Content-Disposition: render;handling=optional');
-  }
-
-  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {
-    extraHeaders.push('Require: 100rel');
-  }
-  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {
-    extraHeaders.push('Require: replaces');
-  }
-
-  options.extraHeaders = extraHeaders;
-
-  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);
-  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);
-
-  // Check Session Status
-  if (this.status !== C.STATUS_NULL) {
-    throw new SIP.Exceptions.InvalidStateError(this.status);
-  }
-
-  // Session parameter initialization
-  this.from_tag = SIP.Utils.newTag();
-
-  // OutgoingSession specific parameters
-  this.isCanceled = false;
-  this.received_100 = false;
-
-  this.method = SIP.C.INVITE;
-
-  this.receiveNonInviteResponse = this.receiveResponse;
-  this.receiveResponse = this.receiveInviteResponse;
-
-  this.logger = ua.getLogger('sip.inviteclientcontext');
-
-  if (stunServers) {
-    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
-    if (!iceServers) {
-      throw new TypeError('Invalid stunServers: '+ stunServers);
-    } else {
-      this.stunServers = iceServers;
-    }
-  }
-
-  if (turnServers) {
-    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
-    if (!iceServers) {
-      throw new TypeError('Invalid turnServers: '+ turnServers);
-    } else {
-      this.turnServers = iceServers;
-    }
-  }
-
-  ua.applicants[this] = this;
-
-  this.id = this.request.call_id + this.from_tag;
-
-  //Initialize Media Session
-  this.mediaHandler = this.mediaHandlerFactory(this, {
-    RTCConstraints: this.RTCConstraints,
-    stunServers: this.stunServers,
-    turnServers: this.turnServers
-  });
-
-  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
-    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
-    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
-  }
-
-  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
-  this.mediaHint = options.media;
-
-  this.onInfo = options.onInfo;
-};
-
-InviteClientContext.prototype = {
-  invite: function () {
-    var self = this;
-
-    //Save the session into the ua sessions collection.
-    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
-    this.ua.sessions[this.id] = this;
-
-    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level
-    // and hand sip.js a stream as the mediaHint
-    if (this.inviteWithoutSdp) {
-      //just send an invite with no sdp...
-      this.request.body = self.renderbody;
-      this.status = C.STATUS_INVITE_SENT;
-      this.send();
-    } else {
-      this.mediaHandler.getDescription(self.mediaHint)
-      .then(
-        function onSuccess(description) {
-          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
-            return;
-          }
-          self.hasOffer = true;
-          self.request.body = description;
-          self.status = C.STATUS_INVITE_SENT;
-          self.send();
-        },
-        function onFailure() {
-          if (self.status === C.STATUS_TERMINATED) {
-            return;
-          }
-          // TODO...fail out
-          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
-          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);
-          self.failed(null, SIP.C.causes.WEBRTC_ERROR);
-          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
-        }
-      );
-    }
-
-    return this;
-  },
-
-  receiveInviteResponse: function(response) {
-    var cause, //localMedia,
-      session = this,
-      id = response.call_id + response.from_tag + response.to_tag,
-      extraHeaders = [],
-      options = {};
-
-    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {
-      return;
-    }
-
-    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {
-      if (id !== this.dialog.id.toString() ) {
-        if (!this.createDialog(response, 'UAC', true)) {
-          return;
-        }
-        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,
-                                          {
-                                            body: SIP.Utils.generateFakeSDP(response.body)
-                                          });
-        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);
-
-        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable
-         * leg (due to peerConnection limitations) has been answered first. If your forking
-         * proxy does not hang up all unanswered branches on the first branch answered, remove this.
-         */
-        if(this.status !== C.STATUS_CONFIRMED) {
-          this.failed(response, SIP.C.causes.WEBRTC_ERROR);
-          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);
-        }
-        return;
-      } else if (this.status === C.STATUS_CONFIRMED) {
-        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
-        return;
-      } else if (!this.hasAnswer) {
-        // invite w/o sdp is waiting for callback
-        //an invite with sdp must go on, and hasAnswer is true
-        return;
-      }
-    }
-
-    if (this.dialog && response.status_code < 200) {
-      /*
-        Early media has been set up with at least one other different branch,
-        but a final 2xx response hasn't been received
-      */
-      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||
-          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {
-        return;
-      }
-
-      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {
-        return;
-      }
-
-      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
-          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
-        return;
-      }
-
-      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
-      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
-
-      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
-        extraHeaders: extraHeaders,
-        body: SIP.Utils.generateFakeSDP(response.body)
-      });
-      return;
-    }
-
-    // Proceed to cancellation if the user requested.
-    if(this.isCanceled) {
-      if(response.status_code >= 100 && response.status_code < 200) {
-        this.request.cancel(this.cancelReason, extraHeaders);
-        this.canceled(null);
-      } else if(response.status_code >= 200 && response.status_code < 299) {
-        this.acceptAndTerminate(response);
-        this.emit('bye', this.request);
-      } else if (response.status_code >= 300) {
-        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;
-        this.rejected(response, cause);
-        this.failed(response, cause);
-        this.terminated(response, cause);
-      }
-      return;
-    }
-
-    switch(true) {
-      case /^100$/.test(response.status_code):
-        this.received_100 = true;
-        this.emit('progress', response);
-        break;
-      case (/^1[0-9]{2}$/.test(response.status_code)):
-        // Do nothing with 1xx responses without To tag.
-        if(!response.to_tag) {
-          this.logger.warn('1xx response received without to tag');
-          break;
-        }
-
-        // Create Early Dialog if 1XX comes with contact
-        if(response.hasHeader('contact')) {
-          // An error on dialog creation will fire 'failed' event
-          if (!this.createDialog(response, 'UAC', true)) {
-            break;
-          }
-        }
-
-        this.status = C.STATUS_1XX_RECEIVED;
-
-        if(response.hasHeader('require') &&
-           response.getHeader('require').indexOf('100rel') !== -1) {
-
-          // Do nothing if this.dialog is already confirmed
-          if (this.dialog || !this.earlyDialogs[id]) {
-            break;
-          }
-
-          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
-              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
-            return;
-          }
-
-          if (!this.mediaHandler.hasDescription(response)) {
-            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
-            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
-            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
-              extraHeaders: extraHeaders
-            });
-            this.emit('progress', response);
-
-          } else if (this.hasOffer) {
-            if (!this.createDialog(response, 'UAC')) {
-              break;
-            }
-            this.hasAnswer = true;
-            this.dialog.pracked.push(response.getHeader('rseq'));
-
-            this.mediaHandler.setDescription(response)
-            .then(
-              function onSuccess () {
-                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
-
-                session.sendRequest(SIP.C.PRACK, {
-                  extraHeaders: extraHeaders,
-                  receiveResponse: function() {}
-                });
-                session.status = C.STATUS_EARLY_MEDIA;
-                session.mute();
-                session.emit('progress', response);
-                /*
-                if (session.status === C.STATUS_EARLY_MEDIA) {
-                  localMedia = session.mediaHandler.localMedia;
-                  if (localMedia.getAudioTracks().length > 0) {
-                    localMedia.getAudioTracks()[0].enabled = false;
-                  }
-                  if (localMedia.getVideoTracks().length > 0) {
-                    localMedia.getVideoTracks()[0].enabled = false;
-                  }
-                }*/
-              },
-              function onFailure (e) {
-                session.logger.warn(e);
-                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
-                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-              }
-            );
-          } else {
-            var earlyDialog = this.earlyDialogs[id];
-            var earlyMedia = earlyDialog.mediaHandler;
-
-            earlyDialog.pracked.push(response.getHeader('rseq'));
-
-            earlyMedia.setDescription(response)
-            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))
-            .then(function onSuccess(description) {
-              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
-              earlyDialog.sendRequest(session, SIP.C.PRACK, {
-                extraHeaders: extraHeaders,
-                body: description
-              });
-              session.status = C.STATUS_EARLY_MEDIA;
-              session.emit('progress', response);
-            })
-            .catch(function onFailure(e) {
-              if (e instanceof SIP.Exceptions.GetDescriptionError) {
-                earlyDialog.pracked.push(response.getHeader('rseq'));
-                if (session.status === C.STATUS_TERMINATED) {
-                  return;
-                }
-                // TODO - fail out on error
-                // session.failed(gum error);
-                session.failed(null, SIP.C.causes.WEBRTC_ERROR);
-                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);
-              } else {
-                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);
-                // Could not set remote description
-                session.logger.warn('invalid description');
-                session.logger.warn(e);
-              }
-            });
-          }
-        } else {
-          this.emit('progress', response);
-        }
-        break;
-      case /^2[0-9]{2}$/.test(response.status_code):
-        var cseq = this.request.cseq + ' ' + this.request.method;
-        if (cseq !== response.getHeader('cseq')) {
-          break;
-        }
-
-        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {
-          this.status = C.STATUS_CONFIRMED;
-          this.unmute();
-          /*localMedia = this.mediaHandler.localMedia;
-          if (localMedia.getAudioTracks().length > 0) {
-            localMedia.getAudioTracks()[0].enabled = true;
-          }
-          if (localMedia.getVideoTracks().length > 0) {
-            localMedia.getVideoTracks()[0].enabled = true;
-          }*/
-          options = {};
-          if (this.renderbody) {
-            extraHeaders.push('Content-Type: ' + this.rendertype);
-            options.extraHeaders = extraHeaders;
-            options.body = this.renderbody;
-          }
-          options.cseq = response.cseq;
-          this.sendRequest(SIP.C.ACK, options);
-          this.accepted(response);
-          break;
-        }
-        // Do nothing if this.dialog is already confirmed
-        if (this.dialog) {
-          break;
-        }
-
-        // This is an invite without sdp
-        if (!this.hasOffer) {
-          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {
-            //REVISIT
-            this.hasOffer = true;
-            this.hasAnswer = true;
-            this.mediaHandler = this.earlyDialogs[id].mediaHandler;
-            if (!this.createDialog(response, 'UAC')) {
-              break;
-            }
-            this.status = C.STATUS_CONFIRMED;
-            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});
-
-            this.unmute();
-            /*
-            localMedia = session.mediaHandler.localMedia;
-            if (localMedia.getAudioTracks().length > 0) {
-              localMedia.getAudioTracks()[0].enabled = true;
-            }
-            if (localMedia.getVideoTracks().length > 0) {
-              localMedia.getVideoTracks()[0].enabled = true;
-            }*/
-            this.accepted(response);
-          } else {
-            if(!this.mediaHandler.hasDescription(response)) {
-              this.acceptAndTerminate(response, 400, 'Missing session description');
-              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-              break;
-            }
-            if (!this.createDialog(response, 'UAC')) {
-              break;
-            }
-            this.hasOffer = true;
-            this.mediaHandler.setDescription(response)
-            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
-            .then(function onSuccess(description) {
-              //var localMedia;
-              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {
-                return;
-              }
-
-              session.status = C.STATUS_CONFIRMED;
-              session.hasAnswer = true;
-
-              session.unmute();
-              /*localMedia = session.mediaHandler.localMedia;
-              if (localMedia.getAudioTracks().length > 0) {
-                localMedia.getAudioTracks()[0].enabled = true;
-              }
-              if (localMedia.getVideoTracks().length > 0) {
-                localMedia.getVideoTracks()[0].enabled = true;
-              }*/
-              session.sendRequest(SIP.C.ACK,{
-                body: description,
-                cseq:response.cseq
-              });
-              session.accepted(response);
-            })
-            .catch(function onFailure(e) {
-              if (e instanceof SIP.Exceptions.GetDescriptionError) {
-                // TODO do something here
-                session.logger.warn("there was a problem");
-              } else {
-                session.logger.warn('invalid description');
-                session.logger.warn(e);
-                response.reply(488);
-              }
-            });
-          }
-        } else if (this.hasAnswer){
-          if (this.renderbody) {
-            extraHeaders.push('Content-Type: ' + session.rendertype);
-            options.extraHeaders = extraHeaders;
-            options.body = this.renderbody;
-          }
-          this.sendRequest(SIP.C.ACK, options);
-        } else {
-          if(!this.mediaHandler.hasDescription(response)) {
-            this.acceptAndTerminate(response, 400, 'Missing session description');
-            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-            break;
-          }
-          if (!this.createDialog(response, 'UAC')) {
-            break;
-          }
-          this.hasAnswer = true;
-          this.mediaHandler.setDescription(response)
-          .then(
-            function onSuccess () {
-              var options = {};//,localMedia;
-              session.status = C.STATUS_CONFIRMED;
-              session.unmute();
-              /*localMedia = session.mediaHandler.localMedia;
-              if (localMedia.getAudioTracks().length > 0) {
-                localMedia.getAudioTracks()[0].enabled = true;
-              }
-              if (localMedia.getVideoTracks().length > 0) {
-                localMedia.getVideoTracks()[0].enabled = true;
-              }*/
-              if (session.renderbody) {
-                extraHeaders.push('Content-Type: ' + session.rendertype);
-                options.extraHeaders = extraHeaders;
-                options.body = session.renderbody;
-              }
-              options.cseq = response.cseq;
-              session.sendRequest(SIP.C.ACK, options);
-              session.accepted(response);
-            },
-            function onFailure (e) {
-              session.logger.warn(e);
-              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
-              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
-            }
-          );
-        }
-        break;
-      default:
-        cause = SIP.Utils.sipErrorCause(response.status_code);
-        this.rejected(response, cause);
-        this.failed(response, cause);
-        this.terminated(response, cause);
-    }
-  },
-
-  cancel: function(options) {
-    options = options || {};
-
-    options.extraHeaders = (options.extraHeaders || []).slice();
-
-    // Check Session Status
-    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {
-      throw new SIP.Exceptions.InvalidStateError(this.status);
-    }
-
-    this.logger.log('canceling RTCSession');
-
-    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
-
-    // Check Session Status
-    if (this.status === C.STATUS_NULL ||
-        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {
-      this.isCanceled = true;
-      this.cancelReason = cancel_reason;
-    } else if (this.status === C.STATUS_INVITE_SENT ||
-               this.status === C.STATUS_1XX_RECEIVED ||
-               this.status === C.STATUS_EARLY_MEDIA) {
-      this.request.cancel(cancel_reason, options.extraHeaders);
-    }
-
-    return this.canceled();
-  },
-
-  terminate: function(options) {
-    if (this.status === C.STATUS_TERMINATED) {
-      return this;
-    }
-
-    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {
-      this.bye(options);
-    } else {
-      this.cancel(options);
-    }
-
-    return this;
-  },
-
-  receiveRequest: function(request) {
-    // ICC RECEIVE REQUEST
-
-    // Reject CANCELs
-    if (request.method === SIP.C.CANCEL) {
-      // TODO; make this a switch when it gets added
-    }
-
-    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {
-      SIP.Timers.clearTimeout(this.timers.ackTimer);
-      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
-      this.status = C.STATUS_CONFIRMED;
-      this.unmute();
-
-      this.accepted();
-    }
-
-    return Session.prototype.receiveRequest.apply(this, [request]);
-  },
-
-  onTransportError: function() {
-    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
-      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
-    }
-  },
-
-  onRequestTimeout: function() {
-    if (this.status === C.STATUS_CONFIRMED) {
-      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
-    } else if (this.status !== C.STATUS_TERMINATED) {
-      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
-      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
-    }
-  }
-
-};
-
-SIP.InviteClientContext = InviteClientContext;
-
-};
-
-},{"./RFC4028":37,"./Session/DTMF":45}],45:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview DTMF
- */
-
-/**
- * @class DTMF
- * @param {SIP.Session} session
- */
-module.exports = function (SIP) {
-
-var DTMF,
-  C = {
-    MIN_DURATION:            70,
-    MAX_DURATION:            6000,
-    DEFAULT_DURATION:        100,
-    MIN_INTER_TONE_GAP:      50,
-    DEFAULT_INTER_TONE_GAP:  500
-  };
-
-DTMF = function(session, tone, options) {
-  var duration, interToneGap;
-
-  if (tone === undefined) {
-    throw new TypeError('Not enough arguments');
-  }
-
-  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);
-  this.owner = session;
-  this.direction = null;
-
-  options = options || {};
-  duration = options.duration || null;
-  interToneGap = options.interToneGap || null;
-
-  // Check tone type
-  if (typeof tone === 'string' ) {
-    tone = tone.toUpperCase();
-  } else if (typeof tone === 'number') {
-    tone = tone.toString();
-  } else {
-    throw new TypeError('Invalid tone: '+ tone);
-  }
-
-  // Check tone value
-  if (!tone.match(/^[0-9A-D#*]$/)) {
-    throw new TypeError('Invalid tone: '+ tone);
-  } else {
-    this.tone = tone;
-  }
-
-  // Check duration
-  if (duration && !SIP.Utils.isDecimal(duration)) {
-    throw new TypeError('Invalid tone duration: '+ duration);
-  } else if (!duration) {
-    duration = DTMF.C.DEFAULT_DURATION;
-  } else if (duration < DTMF.C.MIN_DURATION) {
-    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');
-    duration = DTMF.C.MIN_DURATION;
-  } else if (duration > DTMF.C.MAX_DURATION) {
-    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');
-    duration = DTMF.C.MAX_DURATION;
-  } else {
-    duration = Math.abs(duration);
-  }
-  this.duration = duration;
-
-  // Check interToneGap
-  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {
-    throw new TypeError('Invalid interToneGap: '+ interToneGap);
-  } else if (!interToneGap) {
-    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;
-  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {
-    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');
-    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;
-  } else {
-    interToneGap = Math.abs(interToneGap);
-  }
-  this.interToneGap = interToneGap;
-};
-DTMF.prototype = Object.create(SIP.EventEmitter.prototype);
-
-
-DTMF.prototype.send = function(options) {
-  var extraHeaders,
-    body = {};
-
-  this.direction = 'outgoing';
-
-  // Check RTCSession Status
-  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&
-    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {
-    throw new SIP.Exceptions.InvalidStateError(this.owner.status);
-  }
-
-  // Get DTMF options
-  options = options || {};
-  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
-
-  body.contentType = 'application/dtmf-relay';
-
-  body.body = "Signal= " + this.tone + "\r\n";
-  body.body += "Duration= " + this.duration;
-
-  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {
-    extraHeaders: extraHeaders,
-    body: body
-  });
-
-  this.owner.emit('dtmf', this.request, this);
-};
-
-/**
- * @private
- */
-DTMF.prototype.receiveResponse = function(response) {
-  var cause;
-
-  switch(true) {
-    case /^1[0-9]{2}$/.test(response.status_code):
-      // Ignore provisional responses.
-      break;
-
-    case /^2[0-9]{2}$/.test(response.status_code):
-      this.emit('succeeded', {
-        originator: 'remote',
-        response: response
-      });
-      break;
-
-    default:
-      cause = SIP.Utils.sipErrorCause(response.status_code);
-      this.emit('failed', response, cause);
-      break;
-  }
-};
-
-/**
- * @private
- */
-DTMF.prototype.onRequestTimeout = function() {
-  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
-  this.owner.onRequestTimeout();
-};
-
-/**
- * @private
- */
-DTMF.prototype.onTransportError = function() {
-  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
-  this.owner.onTransportError();
-};
-
-/**
- * @private
- */
-DTMF.prototype.onDialogError = function(response) {
-  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);
-  this.owner.onDialogError(response);
-};
-
-/**
- * @private
- */
-DTMF.prototype.init_incoming = function(request) {
-  this.direction = 'incoming';
-  this.request = request;
-
-  request.reply(200);
-
-  if (!this.tone || !this.duration) {
-    this.logger.warn('invalid INFO DTMF received, discarded');
-  } else {
-    this.owner.emit('dtmf', request, this);
-  }
-};
-
-DTMF.C = C;
-return DTMF;
-};
-
-},{}],46:[function(require,module,exports){
-"use strict";
-
-/**
- * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)
- */
-
-/**
- * @augments SIP
- * @class Class creating a SIP Subscription.
- */
-module.exports = function (SIP) {
-SIP.Subscription = function (ua, target, event, options) {
-  options = Object.create(options || Object.prototype);
-  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();
-
-  this.id = null;
-  this.state = 'init';
-
-  if (!event) {
-    throw new TypeError('Event necessary to create a subscription.');
-  } else {
-    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?
-    //The check may need to/should probably occur on the other side,
-    this.event = event;
-  }
-
-  if(typeof options.expires !== 'number'){
-    ua.logger.warn('expires must be a number. Using default of 3600.');
-    this.expires = 3600;
-  } else {
-    this.expires = options.expires;
-  }
-
-  options.extraHeaders.push('Event: ' + this.event);
-  options.extraHeaders.push('Expires: ' + this.expires);
-
-  if (options.body) {
-    this.body = options.body;
-  }
-
-  this.contact = ua.contact.toString();
-
-  options.extraHeaders.push('Contact: '+ this.contact);
-  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
-
-  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);
-
-  this.logger = ua.getLogger('sip.subscription');
-
-  this.dialog = null;
-  this.timers = {N: null, sub_duration: null};
-  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];
-};
-
-SIP.Subscription.prototype = {
-  subscribe: function() {
-    var sub = this;
-
-     //these states point to an existing subscription, no subscribe is necessary
-    if (this.state === 'active') {
-      this.refresh();
-      return this;
-    } else if (this.state === 'notify_wait') {
-      return this;
-    }
-
-    SIP.Timers.clearTimeout(this.timers.sub_duration);
-    SIP.Timers.clearTimeout(this.timers.N);
-    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
-
-    this.send();
-
-    this.state = 'notify_wait';
-
-    return this;
-  },
-
-  refresh: function () {
-    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {
-      return;
-    }
-
-    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {
-      extraHeaders: this.extraHeaders,
-      body: this.body
-    });
-  },
-
-  receiveResponse: function(response) {
-    var expires, sub = this,
-        cause = SIP.Utils.getReasonPhrase(response.status_code);
-
-    if ((this.state === 'notify_wait' && response.status_code >= 300) ||
-        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {
-      this.failed(response, null);
-    } else if (/^2[0-9]{2}$/.test(response.status_code)){
-      expires = response.getHeader('Expires');
-      SIP.Timers.clearTimeout(this.timers.N);
-
-      if (this.createConfirmedDialog(response,'UAC')) {
-        this.id = this.dialog.id.toString();
-        this.ua.subscriptions[this.id] = this;
-        this.emit('accepted', response, cause);
-        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?
-      }
-
-      if (expires && expires <= this.expires) {
-        // Preserve new expires value for subsequent requests
-        this.expires = expires;
-        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);
-      } else {
-        if (!expires) {
-          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');
-          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);
-        } else {
-          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');
-          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);
-        }
-      }
-    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx
-  },
-
-  unsubscribe: function() {
-    var extraHeaders = [], sub = this;
-
-    this.state = 'terminated';
-
-    extraHeaders.push('Event: ' + this.event);
-    extraHeaders.push('Expires: 0');
-
-    extraHeaders.push('Contact: '+ this.contact);
-    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
-
-    //makes sure expires isn't set, and other typical resubscribe behavior
-    this.receiveResponse = function(){};
-
-    this.dialog.sendRequest(this, this.method, {
-      extraHeaders: extraHeaders,
-      body: this.body
-    });
-
-    SIP.Timers.clearTimeout(this.timers.sub_duration);
-    SIP.Timers.clearTimeout(this.timers.N);
-    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
-  },
-
-  /**
-  * @private
-  */
-  timer_fire: function(){
-    if (this.state === 'terminated') {
-      this.terminateDialog();
-      SIP.Timers.clearTimeout(this.timers.N);
-      SIP.Timers.clearTimeout(this.timers.sub_duration);
-
-      delete this.ua.subscriptions[this.id];
-    } else if (this.state === 'pending' || this.state === 'notify_wait') {
-      this.close();
-    } else {
-      this.refresh();
-    }
-  },
-
-  /**
-  * @private
-  */
-  close: function() {
-    if(this.state !== 'notify_wait' && this.state !== 'terminated') {
-      this.unsubscribe();
-    }
-  },
-
-  /**
-  * @private
-  */
-  createConfirmedDialog: function(message, type) {
-    var dialog;
-
-    this.terminateDialog();
-    dialog = new SIP.Dialog(this, message, type);
-
-    if(!dialog.error) {
-      this.dialog = dialog;
-      return true;
-    }
-    // Dialog not created due to an error
-    else {
-      return false;
-    }
-  },
-
-  /**
-  * @private
-  */
-  terminateDialog: function() {
-    if(this.dialog) {
-      delete this.ua.subscriptions[this.id];
-      this.dialog.terminate();
-      delete this.dialog;
-    }
-  },
-
-  /**
-  * @private
-  */
-  receiveRequest: function(request) {
-    var sub_state, sub = this;
-
-    function setExpiresTimeout() {
-      if (sub_state.expires) {
-        SIP.Timers.clearTimeout(sub.timers.sub_duration);
-        sub_state.expires = Math.min(sub.expires,
-                                     Math.max(sub_state.expires, 0));
-        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),
-                                                    sub_state.expires * 900);
-      }
-    }
-
-    if (!this.matchEvent(request)) { //checks event and subscription_state headers
-      request.reply(489);
-      return;
-    }
-
-    sub_state = request.parseHeader('Subscription-State');
-
-    request.reply(200, SIP.C.REASON_200);
-
-    SIP.Timers.clearTimeout(this.timers.N);
-
-    this.emit('notify', {request: request});
-
-    // if we've set state to terminated, no further processing should take place
-    // and we are only interested in cleaning up after the appropriate NOTIFY
-    if (this.state === 'terminated') {
-      if (sub_state.state === 'terminated') {
-        this.terminateDialog();
-        SIP.Timers.clearTimeout(this.timers.N);
-        SIP.Timers.clearTimeout(this.timers.sub_duration);
-
-        delete this.ua.subscriptions[this.id];
-      }
-      return;
-    }
-
-    switch (sub_state.state) {
-      case 'active':
-        this.state = 'active';
-        setExpiresTimeout();
-        break;
-      case 'pending':
-        if (this.state === 'notify_wait') {
-          setExpiresTimeout();
-        }
-        this.state = 'pending';
-        break;
-      case 'terminated':
-        SIP.Timers.clearTimeout(this.timers.sub_duration);
-        if (sub_state.reason) {
-          this.logger.log('terminating subscription with reason '+ sub_state.reason);
-          switch (sub_state.reason) {
-            case 'deactivated':
-            case 'timeout':
-              this.subscribe();
-              return;
-            case 'probation':
-            case 'giveup':
-              if(sub_state.params && sub_state.params['retry-after']) {
-                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);
-              } else {
-                this.subscribe();
-              }
-              return;
-            case 'rejected':
-            case 'noresource':
-            case 'invariant':
-              break;
-          }
-        }
-        this.close();
-        break;
-    }
-  },
-
-  failed: function(response, cause) {
-    this.close();
-    this.emit('failed', response, cause);
-    return this;
-  },
-
-  onDialogError: function(response) {
-    this.failed(response, SIP.C.causes.DIALOG_ERROR);
-  },
-
-  /**
-  * @private
-  */
-  matchEvent: function(request) {
-    var event;
-
-    // Check mandatory header Event
-    if (!request.hasHeader('Event')) {
-      this.logger.warn('missing Event header');
-      return false;
-    }
-    // Check mandatory header Subscription-State
-    if (!request.hasHeader('Subscription-State')) {
-      this.logger.warn('missing Subscription-State header');
-      return false;
-    }
-
-    // Check whether the event in NOTIFY matches the event in SUBSCRIBE
-    event = request.parseHeader('event').event;
-
-    if (this.event !== event) {
-      this.logger.warn('event match failed');
-      request.reply(481, 'Event Match Failed');
-      return false;
-    } else {
-      return true;
-    }
-  }
-};
-};
-
-},{}],47:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP TIMERS
- */
-
-/**
- * @augments SIP
- */
-var
-  T1 = 500,
-  T2 = 4000,
-  T4 = 5000;
-module.exports = function (timers) {
-  var Timers = {
-    T1: T1,
-    T2: T2,
-    T4: T4,
-    TIMER_B: 64 * T1,
-    TIMER_D: 0  * T1,
-    TIMER_F: 64 * T1,
-    TIMER_H: 64 * T1,
-    TIMER_I: 0  * T1,
-    TIMER_J: 0  * T1,
-    TIMER_K: 0  * T4,
-    TIMER_L: 64 * T1,
-    TIMER_M: 64 * T1,
-    TIMER_N: 64 * T1,
-    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
-  };
-
-  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']
-  .forEach(function (name) {
-    // can't just use timers[name].bind(timers) since it bypasses jasmine's
-    // clock-mocking
-    Timers[name] = function () {
-      return timers[name].apply(timers, arguments);
-    };
-  });
-
-  return Timers;
-};
-
-},{}],48:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP Transactions
- */
-
-/**
- * SIP Transactions module.
- * @augments SIP
- */
-module.exports = function (SIP) {
-var
-  C = {
-    // Transaction states
-    STATUS_TRYING:     1,
-    STATUS_PROCEEDING: 2,
-    STATUS_CALLING:    3,
-    STATUS_ACCEPTED:   4,
-    STATUS_COMPLETED:  5,
-    STATUS_TERMINATED: 6,
-    STATUS_CONFIRMED:  7,
-
-    // Transaction types
-    NON_INVITE_CLIENT: 'nict',
-    NON_INVITE_SERVER: 'nist',
-    INVITE_CLIENT: 'ict',
-    INVITE_SERVER: 'ist'
-  };
-
-function buildViaHeader (request_sender, transport, id) {
-  var via;
-  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);
-  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;
-  if (request_sender.ua.configuration.forceRport) {
-    via += ';rport';
-  }
-  return via;
-}
-
-/**
-* @augments SIP.Transactions
-* @class Non Invite Client Transaction
-* @param {SIP.RequestSender} request_sender
-* @param {SIP.OutgoingRequest} request
-* @param {SIP.Transport} transport
-*/
-var NonInviteClientTransaction = function(request_sender, request, transport) {
-  var via;
-
-  this.type = C.NON_INVITE_CLIENT;
-  this.transport = transport;
-  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
-  this.request_sender = request_sender;
-  this.request = request;
-
-  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
-
-  via = buildViaHeader(request_sender, transport, this.id);
-  this.request.setHeader('via', via);
-
-  this.request_sender.ua.newTransaction(this);
-};
-NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
-
-NonInviteClientTransaction.prototype.stateChanged = function(state) {
-  this.state = state;
-  this.emit('stateChanged');
-};
-
-NonInviteClientTransaction.prototype.send = function() {
-  var tr = this;
-
-  this.stateChanged(C.STATUS_TRYING);
-  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);
-
-  if(!this.transport.send(this.request)) {
-    this.onTransportError();
-  }
-};
-
-NonInviteClientTransaction.prototype.onTransportError = function() {
-  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);
-  SIP.Timers.clearTimeout(this.F);
-  SIP.Timers.clearTimeout(this.K);
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.request_sender.ua.destroyTransaction(this);
-  this.request_sender.onTransportError();
-};
-
-NonInviteClientTransaction.prototype.timer_F = function() {
-  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.request_sender.ua.destroyTransaction(this);
-  this.request_sender.onRequestTimeout();
-};
-
-NonInviteClientTransaction.prototype.timer_K = function() {
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.request_sender.ua.destroyTransaction(this);
-};
-
-NonInviteClientTransaction.prototype.receiveResponse = function(response) {
-  var
-    tr = this,
-    status_code = response.status_code;
-
-  if(status_code < 200) {
-    switch(this.state) {
-      case C.STATUS_TRYING:
-      case C.STATUS_PROCEEDING:
-        this.stateChanged(C.STATUS_PROCEEDING);
-        this.request_sender.receiveResponse(response);
-        break;
-    }
-  } else {
-    switch(this.state) {
-      case C.STATUS_TRYING:
-      case C.STATUS_PROCEEDING:
-        this.stateChanged(C.STATUS_COMPLETED);
-        SIP.Timers.clearTimeout(this.F);
-
-        if(status_code === 408) {
-          this.request_sender.onRequestTimeout();
-        } else {
-          this.request_sender.receiveResponse(response);
-        }
-
-        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);
-        break;
-      case C.STATUS_COMPLETED:
-        break;
-    }
-  }
-};
-
-
-
-/**
-* @augments SIP.Transactions
-* @class Invite Client Transaction
-* @param {SIP.RequestSender} request_sender
-* @param {SIP.OutgoingRequest} request
-* @param {SIP.Transport} transport
-*/
-var InviteClientTransaction = function(request_sender, request, transport) {
-  var via,
-    tr = this;
-
-  this.type = C.INVITE_CLIENT;
-  this.transport = transport;
-  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
-  this.request_sender = request_sender;
-  this.request = request;
-
-  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);
-
-  via = buildViaHeader(request_sender, transport, this.id);
-  this.request.setHeader('via', via);
-
-  this.request_sender.ua.newTransaction(this);
-
-  // Add the cancel property to the request.
-  //Will be called from the request instance, not the transaction itself.
-  this.request.cancel = function(reason, extraHeaders) {
-    extraHeaders = (extraHeaders || []).slice();
-    var length = extraHeaders.length;
-    var extraHeadersString = null;
-    for (var idx = 0; idx < length; idx++) {
-      extraHeadersString = (extraHeadersString || '') + extraHeaders[idx].trim() + '\r\n';
-    }
-
-    tr.cancel_request(tr, reason, extraHeadersString);
-  };
-};
-InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
-
-InviteClientTransaction.prototype.stateChanged = function(state) {
-  this.state = state;
-  this.emit('stateChanged');
-};
-
-InviteClientTransaction.prototype.send = function() {
-  var tr = this;
-  this.stateChanged(C.STATUS_CALLING);
-  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);
-
-  if(!this.transport.send(this.request)) {
-    this.onTransportError();
-  }
-};
-
-InviteClientTransaction.prototype.onTransportError = function() {
-  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);
-  SIP.Timers.clearTimeout(this.B);
-  SIP.Timers.clearTimeout(this.D);
-  SIP.Timers.clearTimeout(this.M);
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.request_sender.ua.destroyTransaction(this);
-
-  if (this.state !== C.STATUS_ACCEPTED) {
-    this.request_sender.onTransportError();
-  }
-};
-
-// RFC 6026 7.2
-InviteClientTransaction.prototype.timer_M = function() {
-  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);
-
-  if(this.state === C.STATUS_ACCEPTED) {
-    SIP.Timers.clearTimeout(this.B);
-    this.stateChanged(C.STATUS_TERMINATED);
-    this.request_sender.ua.destroyTransaction(this);
-  }
-};
-
-// RFC 3261 17.1.1
-InviteClientTransaction.prototype.timer_B = function() {
-  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);
-  if(this.state === C.STATUS_CALLING) {
-    this.stateChanged(C.STATUS_TERMINATED);
-    this.request_sender.ua.destroyTransaction(this);
-    this.request_sender.onRequestTimeout();
-  }
-};
-
-InviteClientTransaction.prototype.timer_D = function() {
-  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);
-  SIP.Timers.clearTimeout(this.B);
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.request_sender.ua.destroyTransaction(this);
-};
-
-InviteClientTransaction.prototype.sendACK = function(response) {
-  var tr = this;
-
-  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
-  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\r\n';
-
-  if(this.request.headers['Route']) {
-    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\r\n';
-  }
-
-  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
-  this.ack += 'From: ' + this.request.headers['From'].toString() + '\r\n';
-  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
-  this.ack += 'Content-Length: 0\r\n';
-  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];
-  this.ack += ' ACK\r\n\r\n';
-
-  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);
-
-  this.transport.send(this.ack);
-};
-
-InviteClientTransaction.prototype.cancel_request = function(tr, reason, extraHeaders) {
-  var request = tr.request;
-
-  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
-  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\r\n';
-
-  if(this.request.headers['Route']) {
-    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\r\n';
-  }
-
-  this.cancel += 'To: ' + request.headers['To'].toString() + '\r\n';
-  this.cancel += 'From: ' + request.headers['From'].toString() + '\r\n';
-  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
-  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +
-  ' CANCEL\r\n';
-
-  if(reason) {
-    this.cancel += 'Reason: ' + reason + '\r\n';
-  }
-
-  if (extraHeaders) {
-    this.cancel += extraHeaders;
-  }
-
-  this.cancel += 'Content-Length: 0\r\n\r\n';
-
-  // Send only if a provisional response (>100) has been received.
-  if(this.state === C.STATUS_PROCEEDING) {
-    this.transport.send(this.cancel);
-  }
-};
-
-InviteClientTransaction.prototype.receiveResponse = function(response) {
-  var
-  tr = this,
-  status_code = response.status_code;
-
-  if(status_code >= 100 && status_code <= 199) {
-    switch(this.state) {
-      case C.STATUS_CALLING:
-        this.stateChanged(C.STATUS_PROCEEDING);
-        this.request_sender.receiveResponse(response);
-        if(this.cancel) {
-          this.transport.send(this.cancel);
-        }
-        break;
-      case C.STATUS_PROCEEDING:
-        this.request_sender.receiveResponse(response);
-        break;
-    }
-  } else if(status_code >= 200 && status_code <= 299) {
-    switch(this.state) {
-      case C.STATUS_CALLING:
-      case C.STATUS_PROCEEDING:
-        this.stateChanged(C.STATUS_ACCEPTED);
-        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);
-        this.request_sender.receiveResponse(response);
-        break;
-      case C.STATUS_ACCEPTED:
-        this.request_sender.receiveResponse(response);
-        break;
-    }
-  } else if(status_code >= 300 && status_code <= 699) {
-    switch(this.state) {
-      case C.STATUS_CALLING:
-      case C.STATUS_PROCEEDING:
-        this.stateChanged(C.STATUS_COMPLETED);
-        this.sendACK(response);
-        this.request_sender.receiveResponse(response);
-        break;
-      case C.STATUS_COMPLETED:
-        this.sendACK(response);
-        break;
-    }
-  }
-};
-
-
-/**
- * @augments SIP.Transactions
- * @class ACK Client Transaction
- * @param {SIP.RequestSender} request_sender
- * @param {SIP.OutgoingRequest} request
- * @param {SIP.Transport} transport
- */
-var AckClientTransaction = function(request_sender, request, transport) {
-  var via;
-
-  this.transport = transport;
-  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
-  this.request_sender = request_sender;
-  this.request = request;
-
-  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
-
-  via = buildViaHeader(request_sender, transport, this.id);
-  this.request.setHeader('via', via);
-};
-AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
-
-AckClientTransaction.prototype.send = function() {
-  if(!this.transport.send(this.request)) {
-    this.onTransportError();
-  }
-};
-
-AckClientTransaction.prototype.onTransportError = function() {
-  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);
-  this.request_sender.onTransportError();
-};
-
-
-/**
-* @augments SIP.Transactions
-* @class Non Invite Server Transaction
-* @param {SIP.IncomingRequest} request
-* @param {SIP.UA} ua
-*/
-var NonInviteServerTransaction = function(request, ua) {
-  this.type = C.NON_INVITE_SERVER;
-  this.id = request.via_branch;
-  this.request = request;
-  this.transport = request.transport;
-  this.ua = ua;
-  this.last_response = '';
-  request.server_transaction = this;
-
-  this.logger = ua.getLogger('sip.transaction.nist', this.id);
-
-  this.state = C.STATUS_TRYING;
-
-  ua.newTransaction(this);
-};
-NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
-
-NonInviteServerTransaction.prototype.stateChanged = function(state) {
-  this.state = state;
-  this.emit('stateChanged');
-};
-
-NonInviteServerTransaction.prototype.timer_J = function() {
-  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.ua.destroyTransaction(this);
-};
-
-NonInviteServerTransaction.prototype.onTransportError = function() {
-  if (!this.transportError) {
-    this.transportError = true;
-
-    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);
-
-    SIP.Timers.clearTimeout(this.J);
-    this.stateChanged(C.STATUS_TERMINATED);
-    this.ua.destroyTransaction(this);
-  }
-};
-
-NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
-  var tr = this;
-  var deferred = SIP.Utils.defer();
-
-  if(status_code === 100) {
-    /* RFC 4320 4.1
-     * 'A SIP element MUST NOT
-     * send any provisional response with a
-     * Status-Code other than 100 to a non-INVITE request.'
-     */
-    switch(this.state) {
-      case C.STATUS_TRYING:
-        this.stateChanged(C.STATUS_PROCEEDING);
-        if(!this.transport.send(response))  {
-          this.onTransportError();
-        }
-        break;
-      case C.STATUS_PROCEEDING:
-        this.last_response = response;
-        if(!this.transport.send(response)) {
-          this.onTransportError();
-          deferred.reject();
-        } else {
-          deferred.resolve();
-        }
-        break;
-    }
-  } else if(status_code >= 200 && status_code <= 699) {
-    switch(this.state) {
-      case C.STATUS_TRYING:
-      case C.STATUS_PROCEEDING:
-        this.stateChanged(C.STATUS_COMPLETED);
-        this.last_response = response;
-        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);
-        if(!this.transport.send(response)) {
-          this.onTransportError();
-          deferred.reject();
-        } else {
-          deferred.resolve();
-        }
-        break;
-      case C.STATUS_COMPLETED:
-        break;
-    }
-  }
-
-  return deferred.promise;
-};
-
-/**
-* @augments SIP.Transactions
-* @class Invite Server Transaction
-* @param {SIP.IncomingRequest} request
-* @param {SIP.UA} ua
-*/
-var InviteServerTransaction = function(request, ua) {
-  this.type = C.INVITE_SERVER;
-  this.id = request.via_branch;
-  this.request = request;
-  this.transport = request.transport;
-  this.ua = ua;
-  this.last_response = '';
-  request.server_transaction = this;
-
-  this.logger = ua.getLogger('sip.transaction.ist', this.id);
-
-  this.state = C.STATUS_PROCEEDING;
-
-  ua.newTransaction(this);
-
-  this.resendProvisionalTimer = null;
-
-  request.reply(100);
-};
-InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
-
-InviteServerTransaction.prototype.stateChanged = function(state) {
-  this.state = state;
-  this.emit('stateChanged');
-};
-
-InviteServerTransaction.prototype.timer_H = function() {
-  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);
-
-  if(this.state === C.STATUS_COMPLETED) {
-    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
-  }
-
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.ua.destroyTransaction(this);
-};
-
-InviteServerTransaction.prototype.timer_I = function() {
-  this.stateChanged(C.STATUS_TERMINATED);
-  this.ua.destroyTransaction(this);
-};
-
-// RFC 6026 7.1
-InviteServerTransaction.prototype.timer_L = function() {
-  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);
-
-  if(this.state === C.STATUS_ACCEPTED) {
-    this.stateChanged(C.STATUS_TERMINATED);
-    this.ua.destroyTransaction(this);
-  }
-};
-
-InviteServerTransaction.prototype.onTransportError = function() {
-  if (!this.transportError) {
-    this.transportError = true;
-
-    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);
-
-    if (this.resendProvisionalTimer !== null) {
-      SIP.Timers.clearInterval(this.resendProvisionalTimer);
-      this.resendProvisionalTimer = null;
-    }
-
-    SIP.Timers.clearTimeout(this.L);
-    SIP.Timers.clearTimeout(this.H);
-    SIP.Timers.clearTimeout(this.I);
-
-    this.stateChanged(C.STATUS_TERMINATED);
-    this.ua.destroyTransaction(this);
-  }
-};
-
-InviteServerTransaction.prototype.resend_provisional = function() {
-  if(!this.transport.send(this.last_response)) {
-    this.onTransportError();
-  }
-};
-
-// INVITE Server Transaction RFC 3261 17.2.1
-InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
-  var tr = this;
-  var deferred = SIP.Utils.defer();
-
-  if(status_code >= 100 && status_code <= 199) {
-    switch(this.state) {
-      case C.STATUS_PROCEEDING:
-        if(!this.transport.send(response)) {
-          this.onTransportError();
-        }
-        this.last_response = response;
-        break;
-    }
-  }
-
-  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
-    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
-    if(this.resendProvisionalTimer === null) {
-      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),
-        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);
-    }
-  } else if(status_code >= 200 && status_code <= 299) {
-    switch(this.state) {
-      case C.STATUS_PROCEEDING:
-        this.stateChanged(C.STATUS_ACCEPTED);
-        this.last_response = response;
-        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);
-
-        if (this.resendProvisionalTimer !== null) {
-          SIP.Timers.clearInterval(this.resendProvisionalTimer);
-          this.resendProvisionalTimer = null;
-        }
-        /* falls through */
-        case C.STATUS_ACCEPTED:
-          // Note that this point will be reached for proceeding tr.state also.
-          if(!this.transport.send(response)) {
-            this.onTransportError();
-            deferred.reject();
-          } else {
-            deferred.resolve();
-          }
-          break;
-    }
-  } else if(status_code >= 300 && status_code <= 699) {
-    switch(this.state) {
-      case C.STATUS_PROCEEDING:
-        if (this.resendProvisionalTimer !== null) {
-          SIP.Timers.clearInterval(this.resendProvisionalTimer);
-          this.resendProvisionalTimer = null;
-        }
-
-        if(!this.transport.send(response)) {
-          this.onTransportError();
-          deferred.reject();
-        } else {
-          this.stateChanged(C.STATUS_COMPLETED);
-          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);
-          deferred.resolve();
-        }
-        break;
-    }
-  }
-
-  return deferred.promise;
-};
-
-/**
- * @function
- * @param {SIP.UA} ua
- * @param {SIP.IncomingRequest} request
- *
- * @return {boolean}
- * INVITE:
- *  _true_ if retransmission
- *  _false_ new request
- *
- * ACK:
- *  _true_  ACK to non2xx response
- *  _false_ ACK must be passed to TU (accepted state)
- *          ACK to 2xx response
- *
- * CANCEL:
- *  _true_  no matching invite transaction
- *  _false_ matching invite transaction and no final response sent
- *
- * OTHER:
- *  _true_  retransmission
- *  _false_ new request
- */
-var checkTransaction = function(ua, request) {
-  var tr;
-
-  switch(request.method) {
-    case SIP.C.INVITE:
-      tr = ua.transactions.ist[request.via_branch];
-      if(tr) {
-        switch(tr.state) {
-          case C.STATUS_PROCEEDING:
-            tr.transport.send(tr.last_response);
-            break;
-
-            // RFC 6026 7.1 Invite retransmission
-            //received while in C.STATUS_ACCEPTED state. Absorb it.
-          case C.STATUS_ACCEPTED:
-            break;
-        }
-        return true;
-      }
-      break;
-    case SIP.C.ACK:
-      tr = ua.transactions.ist[request.via_branch];
-
-      // RFC 6026 7.1
-      if(tr) {
-        if(tr.state === C.STATUS_ACCEPTED) {
-          return false;
-        } else if(tr.state === C.STATUS_COMPLETED) {
-          tr.stateChanged(C.STATUS_CONFIRMED);
-          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);
-          return true;
-        }
-      }
-
-      // ACK to 2XX Response.
-      else {
-        return false;
-      }
-      break;
-    case SIP.C.CANCEL:
-      tr = ua.transactions.ist[request.via_branch];
-      if(tr) {
-        request.reply_sl(200);
-        if(tr.state === C.STATUS_PROCEEDING) {
-          return false;
-        } else {
-          return true;
-        }
-      } else {
-        request.reply_sl(481);
-        return true;
-      }
-      break;
-    default:
-
-      // Non-INVITE Server Transaction RFC 3261 17.2.2
-      tr = ua.transactions.nist[request.via_branch];
-      if(tr) {
-        switch(tr.state) {
-          case C.STATUS_TRYING:
-            break;
-          case C.STATUS_PROCEEDING:
-          case C.STATUS_COMPLETED:
-            tr.transport.send(tr.last_response);
-            break;
-        }
-        return true;
-      }
-      break;
-  }
-};
-
-SIP.Transactions = {
-  C: C,
-  checkTransaction: checkTransaction,
-  NonInviteClientTransaction: NonInviteClientTransaction,
-  InviteClientTransaction: InviteClientTransaction,
-  AckClientTransaction: AckClientTransaction,
-  NonInviteServerTransaction: NonInviteServerTransaction,
-  InviteServerTransaction: InviteServerTransaction
-};
-
-};
-
-},{}],49:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview Transport
- */
-
-/**
- * @augments SIP
- * @class Transport
- * @param {SIP.UA} ua
- * @param {Object} server ws_server Object
- */
-module.exports = function (SIP, WebSocket) {
-var Transport,
-  C = {
-    // Transport status codes
-    STATUS_READY:        0,
-    STATUS_DISCONNECTED: 1,
-    STATUS_ERROR:        2
-  };
-
-/**
- * Compute an amount of time in seconds to wait before sending another
- * keep-alive.
- * @returns {Number}
- */
-function computeKeepAliveTimeout(upperBound) {
-  var lowerBound = upperBound * 0.8;
-  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
-}
-
-Transport = function(ua, server) {
-
-  this.logger = ua.getLogger('sip.transport');
-  this.ua = ua;
-  this.ws = null;
-  this.server = server;
-  this.reconnection_attempts = 0;
-  this.closed = false;
-  this.connected = false;
-  this.reconnectTimer = null;
-  this.lastTransportError = {};
-
-  this.keepAliveInterval = ua.configuration.keepAliveInterval;
-  this.keepAliveTimeout = null;
-  this.keepAliveTimer = null;
-
-  this.ua.transport = this;
-
-  // Connect
-  this.connect();
-};
-
-Transport.prototype = {
-  /**
-   * Send a message.
-   * @param {SIP.OutgoingRequest|String} msg
-   * @returns {Boolean}
-   */
-  send: function(msg) {
-    var message = msg.toString();
-
-    if(this.ws && this.ws.readyState === WebSocket.OPEN) {
-      if (this.ua.configuration.traceSip === true) {
-        this.logger.log('sending WebSocket message:\n\n' + message + '\n');
-      }
-      this.ws.send(message);
-      return true;
-    } else {
-      this.logger.warn('unable to send message, WebSocket is not open');
-      return false;
-    }
-  },
-
-  /**
-   * Send a keep-alive (a double-CRLF sequence).
-   * @private
-   * @returns {Boolean}
-   */
-  sendKeepAlive: function() {
-    if(this.keepAliveTimeout) { return; }
-
-    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {
-      this.ua.emit('keepAliveTimeout');
-    }.bind(this), 10000);
-
-    return this.send('\r\n\r\n');
-  },
-
-  /**
-   * Start sending keep-alives.
-   * @private
-   */
-  startSendingKeepAlives: function() {
-    if (this.keepAliveInterval && !this.keepAliveTimer) {
-      this.keepAliveTimer = SIP.Timers.setTimeout(function() {
-        this.sendKeepAlive();
-        this.keepAliveTimer = null;
-        this.startSendingKeepAlives();
-      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));
-    }
-  },
-
-  /**
-   * Stop sending keep-alives.
-   * @private
-   */
-  stopSendingKeepAlives: function() {
-    SIP.Timers.clearTimeout(this.keepAliveTimer);
-    SIP.Timers.clearTimeout(this.keepAliveTimeout);
-    this.keepAliveTimer = null;
-    this.keepAliveTimeout = null;
-  },
-
-  /**
-  * Disconnect socket.
-  */
-  disconnect: function() {
-    if(this.ws) {
-      // Clear reconnectTimer
-      SIP.Timers.clearTimeout(this.reconnectTimer);
-
-      this.stopSendingKeepAlives();
-
-      this.closed = true;
-      this.logger.log('closing WebSocket ' + this.server.ws_uri);
-      this.ws.close();
-    }
-
-    if (this.reconnectTimer !== null) {
-      SIP.Timers.clearTimeout(this.reconnectTimer);
-      this.reconnectTimer = null;
-      this.ua.emit('disconnected', {
-        transport: this,
-        code: this.lastTransportError.code,
-        reason: this.lastTransportError.reason
-      });
-    }
-  },
-
-  /**
-  * Connect socket.
-  */
-  connect: function() {
-    var transport = this;
-
-    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
-      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
-      return false;
-    }
-
-    if(this.ws) {
-      this.ws.close();
-    }
-
-    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
-    this.ua.onTransportConnecting(this,
-      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);
-
-    try {
-      this.ws = new WebSocket(this.server.ws_uri, 'sip');
-    } catch(e) {
-      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
-    }
-
-    this.ws.binaryType = 'arraybuffer';
-
-    this.ws.onopen = function() {
-      transport.onOpen();
-    };
-
-    this.ws.onclose = function(e) {
-      transport.onClose(e);
-    };
-
-    this.ws.onmessage = function(e) {
-      transport.onMessage(e);
-    };
-
-    this.ws.onerror = function(e) {
-      transport.onError(e);
-    };
-  },
-
-  // Transport Event Handlers
-
-  /**
-  * @event
-  * @param {event} e
-  */
-  onOpen: function() {
-    this.connected = true;
-
-    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');
-    // Clear reconnectTimer since we are not disconnected
-    if (this.reconnectTimer !== null) {
-      SIP.Timers.clearTimeout(this.reconnectTimer);
-      this.reconnectTimer = null;
-    }
-    // Reset reconnection_attempts
-    this.reconnection_attempts = 0;
-    // Disable closed
-    this.closed = false;
-    // Trigger onTransportConnected callback
-    this.ua.onTransportConnected(this);
-    // Start sending keep-alives
-    this.startSendingKeepAlives();
-  },
-
-  /**
-  * @event
-  * @param {event} e
-  */
-  onClose: function(e) {
-    var connected_before = this.connected;
-
-    this.lastTransportError.code = e.code;
-    this.lastTransportError.reason = e.reason;
-
-    this.stopSendingKeepAlives();
-
-    if (this.reconnection_attempts > 0) {
-      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
-      this.reconnect();
-    } else {
-      this.connected = false;
-      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
-
-      if(e.wasClean === false) {
-        this.logger.warn('WebSocket abrupt disconnection');
-      }
-      // Transport was connected
-      if(connected_before === true) {
-        this.ua.onTransportClosed(this);
-        // Check whether the user requested to close.
-        if(!this.closed) {
-          this.reconnect();
-        } else {
-          this.ua.emit('disconnected', {
-            transport: this,
-            code: this.lastTransportError.code,
-            reason: this.lastTransportError.reason
-          });
-
-        }
-      } else {
-        // This is the first connection attempt
-        //Network error
-        this.ua.onTransportError(this);
-      }
-    }
-  },
-
-  /**
-  * @event
-  * @param {event} e
-  */
-  onMessage: function(e) {
-    var message, transaction,
-      data = e.data;
-
-    // CRLF Keep Alive response from server. Ignore it.
-    if(data === '\r\n') {
-      SIP.Timers.clearTimeout(this.keepAliveTimeout);
-      this.keepAliveTimeout = null;
-
-      if (this.ua.configuration.traceSip === true) {
-        this.logger.log('received WebSocket message with CRLF Keep Alive response');
-      }
-
-      return;
-    }
-
-    // WebSocket binary message.
-    else if (typeof data !== 'string') {
-      try {
-        data = String.fromCharCode.apply(null, new Uint8Array(data));
-      } catch(evt) {
-        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
-        return;
-      }
-
-      if (this.ua.configuration.traceSip === true) {
-        this.logger.log('received WebSocket binary message:\n\n' + data + '\n');
-      }
-    }
-
-    // WebSocket text message.
-    else {
-      if (this.ua.configuration.traceSip === true) {
-        this.logger.log('received WebSocket text message:\n\n' + data + '\n');
-      }
-    }
-
-    message = SIP.Parser.parseMessage(data, this.ua);
-
-    if (!message) {
-      return;
-    }
-
-    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {
-      return;
-    }
-
-    // Do some sanity check
-    if(SIP.sanityCheck(message, this.ua, this)) {
-      if(message instanceof SIP.IncomingRequest) {
-        message.transport = this;
-        this.ua.receiveRequest(message);
-      } else if(message instanceof SIP.IncomingResponse) {
-        /* Unike stated in 18.1.2, if a response does not match
-        * any transaction, it is discarded here and no passed to the core
-        * in order to be discarded there.
-        */
-        switch(message.method) {
-          case SIP.C.INVITE:
-            transaction = this.ua.transactions.ict[message.via_branch];
-            if(transaction) {
-              transaction.receiveResponse(message);
-            }
-            break;
-          case SIP.C.ACK:
-            // Just in case ;-)
-            break;
-          default:
-            transaction = this.ua.transactions.nict[message.via_branch];
-            if(transaction) {
-              transaction.receiveResponse(message);
-            }
-            break;
-        }
-      }
-    }
-  },
-
-  /**
-  * @event
-  * @param {event} e
-  */
-  onError: function(e) {
-    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));
-  },
-
-  /**
-  * Reconnection attempt logic.
-  * @private
-  */
-  reconnect: function() {
-    var transport = this;
-
-    this.reconnection_attempts += 1;
-
-    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {
-      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
-      this.ua.onTransportError(this);
-    } else if (this.reconnection_attempts === 1) {
-      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');
-      transport.connect();
-    } else {
-      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');
-
-      this.reconnectTimer = SIP.Timers.setTimeout(function() {
-        transport.connect();
-        transport.reconnectTimer = null;
-      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);
-    }
-  }
-};
-
-Transport.C = C;
-return Transport;
-};
-
-},{}],50:[function(require,module,exports){
-(function (global){
-"use strict";
-/**
- * @augments SIP
- * @class Class creating a SIP User Agent.
- * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]
- *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.
- *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.
- *
- * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
- */
-module.exports = function (SIP, environment) {
-var UA,
-  C = {
-    // UA status codes
-    STATUS_INIT:                0,
-    STATUS_STARTING:            1,
-    STATUS_READY:               2,
-    STATUS_USER_CLOSED:         3,
-    STATUS_NOT_READY:           4,
-
-    // UA error codes
-    CONFIGURATION_ERROR:  1,
-    NETWORK_ERROR:        2,
-
-    ALLOWED_METHODS: [
-      'ACK',
-      'CANCEL',
-      'INVITE',
-      'MESSAGE',
-      'BYE',
-      'OPTIONS',
-      'INFO',
-      'NOTIFY',
-      'REFER'
-    ],
-
-    ACCEPTED_BODY_TYPES: [
-      'application/sdp',
-      'application/dtmf-relay'
-    ],
-
-    MAX_FORWARDS: 70,
-    TAG_LENGTH: 10
-  };
-
-UA = function(configuration) {
-  var self = this;
-
-  // Helper function for forwarding events
-  function selfEmit(type) {
-    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments
-    return self.emit.bind(self, type);
-  }
-
-  // Set Accepted Body Types
-  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();
-
-  this.log = new SIP.LoggerFactory();
-  this.logger = this.getLogger('sip.ua');
-
-  this.cache = {
-    credentials: {}
-  };
-
-  this.configuration = {};
-  this.dialogs = {};
-
-  //User actions outside any session/dialog (MESSAGE)
-  this.applicants = {};
-
-  this.data = {};
-  this.sessions = {};
-  this.subscriptions = {};
-  this.transport = null;
-  this.contact = null;
-  this.status = C.STATUS_INIT;
-  this.error = null;
-  this.transactions = {
-    nist: {},
-    nict: {},
-    ist: {},
-    ict: {}
-  };
-
-  this.transportRecoverAttempts = 0;
-  this.transportRecoveryTimer = null;
-
-  Object.defineProperties(this, {
-    transactionsCount: {
-      get: function() {
-        var type,
-          transactions = ['nist','nict','ist','ict'],
-          count = 0;
-
-        for (type in transactions) {
-          count += Object.keys(this.transactions[transactions[type]]).length;
-        }
-
-        return count;
-      }
-    },
-
-    nictTransactionsCount: {
-      get: function() {
-        return Object.keys(this.transactions['nict']).length;
-      }
-    },
-
-    nistTransactionsCount: {
-      get: function() {
-        return Object.keys(this.transactions['nist']).length;
-      }
-    },
-
-    ictTransactionsCount: {
-      get: function() {
-        return Object.keys(this.transactions['ict']).length;
-      }
-    },
-
-    istTransactionsCount: {
-      get: function() {
-        return Object.keys(this.transactions['ist']).length;
-      }
-    }
-  });
-
-  /**
-   * Load configuration
-   *
-   * @throws {SIP.Exceptions.ConfigurationError}
-   * @throws {TypeError}
-   */
-
-  if(configuration === undefined) {
-    configuration = {};
-  } else if (typeof configuration === 'string' || configuration instanceof String) {
-    configuration = {
-      uri: configuration
-    };
-  }
-
-  // Apply log configuration if present
-  if (configuration.log) {
-    if (configuration.log.hasOwnProperty('builtinEnabled')) {
-      this.log.builtinEnabled = configuration.log.builtinEnabled;
-    }
-
-    if (configuration.log.hasOwnProperty('level')) {
-      this.log.level = configuration.log.level;
-    }
-
-    if (configuration.log.hasOwnProperty('connector')) {
-      this.log.connector = configuration.log.connector;
-    }
-  }
-
-  try {
-    this.loadConfig(configuration);
-  } catch(e) {
-    this.status = C.STATUS_NOT_READY;
-    this.error = C.CONFIGURATION_ERROR;
-    throw e;
-  }
-
-  // Initialize registerContext
-  this.registerContext = new SIP.RegisterContext(this);
-  this.registerContext.on('failed', selfEmit('registrationFailed'));
-  this.registerContext.on('registered', selfEmit('registered'));
-  this.registerContext.on('unregistered', selfEmit('unregistered'));
-
-  if(this.configuration.autostart) {
-    this.start();
-  }
-
-  if (typeof environment.addEventListener === 'function') {
-    // Google Chrome Packaged Apps don't allow 'unload' listeners:
-    // unload is not available in packaged apps
-    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {
-      environment.addEventListener('unload', this.stop.bind(this));
-    }
-  }
-};
-UA.prototype = Object.create(SIP.EventEmitter.prototype);
-
-//=================
-//  High Level API
-//=================
-
-UA.prototype.register = function(options) {
-  this.configuration.register = true;
-  this.registerContext.register(options);
-
-  return this;
-};
-
-/**
- * Unregister.
- *
- * @param {Boolean} [all] unregister all user bindings.
- *
- */
-UA.prototype.unregister = function(options) {
-  this.configuration.register = false;
-
-  var context = this.registerContext;
-  this.afterConnected(context.unregister.bind(context, options));
-
-  return this;
-};
-
-UA.prototype.isRegistered = function() {
-  return this.registerContext.registered;
-};
-
-/**
- * Connection state.
- * @param {Boolean}
- */
-UA.prototype.isConnected = function() {
-  return this.transport ? this.transport.connected : false;
-};
-
-UA.prototype.afterConnected = function afterConnected (callback) {
-  if (this.isConnected()) {
-    callback();
-  } else {
-    this.once('connected', callback);
-  }
-};
-
-/**
- * Make an outgoing call.
- *
- * @param {String} target
- * @param {Object} views
- * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
- *
- * @throws {TypeError}
- *
- */
-UA.prototype.invite = function(target, options) {
-  var context = new SIP.InviteClientContext(this, target, options);
-
-  this.afterConnected(context.invite.bind(context));
-  return context;
-};
-
-UA.prototype.subscribe = function(target, event, options) {
-  var sub = new SIP.Subscription(this, target, event, options);
-
-  this.afterConnected(sub.subscribe.bind(sub));
-  return sub;
-};
-
-/**
- * Send a message.
- *
- * @param {String} target
- * @param {String} body
- * @param {Object} [options]
- *
- * @throws {TypeError}
- *
- */
-UA.prototype.message = function(target, body, options) {
-  if (body === undefined) {
-    throw new TypeError('Not enough arguments');
-  }
-
-  // There is no Message module, so it is okay that the UA handles defaults here.
-  options = Object.create(options || Object.prototype);
-  options.contentType || (options.contentType = 'text/plain');
-  options.body = body;
-
-  return this.request(SIP.C.MESSAGE, target, options);
-};
-
-UA.prototype.request = function (method, target, options) {
-  var req = new SIP.ClientContext(this, method, target, options);
-
-  this.afterConnected(req.send.bind(req));
-  return req;
-};
-
-/**
- * Gracefully close.
- *
- */
-UA.prototype.stop = function() {
-  var session, subscription, applicant,
-    ua = this;
-
-  function transactionsListener() {
-    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {
-        ua.removeListener('transactionDestroyed', transactionsListener);
-        ua.transport.disconnect();
-    }
-  }
-
-  this.logger.log('user requested closure...');
-
-  if(this.status === C.STATUS_USER_CLOSED) {
-    this.logger.warn('UA already closed');
-    return this;
-  }
-
-  // Clear transportRecoveryTimer
-  SIP.Timers.clearTimeout(this.transportRecoveryTimer);
-
-  // Close registerContext
-  this.logger.log('closing registerContext');
-  this.registerContext.close();
-
-  // Run  _terminate_ on every Session
-  for(session in this.sessions) {
-    this.logger.log('closing session ' + session);
-    this.sessions[session].terminate();
-  }
-
-  //Run _close_ on every Subscription
-  for(subscription in this.subscriptions) {
-    this.logger.log('unsubscribing from subscription ' + subscription);
-    this.subscriptions[subscription].close();
-  }
-
-  // Run  _close_ on every applicant
-  for(applicant in this.applicants) {
-    this.applicants[applicant].close();
-  }
-
-  this.status = C.STATUS_USER_CLOSED;
-
-  /*
-   * If the remaining transactions are all INVITE transactions, there is no need to
-   * wait anymore because every session has already been closed by this method.
-   * - locally originated sessions where terminated (CANCEL or BYE)
-   * - remotely originated sessions where rejected (4XX) or terminated (BYE)
-   * Remaining INVITE transactions belong tho sessions that where answered. This are in
-   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]
-   */
-  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {
-    if (this.transport) {
-      this.transport.disconnect();
-    }
-  } else {
-    this.on('transactionDestroyed', transactionsListener);
-  }
-
-  return this;
-};
-
-/**
- * Connect to the WS server if status = STATUS_INIT.
- * Resume UA after being closed.
- *
- */
-UA.prototype.start = function() {
-  var server;
-
-  this.logger.log('user requested startup...');
-  if (this.status === C.STATUS_INIT) {
-    server = this.getNextWsServer();
-    this.status = C.STATUS_STARTING;
-    new SIP.Transport(this, server);
-  } else if(this.status === C.STATUS_USER_CLOSED) {
-    this.logger.log('resuming');
-    this.status = C.STATUS_READY;
-    this.transport.connect();
-  } else if (this.status === C.STATUS_STARTING) {
-    this.logger.log('UA is in STARTING status, not opening new connection');
-  } else if (this.status === C.STATUS_READY) {
-    this.logger.log('UA is in READY status, not resuming');
-  } else {
-    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
-  }
-
-  return this;
-};
-
-/**
- * Normalize a string into a valid SIP request URI
- *
- * @param {String} target
- *
- * @returns {SIP.URI|undefined}
- */
-UA.prototype.normalizeTarget = function(target) {
-  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);
-};
-
-
-//===============================
-//  Private (For internal use)
-//===============================
-
-UA.prototype.saveCredentials = function(credentials) {
-  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
-  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
-
-  return this;
-};
-
-UA.prototype.getCredentials = function(request) {
-  var realm, credentials;
-
-  realm = request.ruri.host;
-
-  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
-    credentials = this.cache.credentials[realm][request.ruri];
-    credentials.method = request.method;
-  }
-
-  return credentials;
-};
-
-UA.prototype.getLogger = function(category, label) {
-  return this.log.getLogger(category, label);
-};
-
-
-//==============================
-// Event Handlers
-//==============================
-
-/**
- * Transport Close event
- * @private
- * @event
- * @param {SIP.Transport} transport.
- */
-UA.prototype.onTransportClosed = function(transport) {
-  // Run _onTransportError_ callback on every client transaction using _transport_
-  var type, idx, length,
-    client_transactions = ['nict', 'ict', 'nist', 'ist'];
-
-  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;
-  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);
-
-  length = client_transactions.length;
-  for (type = 0; type < length; type++) {
-    for(idx in this.transactions[client_transactions[type]]) {
-      this.transactions[client_transactions[type]][idx].onTransportError();
-    }
-  }
-
-  // Close sessions if GRUU is not being used
-  if (!this.contact.pub_gruu) {
-    this.closeSessionsOnTransportError();
-  }
-
-};
-
-/**
- * Unrecoverable transport event.
- * Connection reattempt logic has been done and didn't success.
- * @private
- * @event
- * @param {SIP.Transport} transport.
- */
-UA.prototype.onTransportError = function(transport) {
-  var server;
-
-  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);
-
-  // Close sessions.
-  //Mark this transport as 'down'
-  transport.server.status = SIP.Transport.C.STATUS_ERROR;
-
-  this.emit('disconnected', {
-    transport: transport
-  });
-
-  // try the next transport if the UA isn't closed
-  if(this.status === C.STATUS_USER_CLOSED) {
-    return;
-  }
-
-  server = this.getNextWsServer();
-
-  if(server) {
-    new SIP.Transport(this, server);
-  }else {
-    this.closeSessionsOnTransportError();
-    if (!this.error || this.error !== C.NETWORK_ERROR) {
-      this.status = C.STATUS_NOT_READY;
-      this.error = C.NETWORK_ERROR;
-    }
-    // Transport Recovery process
-    this.recoverTransport();
-  }
-};
-
-/**
- * Transport connection event.
- * @private
- * @event
- * @param {SIP.Transport} transport.
- */
-UA.prototype.onTransportConnected = function(transport) {
-  this.transport = transport;
-
-  // Reset transport recovery counter
-  this.transportRecoverAttempts = 0;
-
-  transport.server.status = SIP.Transport.C.STATUS_READY;
-  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);
-
-  if(this.status === C.STATUS_USER_CLOSED) {
-    return;
-  }
-
-  this.status = C.STATUS_READY;
-  this.error = null;
-
-  if(this.configuration.register) {
-    this.configuration.authenticationFactory.initialize().then(function () {
-      this.registerContext.onTransportConnected();
-    }.bind(this));
-  }
-
-  this.emit('connected', {
-    transport: transport
-  });
-};
-
-
-/**
- * Transport connecting event
- * @private
- * @param {SIP.Transport} transport.
- * #param {Integer} attempts.
- */
-  UA.prototype.onTransportConnecting = function(transport, attempts) {
-    this.emit('connecting', {
-      transport: transport,
-      attempts: attempts
-    });
-  };
-
-
-/**
- * new Transaction
- * @private
- * @param {SIP.Transaction} transaction.
- */
-UA.prototype.newTransaction = function(transaction) {
-  this.transactions[transaction.type][transaction.id] = transaction;
-  this.emit('newTransaction', {transaction: transaction});
-};
-
-
-/**
- * destroy Transaction
- * @private
- * @param {SIP.Transaction} transaction.
- */
-UA.prototype.destroyTransaction = function(transaction) {
-  delete this.transactions[transaction.type][transaction.id];
-  this.emit('transactionDestroyed', {
-    transaction: transaction
-  });
-};
-
-
-//=========================
-// receiveRequest
-//=========================
-
-/**
- * Request reception
- * @private
- * @param {SIP.IncomingRequest} request.
- */
-UA.prototype.receiveRequest = function(request) {
-  var dialog, session, message,
-    method = request.method,
-    transaction,
-    replaces,
-    replacedDialog,
-    self = this;
-
-  function ruriMatches (uri) {
-    return uri && uri.user === request.ruri.user;
-  }
-
-  // Check that request URI points to us
-  if(!(ruriMatches(this.configuration.uri) ||
-       ruriMatches(this.contact.uri) ||
-       ruriMatches(this.contact.pub_gruu) ||
-       ruriMatches(this.contact.temp_gruu))) {
-    this.logger.warn('Request-URI does not point to us');
-    if (request.method !== SIP.C.ACK) {
-      request.reply_sl(404);
-    }
-    return;
-  }
-
-  // Check request URI scheme
-  if(request.ruri.scheme === SIP.C.SIPS) {
-    request.reply_sl(416);
-    return;
-  }
-
-  // Check transaction
-  if(SIP.Transactions.checkTransaction(this, request)) {
-    return;
-  }
-
-  /* RFC3261 12.2.2
-   * Requests that do not change in any way the state of a dialog may be
-   * received within a dialog (for example, an OPTIONS request).
-   * They are processed as if they had been received outside the dialog.
-   */
-  if(method === SIP.C.OPTIONS) {
-    new SIP.Transactions.NonInviteServerTransaction(request, this);
-    request.reply(200, null, [
-      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),
-      'Accept: '+ C.ACCEPTED_BODY_TYPES
-    ]);
-  } else if (method === SIP.C.MESSAGE) {
-    message = new SIP.ServerContext(this, request);
-    message.body = request.body;
-    message.content_type = request.getHeader('Content-Type') || 'text/plain';
-
-    request.reply(200, null);
-    this.emit('message', message);
-  } else if (method !== SIP.C.INVITE &&
-             method !== SIP.C.ACK) {
-    // Let those methods pass through to normal processing for now.
-    transaction = new SIP.ServerContext(this, request);
-  }
-
-  // Initial Request
-  if(!request.to_tag) {
-    switch(method) {
-      case SIP.C.INVITE:
-        replaces =
-          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&
-          request.parseHeader('replaces');
-
-        if (replaces) {
-          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];
-
-          if (!replacedDialog) {
-            //Replaced header without a matching dialog, reject
-            request.reply_sl(481, null);
-            return;
-          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {
-            request.reply_sl(603, null);
-            return;
-          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {
-            request.reply_sl(486, null);
-            return;
-          }
-        }
-
-        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;
-        if(!isMediaSupported || isMediaSupported()) {
-          session = new SIP.InviteServerContext(this, request);
-          session.replacee = replacedDialog && replacedDialog.owner;
-          session.on('invite', function() {
-            self.emit('invite', this);
-          });
-        } else {
-          this.logger.warn('INVITE received but WebRTC is not supported');
-          request.reply(488);
-        }
-        break;
-      case SIP.C.BYE:
-        // Out of dialog BYE received
-        request.reply(481);
-        break;
-      case SIP.C.CANCEL:
-        session = this.findSession(request);
-        if(session) {
-          session.receiveRequest(request);
-        } else {
-          this.logger.warn('received CANCEL request for a non existent session');
-        }
-        break;
-      case SIP.C.ACK:
-        /* Absorb it.
-         * ACK request without a corresponding Invite Transaction
-         * and without To tag.
-         */
-        break;
-      case SIP.C.NOTIFY:
-        if (this.configuration.allowLegacyNotifications && this.listeners('notify').length > 0) {
-          request.reply(200, null);
-          self.emit('notify', {request: request});
-        } else {
-          request.reply(481, 'Subscription does not exist');
-        }
-        break;
-      default:
-        request.reply(405);
-        break;
-    }
-  }
-  // In-dialog request
-  else {
-    dialog = this.findDialog(request);
-
-    if(dialog) {
-      if (method === SIP.C.INVITE) {
-        new SIP.Transactions.InviteServerTransaction(request, this);
-      }
-      dialog.receiveRequest(request);
-    } else if (method === SIP.C.NOTIFY) {
-      session = this.findSession(request);
-      if(session) {
-        session.receiveRequest(request);
-      } else {
-        this.logger.warn('received NOTIFY request for a non existent session');
-        request.reply(481, 'Subscription does not exist');
-      }
-    }
-    /* RFC3261 12.2.2
-     * Request with to tag, but no matching dialog found.
-     * Exception: ACK for an Invite request for which a dialog has not
-     * been created.
-     */
-    else {
-      if(method !== SIP.C.ACK) {
-        request.reply(481);
-      }
-    }
-  }
-};
-
-//=================
-// Utils
-//=================
-
-/**
- * Get the session to which the request belongs to, if any.
- * @private
- * @param {SIP.IncomingRequest} request.
- * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}
- */
-UA.prototype.findSession = function(request) {
-  return this.sessions[request.call_id + request.from_tag] ||
-          this.sessions[request.call_id + request.to_tag] ||
-          null;
-};
-
-/**
- * Get the dialog to which the request belongs to, if any.
- * @private
- * @param {SIP.IncomingRequest}
- * @returns {SIP.Dialog|null}
- */
-UA.prototype.findDialog = function(request) {
-  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||
-          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||
-          null;
-};
-
-/**
- * Retrieve the next server to which connect.
- * @private
- * @returns {Object} ws_server
- */
-UA.prototype.getNextWsServer = function() {
-  // Order servers by weight
-  var idx, length, ws_server,
-    candidates = [];
-
-  length = this.configuration.wsServers.length;
-  for (idx = 0; idx < length; idx++) {
-    ws_server = this.configuration.wsServers[idx];
-
-    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {
-      continue;
-    } else if (candidates.length === 0) {
-      candidates.push(ws_server);
-    } else if (ws_server.weight > candidates[0].weight) {
-      candidates = [ws_server];
-    } else if (ws_server.weight === candidates[0].weight) {
-      candidates.push(ws_server);
-    }
-  }
-
-  idx = Math.floor(Math.random() * candidates.length);
-
-  return candidates[idx];
-};
-
-/**
- * Close all sessions on transport error.
- * @private
- */
-UA.prototype.closeSessionsOnTransportError = function() {
-  var idx;
-
-  // Run _transportError_ for every Session
-  for(idx in this.sessions) {
-    this.sessions[idx].onTransportError();
-  }
-  // Call registerContext _onTransportClosed_
-  this.registerContext.onTransportClosed();
-};
-
-UA.prototype.recoverTransport = function(ua) {
-  var idx, length, k, nextRetry, count, server;
-
-  ua = ua || this;
-  count = ua.transportRecoverAttempts;
-
-  length = ua.configuration.wsServers.length;
-  for (idx = 0; idx < length; idx++) {
-    ua.configuration.wsServers[idx].status = 0;
-  }
-
-  server = ua.getNextWsServer();
-
-  k = Math.floor((Math.random() * Math.pow(2,count)) +1);
-  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;
-
-  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {
-    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');
-    nextRetry = ua.configuration.connectionRecoveryMinInterval;
-    count = 0;
-  }
-
-  this.logger.log('next connection attempt in '+ nextRetry +' seconds');
-
-  this.transportRecoveryTimer = SIP.Timers.setTimeout(
-    function(){
-      ua.transportRecoverAttempts = count + 1;
-      new SIP.Transport(ua, server);
-    }, nextRetry * 1000);
-};
-
-function checkAuthenticationFactory (authenticationFactory) {
-  if (!(authenticationFactory instanceof Function)) {
-    return;
-  }
-  if (!authenticationFactory.initialize) {
-    authenticationFactory.initialize = function initialize () {
-      return SIP.Utils.Promise.resolve();
-    };
-  }
-  return authenticationFactory;
-}
-
-/**
- * Configuration load.
- * @private
- * returns {Boolean}
- */
-UA.prototype.loadConfig = function(configuration) {
-  // Settings and default values
-  var parameter, value, checked_value, hostportParams, registrarServer,
-    settings = {
-      /* Host address
-      * Value to be set in Via sent_by and host part of Contact FQDN
-      */
-      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',
-
-      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),
-      wsServers: [{
-        scheme: 'WSS',
-        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',
-        status: 0,
-        weight: 0,
-        ws_uri: 'wss://edge.sip.onsip.com'
-      }],
-
-      // Password
-      password: null,
-
-      // Registration parameters
-      registerExpires: 600,
-      register: true,
-      registrarServer: null,
-
-      // Transport related parameters
-      wsServerMaxReconnection: 3,
-      wsServerReconnectionTimeout: 4,
-
-      connectionRecoveryMinInterval: 2,
-      connectionRecoveryMaxInterval: 30,
-
-      keepAliveInterval: 0,
-
-      extraSupported: [],
-
-      usePreloadedRoute: false,
-
-      //string to be inserted into User-Agent request header
-      userAgentString: SIP.C.USER_AGENT,
-
-      // Session parameters
-      iceCheckingTimeout: 5000,
-      noAnswerTimeout: 60,
-      stunServers: ['stun:stun.l.google.com:19302'],
-      turnServers: [],
-
-      // Logging parameters
-      traceSip: false,
-
-      // Hacks
-      hackViaTcp: false,
-      hackIpInContact: false,
-      hackWssInTransport: false,
-      hackAllowUnregisteredOptionTags: false,
-      hackCleanJitsiSdpImageattr: false,
-      hackStripTcp: false,
-
-      contactTransport: 'ws',
-      forceRport: false,
-
-      //autostarting
-      autostart: true,
-
-      //Reliable Provisional Responses
-      rel100: SIP.C.supported.UNSUPPORTED,
-
-      // Replaces header (RFC 3891)
-      // http://tools.ietf.org/html/rfc3891
-      replaces: SIP.C.supported.UNSUPPORTED,
-
-      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,
-
-      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {
-        return new SIP.DigestAuthentication(ua);
-      }),
-
-      allowLegacyNotifications: false
-    };
-
-  // Pre-Configuration
-  function aliasUnderscored (parameter, logger) {
-    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {
-      return m[0] + '_' + m[1].toLowerCase();
-    });
-
-    if (parameter === underscored) {
-      return;
-    }
-
-    var hasParameter = configuration.hasOwnProperty(parameter);
-    if (configuration.hasOwnProperty(underscored)) {
-      logger.warn(underscored + ' is deprecated, please use ' + parameter);
-      if (hasParameter) {
-        logger.warn(parameter + ' overriding ' + underscored);
-      }
-    }
-
-    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];
-  }
-
-  // Check Mandatory parameters
-  for(parameter in UA.configuration_check.mandatory) {
-    aliasUnderscored(parameter, this.logger);
-    if(!configuration.hasOwnProperty(parameter)) {
-      throw new SIP.Exceptions.ConfigurationError(parameter);
-    } else {
-      value = configuration[parameter];
-      checked_value = UA.configuration_check.mandatory[parameter](value);
-      if (checked_value !== undefined) {
-        settings[parameter] = checked_value;
-      } else {
-        throw new SIP.Exceptions.ConfigurationError(parameter, value);
-      }
-    }
-  }
-
-  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);
-
-  var emptyArraysAllowed = ['stunServers', 'turnServers'];
-
-  // Check Optional parameters
-  for(parameter in UA.configuration_check.optional) {
-    aliasUnderscored(parameter, this.logger);
-    if(configuration.hasOwnProperty(parameter)) {
-      value = configuration[parameter];
-
-      // If the parameter value is an empty array, but shouldn't be, apply its default value.
-      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }
-
-      // If the parameter value is null, empty string, or undefined then apply its default value.
-      if(value === null || value === "" || value === undefined) { continue; }
-      // If it's a number with NaN value then also apply its default value.
-      // NOTE: JS does not allow "value === NaN", the following does the work:
-      else if(typeof(value) === 'number' && isNaN(value)) { continue; }
-
-      checked_value = UA.configuration_check.optional[parameter](value);
-      if (checked_value !== undefined) {
-        settings[parameter] = checked_value;
-      } else {
-        throw new SIP.Exceptions.ConfigurationError(parameter, value);
-      }
-    }
-  }
-
-  // Sanity Checks
-
-  // Connection recovery intervals
-  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {
-    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);
-  }
-
-  // Post Configuration Process
-
-  // Allow passing 0 number as displayName.
-  if (settings.displayName === 0) {
-    settings.displayName = '0';
-  }
-
-  // Instance-id for GRUU
-  if (!settings.instanceId) {
-    settings.instanceId = SIP.Utils.newUUID();
-  }
-
-  // sipjsId instance parameter. Static random tag of length 5
-  settings.sipjsId = SIP.Utils.createRandomToken(5);
-
-  // String containing settings.uri without scheme and user.
-  hostportParams = settings.uri.clone();
-  hostportParams.user = null;
-  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');
-
-  /* Check whether authorizationUser is explicitly defined.
-   * Take 'settings.uri.user' value if not.
-   */
-  if (!settings.authorizationUser) {
-    settings.authorizationUser = settings.uri.user;
-  }
-
-  /* If no 'registrarServer' is set use the 'uri' value without user portion. */
-  if (!settings.registrarServer) {
-    registrarServer = settings.uri.clone();
-    registrarServer.user = null;
-    settings.registrarServer = registrarServer;
-  }
-
-  // User noAnswerTimeout
-  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
-
-  // Via Host
-  if (settings.hackIpInContact) {
-    if (typeof settings.hackIpInContact === 'boolean') {
-      settings.viaHost = SIP.Utils.getRandomTestNetIP();
-    }
-    else if (typeof settings.hackIpInContact === 'string') {
-      settings.viaHost = settings.hackIpInContact;
-    }
-  }
-
-  // Contact transport parameter
-  if (settings.hackWssInTransport) {
-    settings.contactTransport = 'wss';
-  }
-
-  this.contact = {
-    pub_gruu: null,
-    temp_gruu: null,
-    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),
-    toString: function(options){
-      options = options || {};
-
-      var
-        anonymous = options.anonymous || null,
-        outbound = options.outbound || null,
-        contact = '<';
-
-      if (anonymous) {
-        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();
-      } else {
-        contact += (this.pub_gruu || this.uri).toString();
-      }
-
-      if (outbound) {
-        contact += ';ob';
-      }
-
-      contact += '>';
-
-      return contact;
-    }
-  };
-
-  // media overrides mediaConstraints
-  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);
-
-  // Fill the value of the configuration_skeleton
-  for(parameter in settings) {
-    UA.configuration_skeleton[parameter].value = settings[parameter];
-  }
-
-  Object.defineProperties(this.configuration, UA.configuration_skeleton);
-
-  // Clean UA.configuration_skeleton
-  for(parameter in settings) {
-    UA.configuration_skeleton[parameter].value = '';
-  }
-
-  this.logger.log('configuration parameters after validation:');
-  for(parameter in settings) {
-    switch(parameter) {
-      case 'uri':
-      case 'registrarServer':
-      case 'mediaHandlerFactory':
-        this.logger.log('· ' + parameter + ': ' + settings[parameter]);
-        break;
-      case 'password':
-        this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');
-        break;
-      default:
-        this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));
-    }
-  }
-
-  return;
-};
-
-/**
- * Configuration Object skeleton.
- * @private
- */
-UA.configuration_skeleton = (function() {
-  var idx,  parameter,
-    skeleton = {},
-    parameters = [
-      // Internal parameters
-      "sipjsId",
-      "hostportParams",
-
-      // Optional user configurable parameters
-      "uri",
-      "wsServers",
-      "authorizationUser",
-      "connectionRecoveryMaxInterval",
-      "connectionRecoveryMinInterval",
-      "keepAliveInterval",
-      "extraSupported",
-      "displayName",
-      "hackViaTcp", // false.
-      "hackIpInContact", //false
-      "hackWssInTransport", //false
-      "hackAllowUnregisteredOptionTags", //false
-      "hackCleanJitsiSdpImageattr", //false
-      "hackStripTcp", //false
-      "contactTransport", // 'ws'
-      "forceRport", // false
-      "iceCheckingTimeout",
-      "instanceId",
-      "noAnswerTimeout", // 30 seconds.
-      "password",
-      "registerExpires", // 600 seconds.
-      "registrarServer",
-      "reliable",
-      "rel100",
-      "replaces",
-      "userAgentString", //SIP.C.USER_AGENT
-      "autostart",
-      "stunServers",
-      "traceSip",
-      "turnServers",
-      "usePreloadedRoute",
-      "wsServerMaxReconnection",
-      "wsServerReconnectionTimeout",
-      "mediaHandlerFactory",
-      "media",
-      "mediaConstraints",
-      "authenticationFactory",
-      "allowLegacyNotifications",
-
-      // Post-configuration generated parameters
-      "via_core_value",
-      "viaHost"
-    ];
-
-  for(idx in parameters) {
-    parameter = parameters[idx];
-    skeleton[parameter] = {
-      value: '',
-      writable: false,
-      configurable: false
-    };
-  }
-
-  skeleton['register'] = {
-    value: '',
-    writable: true,
-    configurable: false
-  };
-
-  return skeleton;
-}());
-
-/**
- * Configuration checker.
- * @private
- * @return {Boolean}
- */
-UA.configuration_check = {
-  mandatory: {
-  },
-
-  optional: {
-
-    uri: function(uri) {
-      var parsed;
-
-      if (!(/^sip:/i).test(uri)) {
-        uri = SIP.C.SIP + ':' + uri;
-      }
-      parsed = SIP.URI.parse(uri);
-
-      if(!parsed) {
-        return;
-      } else if(!parsed.user) {
-        return;
-      } else {
-        return parsed;
-      }
-    },
-
-    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
-    wsServers: function(wsServers) {
-      var idx, length, url;
-
-      /* Allow defining wsServers parameter as:
-       *  String: "host"
-       *  Array of Strings: ["host1", "host2"]
-       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
-       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
-       */
-      if (typeof wsServers === 'string') {
-        wsServers = [{ws_uri: wsServers}];
-      } else if (wsServers instanceof Array) {
-        length = wsServers.length;
-        for (idx = 0; idx < length; idx++) {
-          if (typeof wsServers[idx] === 'string'){
-            wsServers[idx] = {ws_uri: wsServers[idx]};
-          }
-        }
-      } else {
-        return;
-      }
-
-      if (wsServers.length === 0) {
-        return false;
-      }
-
-      length = wsServers.length;
-      for (idx = 0; idx < length; idx++) {
-        if (!wsServers[idx].ws_uri) {
-          return;
-        }
-        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {
-          return;
-        }
-
-        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');
-
-        if(url === -1) {
-          return;
-        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {
-          return;
-        } else {
-          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';
-
-          if (!wsServers[idx].weight) {
-            wsServers[idx].weight = 0;
-          }
-
-          wsServers[idx].status = 0;
-          wsServers[idx].scheme = url.scheme.toUpperCase();
-        }
-      }
-      return wsServers;
-    },
-
-    authorizationUser: function(authorizationUser) {
-      if(SIP.Grammar.parse('"'+ authorizationUser +'"', 'quoted_string') === -1) {
-        return;
-      } else {
-        return authorizationUser;
-      }
-    },
-
-    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {
-      var value;
-      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {
-        value = Number(connectionRecoveryMaxInterval);
-        if(value > 0) {
-          return value;
-        }
-      }
-    },
-
-    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {
-      var value;
-      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {
-        value = Number(connectionRecoveryMinInterval);
-        if(value > 0) {
-          return value;
-        }
-      }
-    },
-
-    displayName: function(displayName) {
-      if(SIP.Grammar.parse('"' + displayName + '"', 'displayName') === -1) {
-        return;
-      } else {
-        return displayName;
-      }
-    },
-
-    hackViaTcp: function(hackViaTcp) {
-      if (typeof hackViaTcp === 'boolean') {
-        return hackViaTcp;
-      }
-    },
-
-    hackIpInContact: function(hackIpInContact) {
-      if (typeof hackIpInContact === 'boolean') {
-        return hackIpInContact;
-      }
-      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {
-        return hackIpInContact;
-      }
-    },
-
-    iceCheckingTimeout: function(iceCheckingTimeout) {
-      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {
-        return Math.max(500, iceCheckingTimeout);
-      }
-    },
-
-    hackWssInTransport: function(hackWssInTransport) {
-      if (typeof hackWssInTransport === 'boolean') {
-        return hackWssInTransport;
-      }
-    },
-
-    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {
-      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {
-        return hackAllowUnregisteredOptionTags;
-      }
-    },
-
-    hackCleanJitsiSdpImageattr: function(hackCleanJitsiSdpImageattr) {
-      if (typeof hackCleanJitsiSdpImageattr === 'boolean') {
-        return hackCleanJitsiSdpImageattr;
-      }
-    },
-
-    hackStripTcp: function(hackStripTcp) {
-      if (typeof hackStripTcp === 'boolean') {
-        return hackStripTcp;
-      }
-    },
-
-    contactTransport: function(contactTransport) {
-      if (typeof contactTransport === 'string') {
-        return contactTransport;
-      }
-    },
-
-    forceRport: function(forceRport) {
-      if (typeof forceRport === 'boolean') {
-        return forceRport;
-      }
-    },
-
-    instanceId: function(instanceId) {
-      if(typeof instanceId !== 'string') {
-        return;
-      }
-
-      if ((/^uuid:/i.test(instanceId))) {
-        instanceId = instanceId.substr(5);
-      }
-
-      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {
-        return;
-      } else {
-        return instanceId;
-      }
-    },
-
-    keepAliveInterval: function(keepAliveInterval) {
-      var value;
-      if (SIP.Utils.isDecimal(keepAliveInterval)) {
-        value = Number(keepAliveInterval);
-        if (value > 0) {
-          return value;
-        }
-      }
-    },
-
-    extraSupported: function(optionTags) {
-      var idx, length;
-
-      if (!(optionTags instanceof Array)) {
-        return;
-      }
-
-      length = optionTags.length;
-      for (idx = 0; idx < length; idx++) {
-        if (typeof optionTags[idx] !== 'string') {
-          return;
-        }
-      }
-
-      return optionTags;
-    },
-
-    noAnswerTimeout: function(noAnswerTimeout) {
-      var value;
-      if (SIP.Utils.isDecimal(noAnswerTimeout)) {
-        value = Number(noAnswerTimeout);
-        if (value > 0) {
-          return value;
-        }
-      }
-    },
-
-    password: function(password) {
-      return String(password);
-    },
-
-    rel100: function(rel100) {
-      if(rel100 === SIP.C.supported.REQUIRED) {
-        return SIP.C.supported.REQUIRED;
-      } else if (rel100 === SIP.C.supported.SUPPORTED) {
-        return SIP.C.supported.SUPPORTED;
-      } else  {
-        return SIP.C.supported.UNSUPPORTED;
-      }
-    },
-
-    replaces: function(replaces) {
-      if(replaces === SIP.C.supported.REQUIRED) {
-        return SIP.C.supported.REQUIRED;
-      } else if (replaces === SIP.C.supported.SUPPORTED) {
-        return SIP.C.supported.SUPPORTED;
-      } else  {
-        return SIP.C.supported.UNSUPPORTED;
-      }
-    },
-
-    register: function(register) {
-      if (typeof register === 'boolean') {
-        return register;
-      }
-    },
-
-    registerExpires: function(registerExpires) {
-      var value;
-      if (SIP.Utils.isDecimal(registerExpires)) {
-        value = Number(registerExpires);
-        if (value > 0) {
-          return value;
-        }
-      }
-    },
-
-    registrarServer: function(registrarServer) {
-      var parsed;
-
-      if(typeof registrarServer !== 'string') {
-        return;
-      }
-
-      if (!/^sip:/i.test(registrarServer)) {
-        registrarServer = SIP.C.SIP + ':' + registrarServer;
-      }
-      parsed = SIP.URI.parse(registrarServer);
-
-      if(!parsed) {
-        return;
-      } else if(parsed.user) {
-        return;
-      } else {
-        return parsed;
-      }
-    },
-
-    stunServers: function(stunServers) {
-      var idx, length, stun_server;
-
-      if (typeof stunServers === 'string') {
-        stunServers = [stunServers];
-      } else if (!(stunServers instanceof Array)) {
-        return;
-      }
-
-      length = stunServers.length;
-      for (idx = 0; idx < length; idx++) {
-        stun_server = stunServers[idx];
-        if (!(/^stuns?:/.test(stun_server))) {
-          stun_server = 'stun:' + stun_server;
-        }
-
-        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {
-          return;
-        } else {
-          stunServers[idx] = stun_server;
-        }
-      }
-      return stunServers;
-    },
-
-    traceSip: function(traceSip) {
-      if (typeof traceSip === 'boolean') {
-        return traceSip;
-      }
-    },
-
-    turnServers: function(turnServers) {
-      var idx, jdx, length, turn_server, num_turn_server_urls, url;
-
-      if (turnServers instanceof Array) {
-        // Do nothing
-      } else {
-        turnServers = [turnServers];
-      }
-
-      length = turnServers.length;
-      for (idx = 0; idx < length; idx++) {
-        turn_server = turnServers[idx];
-        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.
-        if (turn_server.server) {
-          turn_server.urls = [turn_server.server];
-        }
-
-        if (!turn_server.urls || !turn_server.username || !turn_server.password) {
-          return;
-        }
-
-        if (turn_server.urls instanceof Array) {
-          num_turn_server_urls = turn_server.urls.length;
-        } else {
-          turn_server.urls = [turn_server.urls];
-          num_turn_server_urls = 1;
-        }
-
-        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {
-          url = turn_server.urls[jdx];
-
-          if (!(/^turns?:/.test(url))) {
-            url = 'turn:' + url;
-          }
-
-          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {
-            return;
-          }
-        }
-      }
-      return turnServers;
-    },
-
-    userAgentString: function(userAgentString) {
-      if (typeof userAgentString === 'string') {
-        return userAgentString;
-      }
-    },
-
-    usePreloadedRoute: function(usePreloadedRoute) {
-      if (typeof usePreloadedRoute === 'boolean') {
-        return usePreloadedRoute;
-      }
-    },
-
-    wsServerMaxReconnection: function(wsServerMaxReconnection) {
-      var value;
-      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {
-        value = Number(wsServerMaxReconnection);
-        if (value > 0) {
-          return value;
-        }
-      }
-    },
-
-    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {
-      var value;
-      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {
-        value = Number(wsServerReconnectionTimeout);
-        if (value > 0) {
-          return value;
-        }
-      }
-    },
-
-    autostart: function(autostart) {
-      if (typeof autostart === 'boolean') {
-        return autostart;
-      }
-    },
-
-    mediaHandlerFactory: function(mediaHandlerFactory) {
-      if (mediaHandlerFactory instanceof Function) {
-        var promisifiedFactory = function promisifiedFactory () {
-          var mediaHandler = mediaHandlerFactory.apply(this, arguments);
-
-          function patchMethod (methodName) {
-            var method = mediaHandler[methodName];
-            if (method.length > 1) {
-              var callbacksFirst = methodName === 'getDescription';
-              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);
-            }
-          }
-
-          patchMethod('getDescription');
-          patchMethod('setDescription');
-
-          return mediaHandler;
-        };
-
-        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;
-        return promisifiedFactory;
-      }
-    },
-
-    authenticationFactory: checkAuthenticationFactory,
-
-    allowLegacyNotifications: function(allowLegacyNotifications) {
-      if (typeof allowLegacyNotifications === 'boolean') {
-        return allowLegacyNotifications;
-      }
-    }
-  }
-};
-
-UA.C = C;
-SIP.UA = UA;
-};
-
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{}],51:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview SIP URI
- */
-
-/**
- * @augments SIP
- * @class Class creating a SIP URI.
- *
- * @param {String} [scheme]
- * @param {String} [user]
- * @param {String} host
- * @param {String} [port]
- * @param {Object} [parameters]
- * @param {Object} [headers]
- *
- */
-module.exports = function (SIP) {
-var URI;
-
-URI = function(scheme, user, host, port, parameters, headers) {
-  var param, header, raw, normal;
-
-  // Checks
-  if(!host) {
-    throw new TypeError('missing or invalid "host" parameter');
-  }
-
-  // Initialize parameters
-  scheme = scheme || SIP.C.SIP;
-  this.parameters = {};
-  this.headers = {};
-
-  for (param in parameters) {
-    this.setParam(param, parameters[param]);
-  }
-
-  for (header in headers) {
-    this.setHeader(header, headers[header]);
-  }
-
-  // Raw URI
-  raw = {
-    scheme: scheme,
-    user: user,
-    host: host,
-    port: port
-  };
-
-  // Normalized URI
-  normal = {
-    scheme: scheme.toLowerCase(),
-    user: user,
-    host: host.toLowerCase(),
-    port: port
-  };
-
-  Object.defineProperties(this, {
-    _normal: {
-      get: function() { return normal; }
-    },
-
-    _raw: {
-      get: function() { return raw; }
-    },
-
-    scheme: {
-      get: function() { return normal.scheme; },
-      set: function(value) {
-        raw.scheme = value;
-        normal.scheme = value.toLowerCase();
-      }
-    },
-
-    user: {
-      get: function() { return normal.user; },
-      set: function(value) {
-        normal.user = raw.user = value;
-      }
-    },
-
-    host: {
-      get: function() { return normal.host; },
-      set: function(value) {
-        raw.host = value;
-        normal.host = value.toLowerCase();
-      }
-    },
-
-    aor: {
-      get: function() { return normal.user + '@' + normal.host; }
-    },
-
-    port: {
-      get: function() { return normal.port; },
-      set: function(value) {
-        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);
-      }
-    }
-  });
-};
-
-URI.prototype = {
-  setParam: function(key, value) {
-    if(key) {
-      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
-    }
-  },
-
-  getParam: function(key) {
-    if(key) {
-      return this.parameters[key.toLowerCase()];
-    }
-  },
-
-  hasParam: function(key) {
-    if(key) {
-      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
-    }
-  },
-
-  deleteParam: function(parameter) {
-    var value;
-    parameter = parameter.toLowerCase();
-    if (this.parameters.hasOwnProperty(parameter)) {
-      value = this.parameters[parameter];
-      delete this.parameters[parameter];
-      return value;
-    }
-  },
-
-  clearParams: function() {
-    this.parameters = {};
-  },
-
-  setHeader: function(name, value) {
-    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
-  },
-
-  getHeader: function(name) {
-    if(name) {
-      return this.headers[SIP.Utils.headerize(name)];
-    }
-  },
-
-  hasHeader: function(name) {
-    if(name) {
-      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;
-    }
-  },
-
-  deleteHeader: function(header) {
-    var value;
-    header = SIP.Utils.headerize(header);
-    if(this.headers.hasOwnProperty(header)) {
-      value = this.headers[header];
-      delete this.headers[header];
-      return value;
-    }
-  },
-
-  clearHeaders: function() {
-    this.headers = {};
-  },
-
-  clone: function() {
-    return new URI(
-      this._raw.scheme,
-      this._raw.user,
-      this._raw.host,
-      this._raw.port,
-      JSON.parse(JSON.stringify(this.parameters)),
-      JSON.parse(JSON.stringify(this.headers)));
-  },
-
-  toRaw: function() {
-    return this._toString(this._raw);
-  },
-
-  toString: function() {
-    return this._toString(this._normal);
-  },
-
-  _toString: function(uri) {
-    var header, parameter, idx, uriString, headers = [];
-
-    uriString  = uri.scheme + ':';
-    // add slashes if it's not a sip(s) URI
-    if (!uri.scheme.toLowerCase().match("^sips?$")) {
-      uriString += "//";
-    }
-    if (uri.user) {
-      uriString += SIP.Utils.escapeUser(uri.user) + '@';
-    }
-    uriString += uri.host;
-    if (uri.port || uri.port === 0) {
-      uriString += ':' + uri.port;
-    }
-
-    for (parameter in this.parameters) {
-      uriString += ';' + parameter;
-
-      if (this.parameters[parameter] !== null) {
-        uriString += '='+ this.parameters[parameter];
-      }
-    }
-
-    for(header in this.headers) {
-      for(idx in this.headers[header]) {
-        headers.push(header + '=' + this.headers[header][idx]);
-      }
-    }
-
-    if (headers.length > 0) {
-      uriString += '?' + headers.join('&');
-    }
-
-    return uriString;
-  }
-};
-
-
-/**
-  * Parse the given string and returns a SIP.URI instance or undefined if
-  * it is an invalid URI.
-  * @public
-  * @param {String} uri
-  */
-URI.parse = function(uri) {
-  uri = SIP.Grammar.parse(uri,'SIP_URI');
-
-  if (uri !== -1) {
-    return uri;
-  } else {
-    return undefined;
-  }
-};
-
-SIP.URI = URI;
-};
-
-},{}],52:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview Utils
- */
-
-module.exports = function (SIP, environment) {
-var Utils;
-
-Utils= {
-
-  Promise: environment.Promise,
-
-  defer: function defer () {
-    var deferred = {};
-    deferred.promise = new Utils.Promise(function (resolve, reject) {
-      deferred.resolve = resolve;
-      deferred.reject = reject;
-    });
-    return deferred;
-  },
-
-  promisify: function promisify (object, methodName, callbacksFirst) {
-    var oldMethod = object[methodName];
-    return function promisifiedMethod (arg, onSuccess, onFailure) {
-      return new Utils.Promise(function (resolve, reject) {
-        var oldArgs = [arg, resolve, reject];
-        if (callbacksFirst) {
-          oldArgs = [resolve, reject, arg];
-        }
-        oldMethod.apply(object, oldArgs);
-      }).then(onSuccess, onFailure);
-    };
-  },
-
-  augment: function (object, constructor, args, override) {
-    var idx, proto;
-
-    // Add public properties from constructor's prototype onto object
-    proto = constructor.prototype;
-    for (idx in proto) {
-      if (override || object[idx] === undefined) {
-        object[idx] = proto[idx];
-      }
-    }
-
-    // Construct the object as though it were just created by constructor
-    constructor.apply(object, args);
-  },
-
-  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {
-    if (isDeprecated && options[loser]) {
-      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');
-    }
-
-    if (options[winner] && options[loser]) {
-      logger.warn(winner + ' overriding ' + loser);
-    }
-
-    options[winner] = options[winner] || options[loser] || defaultValue;
-  },
-
-  str_utf8_length: function(string) {
-    return encodeURIComponent(string).replace(/%[A-F\d]{2}/g, 'U').length;
-  },
-
-  generateFakeSDP: function(body) {
-    if (!body) {
-      return;
-    }
-
-    var start = body.indexOf('o=');
-    var end = body.indexOf('\r\n', start);
-
-    return 'v=0\r\n' + body.slice(start, end) + '\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0';
-  },
-
-  isFunction: function(fn) {
-    if (fn !== undefined) {
-      return Object.prototype.toString.call(fn) === '[object Function]';
-    } else {
-      return false;
-    }
-  },
-
-  isDecimal: function (num) {
-    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));
-  },
-
-  createRandomToken: function(size, base) {
-    var i, r,
-      token = '';
-
-    base = base || 32;
-
-    for( i=0; i < size; i++ ) {
-      r = Math.random() * base|0;
-      token += r.toString(base);
-    }
-
-    return token;
-  },
-
-  newTag: function() {
-    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);
-  },
-
-  // http://stackoverflow.com/users/109538/broofa
-  newUUID: function() {
-    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
-      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
-      return v.toString(16);
-    });
-
-    return UUID;
-  },
-
-  hostType: function(host) {
-    if (!host) {
-      return;
-    } else {
-      host = SIP.Grammar.parse(host,'host');
-      if (host !== -1) {
-        return host.host_type;
-      }
-    }
-  },
-
-  /**
-  * Normalize SIP URI.
-  * NOTE: It does not allow a SIP URI without username.
-  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
-  * Detects the domain part (if given) and properly hex-escapes the user portion.
-  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
-  * @private
-  * @param {String} target
-  * @param {String} [domain]
-  */
-  normalizeTarget: function(target, domain) {
-    var uri, target_array, target_user, target_domain;
-
-    // If no target is given then raise an error.
-    if (!target) {
-      return;
-    // If a SIP.URI instance is given then return it.
-    } else if (target instanceof SIP.URI) {
-      return target;
-
-    // If a string is given split it by '@':
-    // - Last fragment is the desired domain.
-    // - Otherwise append the given domain argument.
-    } else if (typeof target === 'string') {
-      target_array = target.split('@');
-
-      switch(target_array.length) {
-        case 1:
-          if (!domain) {
-            return;
-          }
-          target_user = target;
-          target_domain = domain;
-          break;
-        case 2:
-          target_user = target_array[0];
-          target_domain = target_array[1];
-          break;
-        default:
-          target_user = target_array.slice(0, target_array.length-1).join('@');
-          target_domain = target_array[target_array.length-1];
-      }
-
-      // Remove the URI scheme (if present).
-      target_user = target_user.replace(/^(sips?|tel):/i, '');
-
-      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
-      if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
-        target_user = target_user.replace(/[\-\.\(\)]/g, '');
-      }
-
-      // Build the complete SIP URI.
-      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;
-
-      // Finally parse the resulting URI.
-      if (uri = SIP.URI.parse(target)) {
-        return uri;
-      } else {
-        return;
-      }
-    } else {
-      return;
-    }
-  },
-
-  /**
-  * Hex-escape a SIP URI user.
-  * @private
-  * @param {String} user
-  */
-  escapeUser: function(user) {
-    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
-    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
-  },
-
-  headerize: function(string) {
-    var exceptions = {
-      'Call-Id': 'Call-ID',
-      'Cseq': 'CSeq',
-      'Min-Se': 'Min-SE',
-      'Rack': 'RAck',
-      'Rseq': 'RSeq',
-      'Www-Authenticate': 'WWW-Authenticate'
-      },
-      name = string.toLowerCase().replace(/_/g,'-').split('-'),
-      hname = '',
-      parts = name.length, part;
-
-    for (part = 0; part < parts; part++) {
-      if (part !== 0) {
-        hname +='-';
-      }
-      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);
-    }
-    if (exceptions[hname]) {
-      hname = exceptions[hname];
-    }
-    return hname;
-  },
-
-  sipErrorCause: function(status_code) {
-    var cause;
-
-    for (cause in SIP.C.SIP_ERROR_CAUSES) {
-      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
-        return SIP.C.causes[cause];
-      }
-    }
-
-    return SIP.C.causes.SIP_FAILURE_CODE;
-  },
-
-  getReasonPhrase: function getReasonPhrase (code, specific) {
-    return specific || SIP.C.REASON_PHRASE[code] || '';
-  },
-
-  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {
-    reason = SIP.Utils.getReasonPhrase(code, reason);
-    return 'SIP ;cause=' + code + ' ;text="' + reason + '"';
-  },
-
-  getCancelReason: function getCancelReason (code, reason) {
-    if (code && code < 200 || code > 699) {
-      throw new TypeError('Invalid status_code: ' + code);
-    } else if (code) {
-      return SIP.Utils.getReasonHeaderValue(code, reason);
-    }
-  },
-
-  buildStatusLine: function buildStatusLine (code, reason) {
-    code = code || null;
-    reason = reason || null;
-
-    // Validate code and reason values
-    if (!code || (code < 100 || code > 699)) {
-      throw new TypeError('Invalid status_code: '+ code);
-    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
-      throw new TypeError('Invalid reason_phrase: '+ reason);
-    }
-
-    reason = Utils.getReasonPhrase(code, reason);
-
-    return 'SIP/2.0 ' + code + ' ' + reason + '\r\n';
-  },
-
-  /**
-  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
-  * @private
-  */
-  getRandomTestNetIP: function() {
-    function getOctet(from,to) {
-      return Math.floor(Math.random()*(to-from+1)+from);
-    }
-    return '192.0.2.' + getOctet(1, 254);
-  },
-
-  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
-  calculateMD5: function(string) {
-    function RotateLeft(lValue, iShiftBits) {
-      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
-    }
-
-    function AddUnsigned(lX,lY) {
-      var lX4,lY4,lX8,lY8,lResult;
-      lX8 = (lX & 0x80000000);
-      lY8 = (lY & 0x80000000);
-      lX4 = (lX & 0x40000000);
-      lY4 = (lY & 0x40000000);
-      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
-      if (lX4 & lY4) {
-        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
-      }
-      if (lX4 | lY4) {
-        if (lResult & 0x40000000) {
-          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
-        } else {
-          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
-        }
-      } else {
-        return (lResult ^ lX8 ^ lY8);
-      }
-    }
-
-    function F(x,y,z) {
-      return (x & y) | ((~x) & z);
-    }
-
-    function G(x,y,z) {
-      return (x & z) | (y & (~z));
-    }
-
-    function H(x,y,z) {
-      return (x ^ y ^ z);
-    }
-
-    function I(x,y,z) {
-      return (y ^ (x | (~z)));
-    }
-
-    function FF(a,b,c,d,x,s,ac) {
-      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
-      return AddUnsigned(RotateLeft(a, s), b);
-    }
-
-    function GG(a,b,c,d,x,s,ac) {
-      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
-      return AddUnsigned(RotateLeft(a, s), b);
-    }
-
-    function HH(a,b,c,d,x,s,ac) {
-      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
-      return AddUnsigned(RotateLeft(a, s), b);
-    }
-
-    function II(a,b,c,d,x,s,ac) {
-      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
-      return AddUnsigned(RotateLeft(a, s), b);
-    }
-
-    function ConvertToWordArray(string) {
-      var lWordCount;
-      var lMessageLength = string.length;
-      var lNumberOfWords_temp1=lMessageLength + 8;
-      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
-      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
-      var lWordArray=Array(lNumberOfWords-1);
-      var lBytePosition = 0;
-      var lByteCount = 0;
-      while ( lByteCount < lMessageLength ) {
-        lWordCount = (lByteCount-(lByteCount % 4))/4;
-        lBytePosition = (lByteCount % 4)*8;
-        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
-        lByteCount++;
-      }
-      lWordCount = (lByteCount-(lByteCount % 4))/4;
-      lBytePosition = (lByteCount % 4)*8;
-      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
-      lWordArray[lNumberOfWords-2] = lMessageLength<<3;
-      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
-      return lWordArray;
-    }
-
-    function WordToHex(lValue) {
-      var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
-      for (lCount = 0;lCount<=3;lCount++) {
-        lByte = (lValue>>>(lCount*8)) & 255;
-        WordToHexValue_temp = "0" + lByte.toString(16);
-        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
-      }
-      return WordToHexValue;
-    }
-
-    function Utf8Encode(string) {
-      string = string.replace(/\r\n/g,"\n");
-      var utftext = "";
-
-      for (var n = 0; n < string.length; n++) {
-        var c = string.charCodeAt(n);
-
-        if (c < 128) {
-          utftext += String.fromCharCode(c);
-        }
-        else if((c > 127) && (c < 2048)) {
-          utftext += String.fromCharCode((c >> 6) | 192);
-          utftext += String.fromCharCode((c & 63) | 128);
-        }
-        else {
-          utftext += String.fromCharCode((c >> 12) | 224);
-          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
-          utftext += String.fromCharCode((c & 63) | 128);
-        }
-      }
-      return utftext;
-    }
-
-    var x=[];
-    var k,AA,BB,CC,DD,a,b,c,d;
-    var S11=7, S12=12, S13=17, S14=22;
-    var S21=5, S22=9 , S23=14, S24=20;
-    var S31=4, S32=11, S33=16, S34=23;
-    var S41=6, S42=10, S43=15, S44=21;
-
-    string = Utf8Encode(string);
-
-    x = ConvertToWordArray(string);
-
-    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
-
-    for (k=0;k<x.length;k+=16) {
-      AA=a; BB=b; CC=c; DD=d;
-      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
-      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
-      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
-      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
-      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
-      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
-      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
-      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
-      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
-      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
-      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
-      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
-      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
-      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
-      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
-      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
-      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
-      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
-      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
-      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
-      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
-      d=GG(d,a,b,c,x[k+10],S22,0x2441453);
-      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
-      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
-      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
-      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
-      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
-      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
-      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
-      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
-      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
-      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
-      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
-      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
-      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
-      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
-      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
-      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
-      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
-      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
-      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
-      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
-      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
-      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
-      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
-      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
-      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
-      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
-      a=II(a,b,c,d,x[k+0], S41,0xF4292244);
-      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
-      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
-      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
-      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
-      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
-      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
-      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
-      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
-      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
-      c=II(c,d,a,b,x[k+6], S43,0xA3014314);
-      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
-      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
-      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
-      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
-      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
-      a=AddUnsigned(a,AA);
-      b=AddUnsigned(b,BB);
-      c=AddUnsigned(c,CC);
-      d=AddUnsigned(d,DD);
-    }
-
-    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);
-
-    return temp.toLowerCase();
-  }
-};
-
-SIP.Utils = Utils;
-};
-
-},{}],53:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview WebRTC
- */
-
-module.exports = function (SIP, environment) {
-var WebRTC;
-
-WebRTC = {};
-
-WebRTC.MediaHandler = require('./WebRTC/MediaHandler')(SIP);
-WebRTC.MediaStreamManager = require('./WebRTC/MediaStreamManager')(SIP, environment);
-
-var _isSupported;
-
-WebRTC.isSupported = function () {
-  if (_isSupported !== undefined) {
-    return _isSupported;
-  }
-
-  WebRTC.MediaStream = environment.MediaStream;
-  WebRTC.getUserMedia = environment.getUserMedia;
-  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;
-  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;
-
-  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
-    if (WebRTC.getUserMedia) {
-      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');
-    }
-    _isSupported = true;
-  }
-  else {
-    _isSupported = false;
-  }
-  return _isSupported;
-};
-
-return WebRTC;
-};
-
-},{"./WebRTC/MediaHandler":54,"./WebRTC/MediaStreamManager":55}],54:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview MediaHandler
- */
-
-/* MediaHandler
- * @class PeerConnection helper Class.
- * @param {SIP.Session} session
- * @param {Object} [options]
- * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]
- *        The MediaStreamManager to acquire/release streams from/to.
- *        If not provided, a default MediaStreamManager will be used.
- */
-module.exports = function (SIP) {
-
-var MediaHandler = function(session, options) {
-  options = options || {};
-
-  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);
-  this.session = session;
-  this.localMedia = null;
-  this.ready = true;
-  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);
-  this.audioMuted = false;
-  this.videoMuted = false;
-  this.local_hold = false;
-  this.remote_hold = false;
-
-  // old init() from here on
-  var servers = this.prepareIceServers(options.stunServers, options.turnServers);
-  this.RTCConstraints = options.RTCConstraints || {};
-
-  this.initPeerConnection(servers);
-
-  function selfEmit(mh, event) {
-    if (mh.mediaStreamManager.on) {
-      mh.mediaStreamManager.on(event, function () {
-        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));
-      });
-    }
-  }
-
-  selfEmit(this, 'userMediaRequest');
-  selfEmit(this, 'userMedia');
-  selfEmit(this, 'userMediaFailed');
-};
-
-MediaHandler.defaultFactory = function defaultFactory (session, options) {
-  return new MediaHandler(session, options);
-};
-MediaHandler.defaultFactory.isSupported = function () {
-  return SIP.WebRTC.isSupported();
-};
-
-MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {
-// Functions the session can use
-  isReady: {writable: true, value: function isReady () {
-    return this.ready;
-  }},
-
-  close: {writable: true, value: function close () {
-    this.logger.log('closing PeerConnection');
-    this._remoteStreams = [];
-    // have to check signalingState since this.close() gets called multiple times
-    // TODO figure out why that happens
-    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {
-      this.peerConnection.close();
-
-      if(this.localMedia) {
-        this.mediaStreamManager.release(this.localMedia);
-      }
-    }
-  }},
-
-  /**
-   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]
-   *        the MediaStream (or the constraints describing it) to be used for the session
-   */
-  getDescription: {writable: true, value: function getDescription (mediaHint) {
-    var self = this;
-    var acquire = self.mediaStreamManager.acquire;
-    if (acquire.length > 1) {
-      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);
-    }
-    mediaHint = mediaHint || {};
-    if (mediaHint.dataChannel === true) {
-      mediaHint.dataChannel = {};
-    }
-    this.mediaHint = mediaHint;
-
-    /*
-     * 1. acquire streams (skip if MediaStreams passed in)
-     * 2. addStreams
-     * 3. createOffer/createAnswer
-     */
-
-    var streamPromise;
-    if (self.localMedia) {
-      self.logger.log('already have local media');
-      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);
-    }
-    else {
-      self.logger.log('acquiring local media');
-      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)
-        .then(function acquireSucceeded(streams) {
-          self.logger.log('acquired local media streams');
-          self.localMedia = streams;
-          self.session.connecting();
-          return streams;
-        }, function acquireFailed(err) {
-          self.logger.error('unable to acquire streams');
-          self.logger.error(err);
-          self.session.connecting();
-          throw err;
-        })
-        .then(this.addStreams.bind(this))
-      ;
-    }
-
-    return streamPromise
-      .then(function streamAdditionSucceeded() {
-        if (self.hasOffer('remote')) {
-          self.peerConnection.ondatachannel = function (evt) {
-            self.dataChannel = evt.channel;
-            self.emit('dataChannel', self.dataChannel);
-          };
-        } else if (mediaHint.dataChannel &&
-                   self.peerConnection.createDataChannel) {
-          self.dataChannel = self.peerConnection.createDataChannel(
-            'sipjs',
-            mediaHint.dataChannel
-          );
-          self.emit('dataChannel', self.dataChannel);
-        }
-
-        self.render();
-        return self.createOfferOrAnswer(self.RTCConstraints);
-      })
-      .then(function(sdp) {
-        sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);
-
-        if (self.local_hold) {
-          // Don't receive media
-          // TODO - This will break for media streams with different directions.
-          if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(sdp)) {
-            sdp = sdp.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
-          } else {
-            sdp = sdp.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
-            sdp = sdp.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
-          }
-        }
-
-        return {
-          body: sdp,
-          contentType: 'application/sdp'
-        };
-      })
-    ;
-  }},
-
-  /**
-   * Check if a SIP message contains a session description.
-   * @param {SIP.SIPMessage} message
-   * @returns {boolean}
-   */
-  hasDescription: {writeable: true, value: function hasDescription (message) {
-    return message.getHeader('Content-Type') === 'application/sdp' && !!message.body;
-  }},
-
-  /**
-   * Set the session description contained in a SIP message.
-   * @param {SIP.SIPMessage} message
-   * @returns {Promise}
-   */
-  setDescription: {writable: true, value: function setDescription (message) {
-    var sdp = message.body;
-
-    this.remote_hold = /a=(sendonly|inactive)/.test(sdp);
-
-    sdp = SIP.Hacks.Firefox.cannotHandleExtraWhitespace(sdp);
-    sdp = SIP.Hacks.AllBrowsers.maskDtls(sdp);
-
-    var rawDescription = {
-      type: this.hasOffer('local') ? 'answer' : 'offer',
-      sdp: sdp
-    };
-
-    this.emit('setDescription', rawDescription);
-
-    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);
-    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);
-  }},
-
-  /**
-   * If the Session associated with this MediaHandler were to be referred,
-   * what mediaHint should be provided to the UA's invite method?
-   */
-  getReferMedia: {writable: true, value: function getReferMedia () {
-    function hasTracks (trackGetter, stream) {
-      return stream[trackGetter]().length > 0;
-    }
-
-    function bothHaveTracks (trackGetter) {
-      /* jshint validthis:true */
-      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&
-             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));
-    }
-
-    return {
-      constraints: {
-        audio: bothHaveTracks.call(this, 'getAudioTracks'),
-        video: bothHaveTracks.call(this, 'getVideoTracks')
-      }
-    };
-  }},
-
-  updateIceServers: {writeable:true, value: function (options) {
-    var servers = this.prepareIceServers(options.stunServers, options.turnServers);
-    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;
-
-    this.initPeerConnection(servers);
-
-    /* once updateIce is implemented correctly, this is better than above
-    //no op if browser does not support this
-    if (!this.peerConnection.updateIce) {
-      return;
-    }
-
-    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);
-    */
-  }},
-
-// Functions the session can use, but only because it's convenient for the application
-  isMuted: {writable: true, value: function isMuted () {
-    return {
-      audio: this.audioMuted,
-      video: this.videoMuted
-    };
-  }},
-
-  mute: {writable: true, value: function mute (options) {
-    if (this.getLocalStreams().length === 0) {
-      return;
-    }
-
-    options = options || {
-      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
-      video: this.getLocalStreams()[0].getVideoTracks().length > 0
-    };
-
-    var audioMuted = false,
-        videoMuted = false;
-
-    if (options.audio && !this.audioMuted) {
-      audioMuted = true;
-      this.audioMuted = true;
-      this.toggleMuteAudio(true);
-    }
-
-    if (options.video && !this.videoMuted) {
-      videoMuted = true;
-      this.videoMuted = true;
-      this.toggleMuteVideo(true);
-    }
-
-    //REVISIT
-    if (audioMuted || videoMuted) {
-      return {
-        audio: audioMuted,
-        video: videoMuted
-      };
-      /*this.session.onmute({
-        audio: audioMuted,
-        video: videoMuted
-      });*/
-    }
-  }},
-
-  unmute: {writable: true, value: function unmute (options) {
-    if (this.getLocalStreams().length === 0) {
-      return;
-    }
-
-    options = options || {
-      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
-      video: this.getLocalStreams()[0].getVideoTracks().length > 0
-    };
-
-    var audioUnMuted = false,
-        videoUnMuted = false;
-
-    if (options.audio && this.audioMuted) {
-      audioUnMuted = true;
-      this.audioMuted = false;
-      this.toggleMuteAudio(false);
-    }
-
-    if (options.video && this.videoMuted) {
-      videoUnMuted = true;
-      this.videoMuted = false;
-      this.toggleMuteVideo(false);
-    }
-
-    //REVISIT
-    if (audioUnMuted || videoUnMuted) {
-      return {
-        audio: audioUnMuted,
-        video: videoUnMuted
-      };
-      /*this.session.onunmute({
-        audio: audioUnMuted,
-        video: videoUnMuted
-      });*/
-    }
-  }},
-
-  hold: {writable: true, value: function hold () {
-    this.local_hold = true;
-    this.toggleMuteAudio(true);
-    this.toggleMuteVideo(true);
-  }},
-
-  unhold: {writable: true, value: function unhold () {
-    this.local_hold = false;
-
-    if (!this.audioMuted) {
-      this.toggleMuteAudio(false);
-    }
-
-    if (!this.videoMuted) {
-      this.toggleMuteVideo(false);
-    }
-  }},
-
-// Functions the application can use, but not the session
-  getLocalStreams: {writable: true, value: function getLocalStreams () {
-    var pc = this.peerConnection;
-    if (pc && pc.signalingState === 'closed') {
-      this.logger.warn('peerConnection is closed, getLocalStreams returning []');
-      return [];
-    }
-    return (pc.getLocalStreams && pc.getLocalStreams()) ||
-      pc.localStreams || [];
-  }},
-
-  getRemoteStreams: {writable: true, value: function getRemoteStreams () {
-    var pc = this.peerConnection;
-    if (pc && pc.signalingState === 'closed') {
-      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');
-      return this._remoteStreams;
-    }
-    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||
-      pc.remoteStreams || [];
-  }},
-
-  render: {writable: true, value: function render (renderHint) {
-    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);
-    if (!renderHint) {
-      return false;
-    }
-    var streamGetters = {
-      local: 'getLocalStreams',
-      remote: 'getRemoteStreams'
-    };
-    Object.keys(streamGetters).forEach(function (loc) {
-      var streamGetter = streamGetters[loc];
-      var streams = this[streamGetter]();
-      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);
-    }.bind(this));
-  }},
-
-// Internal functions
-  hasOffer: {writable: true, value: function hasOffer (where) {
-    var offerState = 'have-' + where + '-offer';
-    return this.peerConnection.signalingState === offerState;
-    // TODO consider signalingStates with 'pranswer'?
-  }},
-
-  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {
-    var servers = [],
-      config = this.session.ua.configuration;
-
-    stunServers = stunServers || config.stunServers;
-    turnServers = turnServers || config.turnServers;
-
-    [].concat(stunServers).forEach(function (server) {
-      servers.push({'urls': server});
-    });
-
-    [].concat(turnServers).forEach(function (server) {
-      servers.push({
-        'urls': server.urls,
-        'username': server.username,
-        'credential': server.password
-      });
-    });
-
-    return servers;
-  }},
-
-  initPeerConnection: {writable: true, value: function initPeerConnection(servers) {
-    var self = this,
-      config = this.session.ua.configuration;
-
-    this.onIceCompleted = SIP.Utils.defer();
-    this.onIceCompleted.promise.then(function(pc) {
-      self.emit('iceGatheringComplete', pc);
-      if (self.iceCheckingTimer) {
-        SIP.Timers.clearTimeout(self.iceCheckingTimer);
-        self.iceCheckingTimer = null;
-      }
-    });
-
-    if (this.peerConnection) {
-      this.peerConnection.close();
-    }
-
-    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers});
-
-    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams
-    // even if peerConnection.onaddstream was just called. In order to make
-    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually
-    this._remoteStreams = [];
-
-    this.peerConnection.onaddstream = function(e) {
-      self.logger.log('stream added: '+ e.stream.id);
-      self._remoteStreams.push(e.stream);
-      self.render();
-      self.emit('addStream', e);
-    };
-
-    this.peerConnection.onremovestream = function(e) {
-      self.logger.log('stream removed: '+ e.stream.id);
-    };
-
-    this.startIceCheckingTimer = function () {
-      if (!self.iceCheckingTimer) {
-        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {
-          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');
-          self.onIceCompleted.resolve(this);
-        }.bind(this.peerConnection), config.iceCheckingTimeout);
-      }
-    };
-
-    this.peerConnection.onicecandidate = function(e) {
-      self.emit('iceCandidate', e);
-      if (e.candidate) {
-        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
-        self.startIceCheckingTimer();
-      } else {
-        self.onIceCompleted.resolve(this);
-      }
-    };
-
-    this.peerConnection.onicegatheringstatechange = function () {
-      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
-      if (this.iceGatheringState === 'gathering') {
-        self.emit('iceGathering', this);
-      }
-      if (this.iceGatheringState === 'complete') {
-        self.onIceCompleted.resolve(this);
-      }
-    };
-
-    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case
-      var stateEvent;
-
-      if (this.iceConnectionState === 'checking') {
-        self.startIceCheckingTimer();
-      }
-
-      switch (this.iceConnectionState) {
-      case 'new':
-        stateEvent = 'iceConnection';
-        break;
-      case 'checking':
-        stateEvent = 'iceConnectionChecking';
-        break;
-      case 'connected':
-        stateEvent = 'iceConnectionConnected';
-        break;
-      case 'completed':
-        stateEvent = 'iceConnectionCompleted';
-        break;
-      case 'failed':
-        stateEvent = 'iceConnectionFailed';
-        break;
-      case 'disconnected':
-        stateEvent = 'iceConnectionDisconnected';
-        break;
-      case 'closed':
-        stateEvent = 'iceConnectionClosed';
-        break;
-      default:
-        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
-        return;
-      }
-      self.emit(stateEvent, this);
-
-      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated
-      //normal calls switch from failed to connected in some cases, so checking for failed and terminated
-      /*if (this.iceConnectionState === 'failed') {
-        self.session.terminate({
-        cause: SIP.C.causes.RTP_TIMEOUT,
-        status_code: 200,
-        reason_phrase: SIP.C.causes.RTP_TIMEOUT
-      });
-      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {
-      self.onIceCompleted(this);
-      }*/
-    };
-
-    this.peerConnection.onstatechange = function() {
-      self.logger.log('PeerConnection state changed to "'+ this.readyState +'"');
-    };
-  }},
-
-  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {
-    var self = this;
-    var methodName;
-    var pc = self.peerConnection;
-
-    self.ready = false;
-    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';
-
-    return SIP.Utils.promisify(pc, methodName, true)(constraints)
-      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))
-      .then(function onSetLocalDescriptionSuccess() {
-        var deferred = SIP.Utils.defer();
-        if (pc.iceConnectionState === 'complete' || pc.iceConnectionState === 'completed') {
-          deferred.resolve();
-        } else {
-          self.onIceCompleted.promise.then(deferred.resolve);
-        }
-        return deferred.promise;
-      })
-      .then(function readySuccess () {
-        var sdp = pc.localDescription.sdp;
-
-        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);
-        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);
-
-        var sdpWrapper = {
-          type: methodName === 'createOffer' ? 'offer' : 'answer',
-          sdp: sdp
-        };
-
-        self.emit('getDescription', sdpWrapper);
-
-        if (self.session.ua.configuration.hackStripTcp) {
-          sdpWrapper.sdp = sdpWrapper.sdp.replace(/^a=candidate:\d+ \d+ tcp .*?\r\n/img, "");
-        }
-
-        self.ready = true;
-        return sdpWrapper.sdp;
-      })
-      .catch(function methodFailed (e) {
-        self.logger.error(e);
-        self.ready = true;
-        throw new SIP.Exceptions.GetDescriptionError(e);
-      })
-    ;
-  }},
-
-  addStreams: {writable: true, value: function addStreams (streams) {
-    try {
-      streams = [].concat(streams);
-      streams.forEach(function (stream) {
-        this.peerConnection.addStream(stream);
-      }, this);
-    } catch(e) {
-      this.logger.error('error adding stream');
-      this.logger.error(e);
-      return SIP.Utils.Promise.reject(e);
-    }
-
-    return SIP.Utils.Promise.resolve();
-  }},
-
-  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {
-    this.getLocalStreams().forEach(function (stream) {
-      stream[trackGetter]().forEach(function (track) {
-        track.enabled = !mute;
-      });
-    });
-  }},
-
-  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {
-    this.toggleMuteHelper('getAudioTracks', mute);
-  }},
-
-  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {
-    this.toggleMuteHelper('getVideoTracks', mute);
-  }}
-});
-
-// Return since it will be assigned to a variable.
-return MediaHandler;
-};
-
-},{}],55:[function(require,module,exports){
-"use strict";
-/**
- * @fileoverview MediaStreamManager
- */
-
-/* MediaStreamManager
- * @class Manages the acquisition and release of MediaStreams.
- * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()
- */
-module.exports = function (SIP, environment) {
-
-// Default MediaStreamManager provides single-use streams created with getUserMedia
-var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {
-  if (!SIP.WebRTC.isSupported()) {
-    throw new SIP.Exceptions.NotSupportedError('Media not supported');
-  }
-
-  this.mediaHint = defaultMediaHint || {
-    constraints: {audio: true, video: true}
-  };
-
-  // map of streams to acquisition manner:
-  // true -> passed in as mediaHint.stream
-  // false -> getUserMedia
-  this.acquisitions = {};
-};
-MediaStreamManager.streamId = function (stream) {
-  return stream.getAudioTracks().concat(stream.getVideoTracks())
-    .map(function trackId (track) {
-      return track.id;
-    })
-    .join('');
-};
-
-/**
- * @param {(Array of) MediaStream} streams - The streams to render
- *
- * @param {(Array of) HTMLMediaElement} elements
- *        - The <audio>/<video> element(s) that should render the streams
- *
- * Each stream in streams renders to the corresponding element in elements,
- * wrapping around elements if needed.
- */
-MediaStreamManager.render = function render (streams, elements) {
-  if (!elements) {
-    return false;
-  }
-  if (Array.isArray(elements) && !elements.length) {
-    throw new TypeError('elements must not be empty');
-  }
-
-  function attachMediaStream(element, stream) {
-    element.srcObject = stream;
-  }
-
-  function ensureMediaPlaying (mediaElement) {
-    var interval = 100;
-    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {
-      if (mediaElement.paused && mediaElement.srcObject) {
-        mediaElement.play();
-      }
-      else {
-        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);
-      }
-    }, interval);
-  }
-
-  function attachAndPlay (elements, stream, index) {
-    var element = elements[index % elements.length];
-    if (typeof element === 'function') {
-      element = element();
-    }
-    (environment.attachMediaStream || attachMediaStream)(element, stream);
-    ensureMediaPlaying(element);
-  }
-
-  // [].concat "casts" `elements` into an array
-  // so forEach works even if `elements` was a single element
-  elements = [].concat(elements);
-  [].concat(streams).forEach(attachAndPlay.bind(null, elements));
-};
-
-MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {
-  'acquire': {writable: true, value: function acquire (mediaHint) {
-    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;
-
-    var saveSuccess = function (isHintStream, streams) {
-      streams = [].concat(streams);
-      streams.forEach(function (stream) {
-        var streamId = MediaStreamManager.streamId(stream);
-        this.acquisitions[streamId] = !!isHintStream;
-      }, this);
-      return SIP.Utils.Promise.resolve(streams);
-    }.bind(this);
-
-    if (mediaHint.stream) {
-      return saveSuccess(true, mediaHint.stream);
-    } else {
-      // Fallback to audio/video enabled if no mediaHint can be found.
-      var constraints = mediaHint.constraints ||
-        (this.mediaHint && this.mediaHint.constraints) ||
-        {audio: true, video: true};
-
-      var deferred = SIP.Utils.defer();
-
-      /*
-       * Make the call asynchronous, so that ICCs have a chance
-       * to define callbacks to `userMediaRequest`
-       */
-      SIP.Timers.setTimeout(function () {
-        this.emit('userMediaRequest', constraints);
-
-        var emitThenCall = function (eventName, callback) {
-          var callbackArgs = Array.prototype.slice.call(arguments, 2);
-          // Emit with all of the arguments from the real callback.
-          var newArgs = [eventName].concat(callbackArgs);
-
-          this.emit.apply(this, newArgs);
-
-          return callback.apply(null, callbackArgs);
-        }.bind(this);
-
-        if (constraints.audio || constraints.video) {
-          deferred.resolve(
-            SIP.WebRTC.getUserMedia(constraints)
-            .then(
-              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),
-              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})
-            )
-          );
-        } else {
-          // Local streams were explicitly excluded.
-          deferred.resolve([]);
-        }
-      }.bind(this), 0);
-
-      return deferred.promise;
-    }
-  }},
-
-  'release': {writable: true, value: function release (streams) {
-    streams = [].concat(streams);
-    streams.forEach(function (stream) {
-      var streamId = MediaStreamManager.streamId(stream);
-      if (this.acquisitions[streamId] === false) {
-        stream.getTracks().forEach(function (track) {
-          track.stop();
-        });
-      }
-      delete this.acquisitions[streamId];
-    }, this);
-  }},
-});
-
-// Return since it will be assigned to a variable.
-return MediaStreamManager;
-};
-
-},{}],56:[function(require,module,exports){
 'use strict';
 
 var flatMap = require('./util').flatMap;
@@ -14959,7 +3391,7 @@
 
 module.exports = getStats;
 
-},{"./util":71,"./util/sdp":73}],57:[function(require,module,exports){
+},{"./util":37,"./util/sdp":39}],23:[function(require,module,exports){
 'use strict';
 
 /**
@@ -14996,7 +3428,7 @@
 
 module.exports = getUserMedia;
 
-},{}],58:[function(require,module,exports){
+},{}],24:[function(require,module,exports){
 'use strict';
 
 var WebRTC = {};
@@ -15038,7 +3470,7 @@
 
 module.exports = WebRTC;
 
-},{"../package.json":74,"./getstats":56,"./getusermedia":57,"./mediastream":59,"./mediastreamtrack":60,"./rtcicecandidate":61,"./rtcpeerconnection":64,"./rtcsessiondescription":69}],59:[function(require,module,exports){
+},{"../package.json":40,"./getstats":22,"./getusermedia":23,"./mediastream":25,"./mediastreamtrack":26,"./rtcicecandidate":27,"./rtcpeerconnection":30,"./rtcsessiondescription":35}],25:[function(require,module,exports){
 /* globals MediaStream */
 'use strict';
 
@@ -15050,7 +3482,7 @@
   };
 }
 
-},{}],60:[function(require,module,exports){
+},{}],26:[function(require,module,exports){
 /* global MediaStreamTrack */
 'use strict';
 
@@ -15062,7 +3494,7 @@
   };
 }
 
-},{}],61:[function(require,module,exports){
+},{}],27:[function(require,module,exports){
 /* global mozRTCIceCandidate, RTCIceCandidate */
 'use strict';
 
@@ -15076,7 +3508,7 @@
   };
 }
 
-},{}],62:[function(require,module,exports){
+},{}],28:[function(require,module,exports){
 /* globals RTCDataChannel, RTCPeerConnection, RTCSessionDescription */
 'use strict';
 
@@ -15552,7 +3984,7 @@
 
 module.exports = ChromeRTCPeerConnection;
 
-},{"../mediastream":59,"../rtcrtpsender":66,"../rtcsessiondescription/chrome":67,"../util":71,"../util/eventtarget":70,"../util/latch":72,"../util/sdp":73,"util":258}],63:[function(require,module,exports){
+},{"../mediastream":25,"../rtcrtpsender":32,"../rtcsessiondescription/chrome":33,"../util":37,"../util/eventtarget":36,"../util/latch":38,"../util/sdp":39,"util":224}],29:[function(require,module,exports){
 /* globals RTCPeerConnection */
 'use strict';
 
@@ -15885,7 +4317,7 @@
 
 module.exports = FirefoxRTCPeerConnection;
 
-},{"../rtcsessiondescription/firefox":68,"../util":71,"../util/eventtarget":70,"../util/sdp":73,"util":258}],64:[function(require,module,exports){
+},{"../rtcsessiondescription/firefox":34,"../util":37,"../util/eventtarget":36,"../util/sdp":39,"util":224}],30:[function(require,module,exports){
 'use strict';
 
 var guessBrowser = require('../util').guessBrowser;
@@ -15907,7 +4339,7 @@
     module.exports = RTCPeerConnection;
 }
 
-},{"../util":71,"./chrome":62,"./firefox":63,"./safari":65}],65:[function(require,module,exports){
+},{"../util":37,"./chrome":28,"./firefox":29,"./safari":31}],31:[function(require,module,exports){
 /* globals RTCPeerConnection, RTCSessionDescription */
 'use strict';
 
@@ -16256,7 +4688,7 @@
 
 module.exports = SafariRTCPeerConnection;
 
-},{"../util":71,"../util/eventtarget":70,"../util/latch":72,"../util/sdp":73,"util":258}],66:[function(require,module,exports){
+},{"../util":37,"../util/eventtarget":36,"../util/latch":38,"../util/sdp":39,"util":224}],32:[function(require,module,exports){
 'use strict';
 
 /**
@@ -16297,7 +4729,7 @@
 
 module.exports = RTCRtpSenderShim;
 
-},{}],67:[function(require,module,exports){
+},{}],33:[function(require,module,exports){
 /* globals RTCSessionDescription */
 'use strict';
 
@@ -16338,7 +4770,7 @@
 
 module.exports = ChromeRTCSessionDescription;
 
-},{}],68:[function(require,module,exports){
+},{}],34:[function(require,module,exports){
 /* globals mozRTCSessionDescription, RTCSessionDescription */
 'use strict';
 
@@ -16346,7 +4778,7 @@
   ? RTCSessionDescription
   : mozRTCSessionDescription;
 
-},{}],69:[function(require,module,exports){
+},{}],35:[function(require,module,exports){
 'use strict';
 
 var guessBrowser = require('../util').guessBrowser;
@@ -16365,7 +4797,7 @@
     module.exports = RTCSessionDescription;
 }
 
-},{"../util":71,"./chrome":67,"./firefox":68}],70:[function(require,module,exports){
+},{"../util":37,"./chrome":33,"./firefox":34}],36:[function(require,module,exports){
 'use strict';
 
 var EventEmitter = require('events').EventEmitter;
@@ -16406,7 +4838,7 @@
 
 module.exports = EventTarget;
 
-},{"events":100}],71:[function(require,module,exports){
+},{"events":67}],37:[function(require,module,exports){
 'use strict';
 
 /**
@@ -16655,7 +5087,7 @@
 exports.makeUUID = makeUUID;
 exports.proxyProperties = proxyProperties;
 
-},{}],72:[function(require,module,exports){
+},{}],38:[function(require,module,exports){
 'use strict';
 
 var defer = require('./').defer;
@@ -16770,7 +5202,7 @@
 
 module.exports = Latch;
 
-},{"./":71}],73:[function(require,module,exports){
+},{"./":37}],39:[function(require,module,exports){
 /* globals RTCPeerConnection, RTCRtpTransceiver */
 
 'use strict';
@@ -17063,55 +5495,42 @@
 exports.updatePlanBTrackIdsToSSRCs = updatePlanBTrackIdsToSSRCs;
 exports.updateUnifiedPlanTrackIdsToSSRCs = updateUnifiedPlanTrackIdsToSSRCs;
 
-},{"./":71}],74:[function(require,module,exports){
+},{"./":37}],40:[function(require,module,exports){
 module.exports={
-  "_args": [
-    [
-      "@twilio/webrtc@4.0.0",
-      "/Users/vsmoliy/Desktop/xys-vsp-be-video"
-    ]
-  ],
-  "_from": "@twilio/webrtc@4.0.0",
-  "_id": "@twilio/webrtc@4.0.0",
-  "_inBundle": false,
-  "_integrity": "sha512-ZKAJ7g2dMhfbfmtSjFI7+u00NG1vbLUYD51vQzLy03MlO1pWM2JCtH8vdu6p6ejyoZBB7AE8dy0d6Oo/agpYsw==",
-  "_location": "/@twilio/webrtc",
-  "_phantomChildren": {},
-  "_requested": {
-    "type": "version",
-    "registry": true,
-    "raw": "@twilio/webrtc@4.0.0",
-    "name": "@twilio/webrtc",
-    "escapedName": "@twilio%2fwebrtc",
-    "scope": "@twilio",
-    "rawSpec": "4.0.0",
-    "saveSpec": null,
-    "fetchSpec": "4.0.0"
+  "name": "@twilio/webrtc",
+  "version": "4.0.0",
+  "description": "WebRTC-related APIs and shims used by twilio-video.js",
+  "scripts": {
+    "build": "npm-run-all clean lint test",
+    "clean": "rimraf coverage",
+    "lint": "eslint ./lib",
+    "test:unit": "istanbul cover node_modules/mocha/bin/_mocha -- ./test/unit/index.js",
+    "test:integration:native": "karma start karma/integration.conf.js",
+    "test:integration:adapter": "karma start karma/integration.adapter.conf.js",
+    "test:integration": "npm-run-all test:integration:*",
+    "test": "npm-run-all test:*"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/twilio/twilio-webrtc.js.git"
   },
-  "_requiredBy": [
-    "/twilio-video"
+  "keywords": [
+    "shim",
+    "twilio",
+    "video",
+    "webrtc"
   ],
-  "_resolved": "https://registry.npmjs.org/@twilio/webrtc/-/webrtc-4.0.0.tgz",
-  "_spec": "4.0.0",
-  "_where": "/Users/vsmoliy/Desktop/xys-vsp-be-video",
-  "author": {
-    "name": "Manjesh Malavalli",
-    "email": "mmalavalli@twilio.com"
-  },
+  "author": "Manjesh Malavalli <mmalavalli@twilio.com>",
+  "contributors": [
+    "Mark Roberts <mroberts@twilio.com>",
+    "Ryan Rowland <rrowland@twilio.com>"
+  ],
+  "license": "BSD-3-Clause",
+  "main": "./lib/index.js",
   "bugs": {
     "url": "https://github.com/twilio/twilio-webrtc.js/issues"
   },
-  "contributors": [
-    {
-      "name": "Mark Roberts",
-      "email": "mroberts@twilio.com"
-    },
-    {
-      "name": "Ryan Rowland",
-      "email": "rrowland@twilio.com"
-    }
-  ],
-  "description": "WebRTC-related APIs and shims used by twilio-video.js",
+  "homepage": "https://github.com/twilio/twilio-webrtc.js#readme",
   "devDependencies": {
     "browserify": "^14.4.0",
     "envify": "^4.1.0",
@@ -17131,35 +5550,10 @@
     "travis-multirunner": "^4.2.3",
     "watchify": "^3.9.0",
     "webrtc-adapter": "^6.4.8"
-  },
-  "homepage": "https://github.com/twilio/twilio-webrtc.js#readme",
-  "keywords": [
-    "shim",
-    "twilio",
-    "video",
-    "webrtc"
-  ],
-  "license": "BSD-3-Clause",
-  "main": "./lib/index.js",
-  "name": "@twilio/webrtc",
-  "repository": {
-    "type": "git",
-    "url": "git+https://github.com/twilio/twilio-webrtc.js.git"
-  },
-  "scripts": {
-    "build": "npm-run-all clean lint test",
-    "clean": "rimraf coverage",
-    "lint": "eslint ./lib",
-    "test": "npm-run-all test:*",
-    "test:integration": "npm-run-all test:integration:*",
-    "test:integration:adapter": "karma start karma/integration.adapter.conf.js",
-    "test:integration:native": "karma start karma/integration.conf.js",
-    "test:unit": "istanbul cover node_modules/mocha/bin/_mocha -- ./test/unit/index.js"
-  },
-  "version": "4.0.0"
+  }
 }
 
-},{}],75:[function(require,module,exports){
+},{}],41:[function(require,module,exports){
 module.exports = after
 
 function after(count, callback, err_cb) {
@@ -17189,7 +5583,7 @@
 
 function noop() {}
 
-},{}],76:[function(require,module,exports){
+},{}],42:[function(require,module,exports){
 /**
  * An abstraction for slicing an arraybuffer even when
  * ArrayBuffer.prototype.slice is not supported
@@ -17220,7 +5614,7 @@
   return result.buffer;
 };
 
-},{}],77:[function(require,module,exports){
+},{}],43:[function(require,module,exports){
 
 /**
  * Expose `Backoff`.
@@ -17307,7 +5701,7 @@
 };
 
 
-},{}],78:[function(require,module,exports){
+},{}],44:[function(require,module,exports){
 /*
  * base64-arraybuffer
  * https://github.com/niklasvh/base64-arraybuffer
@@ -17376,7 +5770,7 @@
   };
 })();
 
-},{}],79:[function(require,module,exports){
+},{}],45:[function(require,module,exports){
 'use strict'
 
 exports.byteLength = byteLength
@@ -17529,7 +5923,7 @@
   return parts.join('')
 }
 
-},{}],80:[function(require,module,exports){
+},{}],46:[function(require,module,exports){
 /**
  * Create a blob builder even when vendor prefixes exist
  */
@@ -17631,9 +6025,10 @@
   }
 })();
 
-},{}],81:[function(require,module,exports){
+},{}],47:[function(require,module,exports){
 
-},{}],82:[function(require,module,exports){
+},{}],48:[function(require,module,exports){
+(function (Buffer){
 /*!
  * The buffer module from node.js, for the browser.
  *
@@ -19412,7 +7807,8 @@
   return obj !== obj // eslint-disable-line no-self-compare
 }
 
-},{"base64-js":79,"ieee754":103}],83:[function(require,module,exports){
+}).call(this,require("buffer").Buffer)
+},{"base64-js":45,"buffer":48,"ieee754":71}],49:[function(require,module,exports){
 /**
  * Slice reference.
  */
@@ -19437,7 +7833,7 @@
   }
 };
 
-},{}],84:[function(require,module,exports){
+},{}],50:[function(require,module,exports){
 
 /**
  * Expose `Emitter`.
@@ -19602,7 +7998,7 @@
   return !! this.listeners(event).length;
 };
 
-},{}],85:[function(require,module,exports){
+},{}],51:[function(require,module,exports){
 
 module.exports = function(a, b){
   var fn = function(){};
@@ -19610,7 +8006,7 @@
   a.prototype = new fn;
   a.prototype.constructor = a;
 };
-},{}],86:[function(require,module,exports){
+},{}],52:[function(require,module,exports){
 
 module.exports = require('./socket');
 
@@ -19622,8 +8018,7 @@
  */
 module.exports.parser = require('engine.io-parser');
 
-},{"./socket":87,"engine.io-parser":97}],87:[function(require,module,exports){
-(function (global){
+},{"./socket":53,"engine.io-parser":64}],53:[function(require,module,exports){
 /**
  * Module dependencies.
  */
@@ -19671,7 +8066,7 @@
   }
 
   this.secure = null != opts.secure ? opts.secure
-    : (global.location && 'https:' === location.protocol);
+    : (typeof location !== 'undefined' && 'https:' === location.protocol);
 
   if (opts.hostname && !opts.port) {
     // if no port is specified manually, use the protocol default
@@ -19680,8 +8075,8 @@
 
   this.agent = opts.agent || false;
   this.hostname = opts.hostname ||
-    (global.location ? location.hostname : 'localhost');
-  this.port = opts.port || (global.location && location.port
+    (typeof location !== 'undefined' ? location.hostname : 'localhost');
+  this.port = opts.port || (typeof location !== 'undefined' && location.port
       ? location.port
       : (this.secure ? 443 : 80));
   this.query = opts.query || {};
@@ -19720,9 +8115,11 @@
   this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
   this.forceNode = !!opts.forceNode;
 
-  // other options for Node.js client
-  var freeGlobal = typeof global === 'object' && global;
-  if (freeGlobal.global === freeGlobal) {
+  // detect ReactNative environment
+  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');
+
+  // other options for Node.js or ReactNative client
+  if (typeof self === 'undefined' || this.isReactNative) {
     if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
       this.extraHeaders = opts.extraHeaders;
     }
@@ -19822,7 +8219,8 @@
     forceNode: options.forceNode || this.forceNode,
     localAddress: options.localAddress || this.localAddress,
     requestTimeout: options.requestTimeout || this.requestTimeout,
-    protocols: options.protocols || void (0)
+    protocols: options.protocols || void (0),
+    isReactNative: this.isReactNative
   });
 
   return transport;
@@ -20368,8 +8766,7 @@
   return filteredUpgrades;
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./transport":88,"./transports/index":89,"component-emitter":84,"debug":95,"engine.io-parser":97,"indexof":104,"parseqs":108,"parseuri":109}],88:[function(require,module,exports){
+},{"./transport":54,"./transports/index":55,"component-emitter":50,"debug":61,"engine.io-parser":64,"indexof":72,"parseqs":73,"parseuri":74}],54:[function(require,module,exports){
 /**
  * Module dependencies.
  */
@@ -20413,6 +8810,9 @@
   this.rejectUnauthorized = opts.rejectUnauthorized;
   this.forceNode = opts.forceNode;
 
+  // results of ReactNative environment detection
+  this.isReactNative = opts.isReactNative;
+
   // other options for Node.js client
   this.extraHeaders = opts.extraHeaders;
   this.localAddress = opts.localAddress;
@@ -20528,8 +8928,7 @@
   this.emit('close');
 };
 
-},{"component-emitter":84,"engine.io-parser":97}],89:[function(require,module,exports){
-(function (global){
+},{"component-emitter":50,"engine.io-parser":64}],55:[function(require,module,exports){
 /**
  * Module dependencies
  */
@@ -20559,7 +8958,7 @@
   var xs = false;
   var jsonp = false !== opts.jsonp;
 
-  if (global.location) {
+  if (typeof location !== 'undefined') {
     var isSSL = 'https:' === location.protocol;
     var port = location.port;
 
@@ -20584,10 +8983,8 @@
   }
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./polling-jsonp":90,"./polling-xhr":91,"./websocket":93,"xmlhttprequest-ssl":94}],90:[function(require,module,exports){
+},{"./polling-jsonp":56,"./polling-xhr":57,"./websocket":59,"xmlhttprequest-ssl":60}],56:[function(require,module,exports){
 (function (global){
-
 /**
  * Module requirements.
  */
@@ -20620,6 +9017,15 @@
 
 function empty () { }
 
+/**
+ * Until https://github.com/tc39/proposal-global is shipped.
+ */
+function glob () {
+  return typeof self !== 'undefined' ? self
+      : typeof window !== 'undefined' ? window
+      : typeof global !== 'undefined' ? global : {};
+}
+
 /**
  * JSONP Polling constructor.
  *
@@ -20636,8 +9042,8 @@
   // we do this here (lazily) to avoid unneeded global pollution
   if (!callbacks) {
     // we need to consider multiple engines in the same page
-    if (!global.___eio) global.___eio = [];
-    callbacks = global.___eio;
+    var global = glob();
+    callbacks = global.___eio = (global.___eio || []);
   }
 
   // callback identifier
@@ -20653,8 +9059,8 @@
   this.query.j = this.index;
 
   // prevent spurious errors from being emitted when the window is unloaded
-  if (global.document && global.addEventListener) {
-    global.addEventListener('beforeunload', function () {
+  if (typeof addEventListener === 'function') {
+    addEventListener('beforeunload', function () {
       if (self.script) self.script.onerror = empty;
     }, false);
   }
@@ -20820,8 +9226,9 @@
 };
 
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./polling":92,"component-inherit":85}],91:[function(require,module,exports){
-(function (global){
+},{"./polling":58,"component-inherit":51}],57:[function(require,module,exports){
+/* global attachEvent */
+
 /**
  * Module requirements.
  */
@@ -20857,7 +9264,7 @@
   this.requestTimeout = opts.requestTimeout;
   this.extraHeaders = opts.extraHeaders;
 
-  if (global.location) {
+  if (typeof location !== 'undefined') {
     var isSSL = 'https:' === location.protocol;
     var port = location.port;
 
@@ -20866,7 +9273,7 @@
       port = isSSL ? 443 : 80;
     }
 
-    this.xd = opts.hostname !== global.location.hostname ||
+    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
       port !== opts.port;
     this.xs = opts.secure !== isSSL;
   }
@@ -21095,7 +9502,7 @@
     return;
   }
 
-  if (global.document) {
+  if (typeof document !== 'undefined') {
     this.index = Request.requestsCount++;
     Request.requests[this.index] = this;
   }
@@ -21157,7 +9564,7 @@
     } catch (e) {}
   }
 
-  if (global.document) {
+  if (typeof document !== 'undefined') {
     delete Request.requests[this.index];
   }
 
@@ -21197,7 +9604,7 @@
  */
 
 Request.prototype.hasXDR = function () {
-  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
+  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
 };
 
 /**
@@ -21219,11 +9626,12 @@
 Request.requestsCount = 0;
 Request.requests = {};
 
-if (global.document) {
-  if (global.attachEvent) {
-    global.attachEvent('onunload', unloadHandler);
-  } else if (global.addEventListener) {
-    global.addEventListener('beforeunload', unloadHandler, false);
+if (typeof document !== 'undefined') {
+  if (typeof attachEvent === 'function') {
+    attachEvent('onunload', unloadHandler);
+  } else if (typeof addEventListener === 'function') {
+    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
+    addEventListener(terminationEvent, unloadHandler, false);
   }
 }
 
@@ -21235,8 +9643,7 @@
   }
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./polling":92,"component-emitter":84,"component-inherit":85,"debug":95,"xmlhttprequest-ssl":94}],92:[function(require,module,exports){
+},{"./polling":58,"component-emitter":50,"component-inherit":51,"debug":61,"xmlhttprequest-ssl":60}],58:[function(require,module,exports){
 /**
  * Module dependencies.
  */
@@ -21483,8 +9890,8 @@
   return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
 };
 
-},{"../transport":88,"component-inherit":85,"debug":95,"engine.io-parser":97,"parseqs":108,"xmlhttprequest-ssl":94,"yeast":259}],93:[function(require,module,exports){
-(function (global){
+},{"../transport":54,"component-inherit":51,"debug":61,"engine.io-parser":64,"parseqs":73,"xmlhttprequest-ssl":60,"yeast":225}],59:[function(require,module,exports){
+(function (Buffer){
 /**
  * Module dependencies.
  */
@@ -21495,9 +9902,14 @@
 var inherit = require('component-inherit');
 var yeast = require('yeast');
 var debug = require('debug')('engine.io-client:websocket');
-var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
-var NodeWebSocket;
-if (typeof window === 'undefined') {
+
+var BrowserWebSocket, NodeWebSocket;
+
+if (typeof WebSocket !== 'undefined') {
+  BrowserWebSocket = WebSocket;
+} else if (typeof self !== 'undefined') {
+  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
+} else {
   try {
     NodeWebSocket = require('ws');
   } catch (e) { }
@@ -21509,10 +9921,7 @@
  * interface exposed by `ws` for Node-like environment.
  */
 
-var WebSocket = BrowserWebSocket;
-if (!WebSocket && typeof window === 'undefined') {
-  WebSocket = NodeWebSocket;
-}
+var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
 
 /**
  * Module exports.
@@ -21536,7 +9945,7 @@
   this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
   this.protocols = opts.protocols;
   if (!this.usingBrowserWebSocket) {
-    WebSocket = NodeWebSocket;
+    WebSocketImpl = NodeWebSocket;
   }
   Transport.call(this, opts);
 }
@@ -21596,7 +10005,12 @@
   }
 
   try {
-    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
+    this.ws =
+      this.usingBrowserWebSocket && !this.isReactNative
+        ? protocols
+          ? new WebSocketImpl(uri, protocols)
+          : new WebSocketImpl(uri)
+        : new WebSocketImpl(uri, protocols, opts);
   } catch (err) {
     return this.emit('error', err);
   }
@@ -21663,7 +10077,7 @@
           }
 
           if (self.perMessageDeflate) {
-            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
+            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
             if (len < self.perMessageDeflate.threshold) {
               opts.compress = false;
             }
@@ -21769,12 +10183,11 @@
  */
 
 WS.prototype.check = function () {
-  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
+  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"../transport":88,"component-inherit":85,"debug":95,"engine.io-parser":97,"parseqs":108,"ws":81,"yeast":259}],94:[function(require,module,exports){
-(function (global){
+}).call(this,require("buffer").Buffer)
+},{"../transport":54,"buffer":48,"component-inherit":51,"debug":61,"engine.io-parser":64,"parseqs":73,"ws":47,"yeast":225}],60:[function(require,module,exports){
 // browser shim for xmlhttprequest module
 
 var hasCORS = require('has-cors');
@@ -21808,13 +10221,12 @@
 
   if (!xdomain) {
     try {
-      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
+      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
     } catch (e) { }
   }
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"has-cors":102}],95:[function(require,module,exports){
+},{"has-cors":70}],61:[function(require,module,exports){
 (function (process){
 /**
  * This is the web browser implementation of `debug()`.
@@ -22013,7 +10425,7 @@
 }
 
 }).call(this,require('_process'))
-},{"./debug":96,"_process":110}],96:[function(require,module,exports){
+},{"./debug":62,"_process":75}],62:[function(require,module,exports){
 
 /**
  * This is the common logic for both the Node.js and web browser
@@ -22240,7 +10652,161 @@
   return val;
 }
 
-},{"ms":107}],97:[function(require,module,exports){
+},{"ms":63}],63:[function(require,module,exports){
+/**
+ * Helpers.
+ */
+
+var s = 1000;
+var m = s * 60;
+var h = m * 60;
+var d = h * 24;
+var y = d * 365.25;
+
+/**
+ * Parse or format the given `val`.
+ *
+ * Options:
+ *
+ *  - `long` verbose formatting [false]
+ *
+ * @param {String|Number} val
+ * @param {Object} [options]
+ * @throws {Error} throw an error if val is not a non-empty string or a number
+ * @return {String|Number}
+ * @api public
+ */
+
+module.exports = function(val, options) {
+  options = options || {};
+  var type = typeof val;
+  if (type === 'string' && val.length > 0) {
+    return parse(val);
+  } else if (type === 'number' && isNaN(val) === false) {
+    return options.long ? fmtLong(val) : fmtShort(val);
+  }
+  throw new Error(
+    'val is not a non-empty string or a valid number. val=' +
+      JSON.stringify(val)
+  );
+};
+
+/**
+ * Parse the given `str` and return milliseconds.
+ *
+ * @param {String} str
+ * @return {Number}
+ * @api private
+ */
+
+function parse(str) {
+  str = String(str);
+  if (str.length > 100) {
+    return;
+  }
+  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
+    str
+  );
+  if (!match) {
+    return;
+  }
+  var n = parseFloat(match[1]);
+  var type = (match[2] || 'ms').toLowerCase();
+  switch (type) {
+    case 'years':
+    case 'year':
+    case 'yrs':
+    case 'yr':
+    case 'y':
+      return n * y;
+    case 'days':
+    case 'day':
+    case 'd':
+      return n * d;
+    case 'hours':
+    case 'hour':
+    case 'hrs':
+    case 'hr':
+    case 'h':
+      return n * h;
+    case 'minutes':
+    case 'minute':
+    case 'mins':
+    case 'min':
+    case 'm':
+      return n * m;
+    case 'seconds':
+    case 'second':
+    case 'secs':
+    case 'sec':
+    case 's':
+      return n * s;
+    case 'milliseconds':
+    case 'millisecond':
+    case 'msecs':
+    case 'msec':
+    case 'ms':
+      return n;
+    default:
+      return undefined;
+  }
+}
+
+/**
+ * Short format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtShort(ms) {
+  if (ms >= d) {
+    return Math.round(ms / d) + 'd';
+  }
+  if (ms >= h) {
+    return Math.round(ms / h) + 'h';
+  }
+  if (ms >= m) {
+    return Math.round(ms / m) + 'm';
+  }
+  if (ms >= s) {
+    return Math.round(ms / s) + 's';
+  }
+  return ms + 'ms';
+}
+
+/**
+ * Long format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtLong(ms) {
+  return plural(ms, d, 'day') ||
+    plural(ms, h, 'hour') ||
+    plural(ms, m, 'minute') ||
+    plural(ms, s, 'second') ||
+    ms + ' ms';
+}
+
+/**
+ * Pluralization helper.
+ */
+
+function plural(ms, n, name) {
+  if (ms < n) {
+    return;
+  }
+  if (ms < n * 1.5) {
+    return Math.floor(ms / n) + ' ' + name;
+  }
+  return Math.ceil(ms / n) + ' ' + name + 's';
+}
+
+},{}],64:[function(require,module,exports){
 /**
  * Module dependencies.
  */
@@ -22847,7 +11413,7 @@
   });
 };
 
-},{"./keys":98,"./utf8":99,"after":75,"arraybuffer.slice":76,"base64-arraybuffer":78,"blob":80,"has-binary2":101}],98:[function(require,module,exports){
+},{"./keys":65,"./utf8":66,"after":41,"arraybuffer.slice":42,"base64-arraybuffer":44,"blob":46,"has-binary2":68}],65:[function(require,module,exports){
 
 /**
  * Gets the keys for an object.
@@ -22868,7 +11434,7 @@
   return arr;
 };
 
-},{}],99:[function(require,module,exports){
+},{}],66:[function(require,module,exports){
 /*! https://mths.be/utf8js v2.1.2 by @mathias */
 
 var stringFromCharCode = String.fromCharCode;
@@ -23080,7 +11646,7 @@
 	decode: utf8decode
 };
 
-},{}],100:[function(require,module,exports){
+},{}],67:[function(require,module,exports){
 // Copyright Joyent, Inc. and other Node contributors.
 //
 // Permission is hereby granted, free of charge, to any person obtaining a
@@ -23605,7 +12171,7 @@
   };
 }
 
-},{}],101:[function(require,module,exports){
+},{}],68:[function(require,module,exports){
 (function (Buffer){
 /* global Blob File */
 
@@ -23673,7 +12239,14 @@
 }
 
 }).call(this,require("buffer").Buffer)
-},{"buffer":82,"isarray":106}],102:[function(require,module,exports){
+},{"buffer":48,"isarray":69}],69:[function(require,module,exports){
+var toString = {}.toString;
+
+module.exports = Array.isArray || function (arr) {
+  return toString.call(arr) == '[object Array]';
+};
+
+},{}],70:[function(require,module,exports){
 
 /**
  * Module exports.
@@ -23692,7 +12265,7 @@
   module.exports = false;
 }
 
-},{}],103:[function(require,module,exports){
+},{}],71:[function(require,module,exports){
 exports.read = function (buffer, offset, isLE, mLen, nBytes) {
   var e, m
   var eLen = (nBytes * 8) - mLen - 1
@@ -23778,7 +12351,7 @@
   buffer[offset + i - d] |= s * 128
 }
 
-},{}],104:[function(require,module,exports){
+},{}],72:[function(require,module,exports){
 
 var indexOf = [].indexOf;
 
@@ -23789,193 +12362,7 @@
   }
   return -1;
 };
-},{}],105:[function(require,module,exports){
-if (typeof Object.create === 'function') {
-  // implementation from standard node.js 'util' module
-  module.exports = function inherits(ctor, superCtor) {
-    ctor.super_ = superCtor
-    ctor.prototype = Object.create(superCtor.prototype, {
-      constructor: {
-        value: ctor,
-        enumerable: false,
-        writable: true,
-        configurable: true
-      }
-    });
-  };
-} else {
-  // old school shim for old browsers
-  module.exports = function inherits(ctor, superCtor) {
-    ctor.super_ = superCtor
-    var TempCtor = function () {}
-    TempCtor.prototype = superCtor.prototype
-    ctor.prototype = new TempCtor()
-    ctor.prototype.constructor = ctor
-  }
-}
-
-},{}],106:[function(require,module,exports){
-var toString = {}.toString;
-
-module.exports = Array.isArray || function (arr) {
-  return toString.call(arr) == '[object Array]';
-};
-
-},{}],107:[function(require,module,exports){
-/**
- * Helpers.
- */
-
-var s = 1000;
-var m = s * 60;
-var h = m * 60;
-var d = h * 24;
-var y = d * 365.25;
-
-/**
- * Parse or format the given `val`.
- *
- * Options:
- *
- *  - `long` verbose formatting [false]
- *
- * @param {String|Number} val
- * @param {Object} [options]
- * @throws {Error} throw an error if val is not a non-empty string or a number
- * @return {String|Number}
- * @api public
- */
-
-module.exports = function(val, options) {
-  options = options || {};
-  var type = typeof val;
-  if (type === 'string' && val.length > 0) {
-    return parse(val);
-  } else if (type === 'number' && isNaN(val) === false) {
-    return options.long ? fmtLong(val) : fmtShort(val);
-  }
-  throw new Error(
-    'val is not a non-empty string or a valid number. val=' +
-      JSON.stringify(val)
-  );
-};
-
-/**
- * Parse the given `str` and return milliseconds.
- *
- * @param {String} str
- * @return {Number}
- * @api private
- */
-
-function parse(str) {
-  str = String(str);
-  if (str.length > 100) {
-    return;
-  }
-  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
-    str
-  );
-  if (!match) {
-    return;
-  }
-  var n = parseFloat(match[1]);
-  var type = (match[2] || 'ms').toLowerCase();
-  switch (type) {
-    case 'years':
-    case 'year':
-    case 'yrs':
-    case 'yr':
-    case 'y':
-      return n * y;
-    case 'days':
-    case 'day':
-    case 'd':
-      return n * d;
-    case 'hours':
-    case 'hour':
-    case 'hrs':
-    case 'hr':
-    case 'h':
-      return n * h;
-    case 'minutes':
-    case 'minute':
-    case 'mins':
-    case 'min':
-    case 'm':
-      return n * m;
-    case 'seconds':
-    case 'second':
-    case 'secs':
-    case 'sec':
-    case 's':
-      return n * s;
-    case 'milliseconds':
-    case 'millisecond':
-    case 'msecs':
-    case 'msec':
-    case 'ms':
-      return n;
-    default:
-      return undefined;
-  }
-}
-
-/**
- * Short format for `ms`.
- *
- * @param {Number} ms
- * @return {String}
- * @api private
- */
-
-function fmtShort(ms) {
-  if (ms >= d) {
-    return Math.round(ms / d) + 'd';
-  }
-  if (ms >= h) {
-    return Math.round(ms / h) + 'h';
-  }
-  if (ms >= m) {
-    return Math.round(ms / m) + 'm';
-  }
-  if (ms >= s) {
-    return Math.round(ms / s) + 's';
-  }
-  return ms + 'ms';
-}
-
-/**
- * Long format for `ms`.
- *
- * @param {Number} ms
- * @return {String}
- * @api private
- */
-
-function fmtLong(ms) {
-  return plural(ms, d, 'day') ||
-    plural(ms, h, 'hour') ||
-    plural(ms, m, 'minute') ||
-    plural(ms, s, 'second') ||
-    ms + ' ms';
-}
-
-/**
- * Pluralization helper.
- */
-
-function plural(ms, n, name) {
-  if (ms < n) {
-    return;
-  }
-  if (ms < n * 1.5) {
-    return Math.floor(ms / n) + ' ' + name;
-  }
-  return Math.ceil(ms / n) + ' ' + name + 's';
-}
-
-},{}],108:[function(require,module,exports){
+},{}],73:[function(require,module,exports){
 /**
  * Compiles a querystring
  * Returns string representation of the object
@@ -24014,7 +12401,7 @@
   return qry;
 };
 
-},{}],109:[function(require,module,exports){
+},{}],74:[function(require,module,exports){
 /**
  * Parses an URI
  *
@@ -24055,7 +12442,7 @@
     return uri;
 };
 
-},{}],110:[function(require,module,exports){
+},{}],75:[function(require,module,exports){
 // shim for using process in browser
 var process = module.exports = {};
 
@@ -24241,7 +12628,7 @@
 };
 process.umask = function() { return 0; };
 
-},{}],111:[function(require,module,exports){
+},{}],76:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -24337,7 +12724,7 @@
 exports.Manager = require('./manager');
 exports.Socket = require('./socket');
 
-},{"./manager":112,"./socket":114,"./url":115,"debug":116,"socket.io-parser":119}],112:[function(require,module,exports){
+},{"./manager":77,"./socket":79,"./url":80,"debug":81,"socket.io-parser":85}],77:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -24912,7 +13299,7 @@
   this.emitAll('reconnect', attempt);
 };
 
-},{"./on":113,"./socket":114,"backo2":77,"component-bind":83,"component-emitter":84,"debug":116,"engine.io-client":86,"indexof":104,"socket.io-parser":119}],113:[function(require,module,exports){
+},{"./on":78,"./socket":79,"backo2":43,"component-bind":49,"component-emitter":50,"debug":81,"engine.io-client":52,"indexof":72,"socket.io-parser":85}],78:[function(require,module,exports){
 
 /**
  * Module exports.
@@ -24938,7 +13325,7 @@
   };
 }
 
-},{}],114:[function(require,module,exports){
+},{}],79:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -25378,8 +13765,7 @@
   return this;
 };
 
-},{"./on":113,"component-bind":83,"component-emitter":84,"debug":116,"has-binary2":101,"parseqs":108,"socket.io-parser":119,"to-array":123}],115:[function(require,module,exports){
-(function (global){
+},{"./on":78,"component-bind":49,"component-emitter":50,"debug":81,"has-binary2":68,"parseqs":73,"socket.io-parser":85,"to-array":91}],80:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -25407,7 +13793,7 @@
   var obj = uri;
 
   // default to window.location
-  loc = loc || global.location;
+  loc = loc || (typeof location !== 'undefined' && location);
   if (null == uri) uri = loc.protocol + '//' + loc.host;
 
   // relative path support
@@ -25456,13 +13842,13 @@
   return obj;
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"debug":116,"parseuri":109}],116:[function(require,module,exports){
-arguments[4][95][0].apply(exports,arguments)
-},{"./debug":117,"_process":110,"dup":95}],117:[function(require,module,exports){
-arguments[4][96][0].apply(exports,arguments)
-},{"dup":96,"ms":107}],118:[function(require,module,exports){
-(function (global){
+},{"debug":81,"parseuri":74}],81:[function(require,module,exports){
+arguments[4][61][0].apply(exports,arguments)
+},{"./debug":82,"_process":75,"dup":61}],82:[function(require,module,exports){
+arguments[4][62][0].apply(exports,arguments)
+},{"dup":62,"ms":83}],83:[function(require,module,exports){
+arguments[4][63][0].apply(exports,arguments)
+},{"dup":63}],84:[function(require,module,exports){
 /*global Blob,File*/
 
 /**
@@ -25472,8 +13858,8 @@
 var isArray = require('isarray');
 var isBuf = require('./is-buffer');
 var toString = Object.prototype.toString;
-var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
-var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';
+var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
+var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');
 
 /**
  * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
@@ -25605,8 +13991,7 @@
   }
 };
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./is-buffer":120,"isarray":106}],119:[function(require,module,exports){
+},{"./is-buffer":86,"isarray":89}],85:[function(require,module,exports){
 
 /**
  * Module dependencies.
@@ -25838,7 +14223,7 @@
 Emitter(Decoder.prototype);
 
 /**
- * Decodes an ecoded packet string into packet JSON.
+ * Decodes an encoded packet string into packet JSON.
  *
  * @param {String} obj - encoded packet
  * @return {Object} packet
@@ -25859,8 +14244,7 @@
     } else { // non-binary full packet
       this.emit('decoded', packet);
     }
-  }
-  else if (isBuf(obj) || obj.base64) { // raw binary data
+  } else if (isBuf(obj) || obj.base64) { // raw binary data
     if (!this.reconstructor) {
       throw new Error('got binary data when not reconstructing a packet');
     } else {
@@ -25870,8 +14254,7 @@
         this.emit('decoded', packet);
       }
     }
-  }
-  else {
+  } else {
     throw new Error('Unknown type: ' + obj);
   }
 };
@@ -26025,21 +14408,17 @@
   };
 }
 
-},{"./binary":118,"./is-buffer":120,"component-emitter":84,"debug":121,"isarray":106}],120:[function(require,module,exports){
-(function (global){
+},{"./binary":84,"./is-buffer":86,"component-emitter":50,"debug":87,"isarray":89}],86:[function(require,module,exports){
+(function (Buffer){
 
 module.exports = isBuf;
 
-var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';
-var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';
+var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
+var withNativeArrayBuffer = typeof ArrayBuffer === 'function';
 
-var isView = (function () {
-  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {
-    return global.ArrayBuffer.isView;
-  } else {
-    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };
-  }
-})();
+var isView = function (obj) {
+  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
+};
 
 /**
  * Returns true if obj is a buffer or an arraybuffer.
@@ -26048,16 +14427,20 @@
  */
 
 function isBuf(obj) {
-  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||
-          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));
+  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
+          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
 }
 
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{}],121:[function(require,module,exports){
-arguments[4][95][0].apply(exports,arguments)
-},{"./debug":122,"_process":110,"dup":95}],122:[function(require,module,exports){
-arguments[4][96][0].apply(exports,arguments)
-},{"dup":96,"ms":107}],123:[function(require,module,exports){
+}).call(this,require("buffer").Buffer)
+},{"buffer":48}],87:[function(require,module,exports){
+arguments[4][61][0].apply(exports,arguments)
+},{"./debug":88,"_process":75,"dup":61}],88:[function(require,module,exports){
+arguments[4][62][0].apply(exports,arguments)
+},{"dup":62,"ms":90}],89:[function(require,module,exports){
+arguments[4][69][0].apply(exports,arguments)
+},{"dup":69}],90:[function(require,module,exports){
+arguments[4][63][0].apply(exports,arguments)
+},{"dup":63}],91:[function(require,module,exports){
 module.exports = toArray
 
 function toArray(list, index) {
@@ -26072,7 +14455,7 @@
     return array
 }
 
-},{}],124:[function(require,module,exports){
+},{}],92:[function(require,module,exports){
 'use strict';
 
 var CancelablePromise = require('./util/cancelablepromise');
@@ -26121,7 +14504,7 @@
 }
 
 module.exports = createCancelableRoomPromise;
-},{"./util/cancelablepromise":233}],125:[function(require,module,exports){
+},{"./util/cancelablepromise":198}],93:[function(require,module,exports){
 'use strict';
 
 var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
@@ -26269,12 +14652,11 @@
     preferredAudioCodecs: [],
     preferredVideoCodecs: [],
     realm: constants.DEFAULT_REALM,
-    signaling: SignalingV2,
-    _useTwilioConnection: false
+    signaling: SignalingV2
   }, util.filterObject(options));
 
   /* eslint new-cap:0 */
-  var wsServer = options._useTwilioConnection ? constants.WS_SERVER_TWILIOCONNECTION(options.environment) : constants.WS_SERVER(options.environment, options.realm);
+  var wsServer = constants.WS_SERVER(options.environment);
 
   options = Object.assign({ wsServer: wsServer }, options);
 
@@ -26619,7 +15001,7 @@
 }
 
 module.exports = connect;
-},{"./cancelableroompromise":124,"./createlocaltracks":127,"./encodingparameters":133,"./iceserversource/constant":135,"./iceserversource/nts":136,"./localparticipant":138,"./media/track/es5/localaudiotrack":140,"./media/track/es5/localdatatrack":141,"./media/track/es5/localvideotrack":142,"./networkqualityconfiguration":166,"./room":171,"./signaling/v2":184,"./util":236,"./util/cancelablepromise":233,"./util/constants":234,"./util/log":239,"@twilio/webrtc":58,"@twilio/webrtc/lib/util":71}],126:[function(require,module,exports){
+},{"./cancelableroompromise":92,"./createlocaltracks":95,"./encodingparameters":101,"./iceserversource/constant":103,"./iceserversource/nts":104,"./localparticipant":106,"./media/track/es5/localaudiotrack":108,"./media/track/es5/localdatatrack":109,"./media/track/es5/localvideotrack":110,"./networkqualityconfiguration":134,"./room":139,"./signaling/v2":152,"./util":201,"./util/cancelablepromise":198,"./util/constants":199,"./util/log":204,"@twilio/webrtc":24,"@twilio/webrtc/lib/util":37}],94:[function(require,module,exports){
 'use strict';
 
 var defaultCreateLocalTracks = require('./createlocaltracks');
@@ -26725,7 +15107,7 @@
   audio: createLocalAudioTrack,
   video: createLocalVideoTrack
 };
-},{"./createlocaltracks":127,"./util/constants":234}],127:[function(require,module,exports){
+},{"./createlocaltracks":95,"./util/constants":199}],95:[function(require,module,exports){
 'use strict';
 
 var asLocalTrack = require('./util').asLocalTrack;
@@ -26866,7 +15248,7 @@
  */
 
 module.exports = createLocalTracks;
-},{"./media/track/es5/localaudiotrack":140,"./media/track/es5/localdatatrack":141,"./media/track/es5/localvideotrack":142,"./util":236,"./util/constants":234,"./util/log":239,"./webaudio/workaround180748":253,"@twilio/webrtc":58}],128:[function(require,module,exports){
+},{"./media/track/es5/localaudiotrack":108,"./media/track/es5/localdatatrack":109,"./media/track/es5/localvideotrack":110,"./util":201,"./util/constants":199,"./util/log":204,"./webaudio/workaround180748":218,"@twilio/webrtc":24}],96:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -26947,7 +15329,7 @@
  */
 
 module.exports = DataTrackReceiver;
-},{"./transceiver":130,"./transport":131}],129:[function(require,module,exports){
+},{"./transceiver":98,"./transport":99}],97:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -27105,7 +15487,7 @@
 }(DataTrackTransceiver);
 
 module.exports = DataTrackSender;
-},{"../util":236,"./transceiver":130}],130:[function(require,module,exports){
+},{"../util":201,"./transceiver":98}],98:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -27164,7 +15546,7 @@
 }(TrackTransceiver);
 
 module.exports = DataTrackTransceiver;
-},{"../transceiver":230}],131:[function(require,module,exports){
+},{"../transceiver":195}],99:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -27275,7 +15657,7 @@
  */
 
 module.exports = DataTransport;
-},{"events":100}],132:[function(require,module,exports){
+},{"events":67}],100:[function(require,module,exports){
 'use strict';
 
 var request = require('./request');
@@ -27344,7 +15726,7 @@
 }
 
 module.exports.getConfiguration = getConfiguration;
-},{"./request":170,"./util/twilio-video-errors":249}],133:[function(require,module,exports){
+},{"./request":138,"./util/twilio-video-errors":214}],101:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -27451,7 +15833,7 @@
  */
 
 module.exports = EncodingParametersImpl;
-},{"events":100}],134:[function(require,module,exports){
+},{"events":67}],102:[function(require,module,exports){
 'use strict';
 
 var _require = require('events'),
@@ -27461,7 +15843,7 @@
     hidePrivateAndCertainPublicPropertiesInClass = _require2.hidePrivateAndCertainPublicPropertiesInClass;
 
 module.exports = hidePrivateAndCertainPublicPropertiesInClass(EventEmitter, ['domain']);
-},{"./util":236,"events":100}],135:[function(require,module,exports){
+},{"./util":201,"events":67}],103:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -27544,7 +15926,7 @@
 }(EventEmitter);
 
 module.exports = ConstantIceServerSource;
-},{"events":100}],136:[function(require,module,exports){
+},{"events":67}],104:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -27827,7 +16209,7 @@
 }
 
 module.exports = NTSIceServerSource;
-},{"../../package.json":254,"../ecs":132,"../util":236,"../util/constants":234,"../util/log":239,"../util/timeoutpromise":248,"../util/twilio-video-errors":249,"events":100}],137:[function(require,module,exports){
+},{"../../package.json":219,"../ecs":100,"../util":201,"../util/constants":199,"../util/log":204,"../util/timeoutpromise":213,"../util/twilio-video-errors":214,"events":67}],105:[function(require,module,exports){
 'use strict';
 
 var version = require('../package.json').version;
@@ -27873,7 +16255,7 @@
 });
 
 module.exports = Video;
-},{"../package.json":254,"./connect":125,"./createlocaltrack":126,"./createlocaltracks":127,"./media/track/es5/localaudiotrack":140,"./media/track/es5/localdatatrack":141,"./media/track/es5/localvideotrack":142,"./util/support":246}],138:[function(require,module,exports){
+},{"../package.json":219,"./connect":93,"./createlocaltrack":94,"./createlocaltracks":95,"./media/track/es5/localaudiotrack":108,"./media/track/es5/localdatatrack":109,"./media/track/es5/localvideotrack":110,"./util/support":211}],106:[function(require,module,exports){
 'use strict';
 
 var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
@@ -28505,7 +16887,7 @@
 }
 
 module.exports = LocalParticipant;
-},{"./media/track/es5/localaudiotrack":140,"./media/track/es5/localdatatrack":141,"./media/track/es5/localvideotrack":142,"./media/track/localaudiotrackpublication":145,"./media/track/localdatatrackpublication":147,"./media/track/localvideotrackpublication":151,"./participant":167,"./util":236,"./util/constants":234,"@twilio/webrtc":58}],139:[function(require,module,exports){
+},{"./media/track/es5/localaudiotrack":108,"./media/track/es5/localdatatrack":109,"./media/track/es5/localvideotrack":110,"./media/track/localaudiotrackpublication":113,"./media/track/localdatatrackpublication":115,"./media/track/localvideotrackpublication":119,"./participant":135,"./util":201,"./util/constants":199,"@twilio/webrtc":24}],107:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -28686,7 +17068,7 @@
  */
 
 module.exports = AudioTrack;
-},{"./mediatrack":152}],140:[function(require,module,exports){
+},{"./mediatrack":120}],108:[function(require,module,exports){
 // TODO(mroberts): Remove this when we go to the next major version. This is
 // only in place so that we can support ES6 classes without requiring `new`.
 'use strict';
@@ -28705,7 +17087,7 @@
 inherits(LocalAudioTrack, LocalAudioTrackClass);
 
 module.exports = LocalAudioTrack;
-},{"../localaudiotrack":144,"util":258}],141:[function(require,module,exports){
+},{"../localaudiotrack":112,"util":224}],109:[function(require,module,exports){
 // TODO(mroberts): Remove this when we go to the next major version. This is
 // only in place so that we can support ES6 classes without requiring `new`.
 'use strict';
@@ -28724,7 +17106,7 @@
 inherits(LocalDataTrack, LocalDataTrackClass);
 
 module.exports = LocalDataTrack;
-},{"../localdatatrack":146,"util":258}],142:[function(require,module,exports){
+},{"../localdatatrack":114,"util":224}],110:[function(require,module,exports){
 // TODO(mroberts): Remove this when we go to the next major version. This is
 // only in place so that we can support ES6 classes without requiring `new`.
 'use strict';
@@ -28743,7 +17125,7 @@
 inherits(LocalVideoTrack, LocalVideoTrackClass);
 
 module.exports = LocalVideoTrack;
-},{"../localvideotrack":150,"util":258}],143:[function(require,module,exports){
+},{"../localvideotrack":118,"util":224}],111:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -28868,7 +17250,7 @@
  */
 
 module.exports = Track;
-},{"../../eventemitter":134,"../../util":236,"../../util/constants":234,"../../util/log":239}],144:[function(require,module,exports){
+},{"../../eventemitter":102,"../../util":201,"../../util/constants":199,"../../util/log":204}],112:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29017,7 +17399,7 @@
  */
 
 module.exports = LocalAudioTrack;
-},{"./audiotrack":139,"./localmediatrack":148}],145:[function(require,module,exports){
+},{"./audiotrack":107,"./localmediatrack":116}],113:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29066,7 +17448,7 @@
 }(LocalTrackPublication);
 
 module.exports = LocalAudioTrackPublication;
-},{"./localtrackpublication":149}],146:[function(require,module,exports){
+},{"./localtrackpublication":117}],114:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29212,7 +17594,7 @@
  */
 
 module.exports = LocalDataTrack;
-},{"../../data/sender":129,"./":143}],147:[function(require,module,exports){
+},{"../../data/sender":97,"./":111}],115:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29261,7 +17643,7 @@
 }(LocalTrackPublication);
 
 module.exports = LocalDataTrackPublication;
-},{"./localtrackpublication":149}],148:[function(require,module,exports){
+},{"./localtrackpublication":117}],116:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29376,7 +17758,7 @@
 }
 
 module.exports = mixinLocalMediaTrack;
-},{"./sender":162}],149:[function(require,module,exports){
+},{"./sender":130}],117:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29472,7 +17854,7 @@
 }(TrackPublication);
 
 module.exports = LocalTrackPublication;
-},{"./trackpublication":163}],150:[function(require,module,exports){
+},{"./trackpublication":131}],118:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29611,7 +17993,7 @@
  */
 
 module.exports = LocalVideoTrack;
-},{"./localmediatrack":148,"./videotrack":165}],151:[function(require,module,exports){
+},{"./localmediatrack":116,"./videotrack":133}],119:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29660,7 +18042,7 @@
 }(LocalTrackPublication);
 
 module.exports = LocalVideoTrackPublication;
-},{"./localtrackpublication":149}],152:[function(require,module,exports){
+},{"./localtrackpublication":117}],120:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -29954,7 +18336,7 @@
 }(Track);
 
 module.exports = MediaTrack;
-},{"./":143,"@twilio/webrtc":58}],153:[function(require,module,exports){
+},{"./":111,"@twilio/webrtc":24}],121:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -29988,7 +18370,7 @@
 }(MediaTrackTransceiver);
 
 module.exports = MediaTrackReceiver;
-},{"./transceiver":164}],154:[function(require,module,exports){
+},{"./transceiver":132}],122:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30062,7 +18444,7 @@
  */
 
 module.exports = RemoteAudioTrack;
-},{"./audiotrack":139,"./remotemediatrack":158}],155:[function(require,module,exports){
+},{"./audiotrack":107,"./remotemediatrack":126}],123:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30143,7 +18525,7 @@
  */
 
 module.exports = RemoteAudioTrackPublication;
-},{"./remotetrackpublication":159}],156:[function(require,module,exports){
+},{"./remotetrackpublication":127}],124:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30252,7 +18634,7 @@
  */
 
 module.exports = RemoteDataTrack;
-},{"./":143}],157:[function(require,module,exports){
+},{"./":111}],125:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30321,7 +18703,7 @@
  */
 
 module.exports = RemoteDataTrackPublication;
-},{"./remotetrackpublication":159}],158:[function(require,module,exports){
+},{"./remotetrackpublication":127}],126:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30409,7 +18791,7 @@
  */
 
 module.exports = mixinRemoteMediaTrack;
-},{}],159:[function(require,module,exports){
+},{}],127:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30572,7 +18954,7 @@
  */
 
 module.exports = RemoteTrackPublication;
-},{"./trackpublication":163}],160:[function(require,module,exports){
+},{"./trackpublication":131}],128:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30647,7 +19029,7 @@
  */
 
 module.exports = RemoteVideoTrack;
-},{"./remotemediatrack":158,"./videotrack":165}],161:[function(require,module,exports){
+},{"./remotemediatrack":126,"./videotrack":133}],129:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30728,7 +19110,7 @@
  */
 
 module.exports = RemoteVideoTrackPublication;
-},{"./remotetrackpublication":159}],162:[function(require,module,exports){
+},{"./remotetrackpublication":127}],130:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30810,7 +19192,7 @@
 }(MediaTrackTransceiver);
 
 module.exports = MediaTrackSender;
-},{"./transceiver":164}],163:[function(require,module,exports){
+},{"./transceiver":132}],131:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30928,7 +19310,7 @@
  */
 
 module.exports = TrackPublication;
-},{"../../eventemitter":134,"../../util":236,"../../util/constants":234,"../../util/log":239}],164:[function(require,module,exports){
+},{"../../eventemitter":102,"../../util":201,"../../util/constants":199,"../../util/log":204}],132:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -30990,7 +19372,7 @@
 }(TrackTransceiver);
 
 module.exports = MediaTrackTransceiver;
-},{"../../transceiver":230}],165:[function(require,module,exports){
+},{"../../transceiver":195}],133:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -31239,7 +19621,7 @@
  */
 
 module.exports = VideoTrack;
-},{"./mediatrack":152}],166:[function(require,module,exports){
+},{"./mediatrack":120}],134:[function(require,module,exports){
 'use strict';
 
 var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
@@ -31336,7 +19718,7 @@
 }(EventEmitter);
 
 module.exports = NetworkQualityConfigurationImpl;
-},{"./util":236,"./util/constants":234,"events":100}],167:[function(require,module,exports){
+},{"./util":201,"./util/constants":199,"events":67}],135:[function(require,module,exports){
 'use strict';
 
 var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
@@ -31998,7 +20380,7 @@
 }
 
 module.exports = Participant;
-},{"./eventemitter":134,"./media/track/remoteaudiotrack":154,"./media/track/remoteaudiotrackpublication":155,"./media/track/remotedatatrack":156,"./media/track/remotedatatrackpublication":157,"./media/track/remotevideotrack":160,"./media/track/remotevideotrackpublication":161,"./util":236}],168:[function(require,module,exports){
+},{"./eventemitter":102,"./media/track/remoteaudiotrack":122,"./media/track/remoteaudiotrackpublication":123,"./media/track/remotedatatrack":124,"./media/track/remotedatatrackpublication":125,"./media/track/remotevideotrack":128,"./media/track/remotevideotrackpublication":129,"./util":201}],136:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -32094,7 +20476,7 @@
 }(EventEmitter);
 
 module.exports = QueueingEventEmitter;
-},{"events":100}],169:[function(require,module,exports){
+},{"events":67}],137:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -32354,7 +20736,7 @@
  */
 
 module.exports = RemoteParticipant;
-},{"./participant":167}],170:[function(require,module,exports){
+},{"./participant":135}],138:[function(require,module,exports){
 'use strict';
 
 var XHR = require('xmlhttprequest').XMLHttpRequest;
@@ -32407,7 +20789,7 @@
 request.post = request.bind(null, 'POST');
 
 module.exports = request;
-},{"xmlhttprequest":256}],171:[function(require,module,exports){
+},{"xmlhttprequest":221}],139:[function(require,module,exports){
 'use strict';
 
 var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
@@ -32908,7 +21290,7 @@
 }
 
 module.exports = Room;
-},{"./eventemitter":134,"./remoteparticipant":169,"./stats/statsreport":227,"./util":236}],172:[function(require,module,exports){
+},{"./eventemitter":102,"./remoteparticipant":137,"./stats/statsreport":192,"./util":201}],140:[function(require,module,exports){
 /* eslint consistent-return:0 */
 'use strict';
 
@@ -33102,7 +21484,7 @@
 }(StateMachine);
 
 module.exports = Signaling;
-},{"../statemachine":199,"./participant":175,"./room":179}],173:[function(require,module,exports){
+},{"../statemachine":164,"./participant":143,"./room":147}],141:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -33200,7 +21582,7 @@
 }(ParticipantSignaling);
 
 module.exports = LocalParticipantSignaling;
-},{"./participant":175}],174:[function(require,module,exports){
+},{"./participant":143}],142:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -33330,7 +21712,7 @@
 }
 
 module.exports = LocalTrackPublicationSignaling;
-},{"./track":180}],175:[function(require,module,exports){
+},{"./track":148}],143:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -33551,7 +21933,7 @@
  */
 
 module.exports = ParticipantSignaling;
-},{"../statemachine":199,"../stats/networkqualitystats":214}],176:[function(require,module,exports){
+},{"../statemachine":164,"../stats/networkqualitystats":179}],144:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -33636,7 +22018,7 @@
  */
 
 module.exports = RecordingSignaling;
-},{"events":100}],177:[function(require,module,exports){
+},{"events":67}],145:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -33675,7 +22057,7 @@
 }(ParticipantSignaling);
 
 module.exports = RemoteParticipantSignaling;
-},{"./participant":175}],178:[function(require,module,exports){
+},{"./participant":143}],146:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -33761,7 +22143,7 @@
 }(TrackSignaling);
 
 module.exports = RemoteTrackPublicationSignaling;
-},{"./track":180}],179:[function(require,module,exports){
+},{"./track":148}],147:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -34026,7 +22408,7 @@
 }
 
 module.exports = RoomSignaling;
-},{"../statemachine":199,"../util/twilio-video-errors":249,"./recording":176}],180:[function(require,module,exports){
+},{"../statemachine":164,"../util/twilio-video-errors":214,"./recording":144}],148:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -34200,23 +22582,22 @@
  */
 
 module.exports = TrackSignaling;
-},{"events":100}],181:[function(require,module,exports){
+},{"events":67}],149:[function(require,module,exports){
 'use strict';
 
 var CancelablePromise = require('../../util/cancelablepromise');
 var DefaultPeerConnectionManager = require('./peerconnectionmanager');
 var DefaultRoomV2 = require('./room');
-var DefaultTransport = require('./transport');
-var TwilioConnectionTransport = require('./twilioconnectiontransport');
+var DefaultTransport = require('./twilioconnectiontransport');
 var SignalingConnectionDisconnectedError = require('../../util/twilio-video-errors').SignalingConnectionDisconnectedError;
 var SignalingIncomingMessageInvalidError = require('../../util/twilio-video-errors').SignalingIncomingMessageInvalidError;
 var flatMap = require('../../util').flatMap;
 
-function createCancelableRoomSignalingPromise(token, uaOrWsServer, localParticipant, iceServerSource, encodingParameters, preferredCodecs, options) {
+function createCancelableRoomSignalingPromise(token, wsServer, localParticipant, iceServerSource, encodingParameters, preferredCodecs, options) {
   options = Object.assign({
     PeerConnectionManager: DefaultPeerConnectionManager,
     RoomV2: DefaultRoomV2,
-    Transport: options._useTwilioConnection ? TwilioConnectionTransport : DefaultTransport
+    Transport: DefaultTransport
   }, options);
 
   var transport = void 0;
@@ -34270,7 +22651,7 @@
         }, transportOptions);
 
         var Transport = options.Transport;
-        transport = new Transport(options.name, token, localParticipant, peerConnectionManager, uaOrWsServer, transportOptions);
+        transport = new Transport(options.name, token, localParticipant, peerConnectionManager, wsServer, transportOptions);
 
         transport.once('connected', function connected(initialState) {
           if (isCanceled()) {
@@ -34320,7 +22701,7 @@
 }
 
 module.exports = createCancelableRoomSignalingPromise;
-},{"../../util":236,"../../util/cancelablepromise":233,"../../util/twilio-video-errors":249,"./peerconnectionmanager":190,"./room":194,"./transport":196,"./twilioconnectiontransport":197}],182:[function(require,module,exports){
+},{"../../util":201,"../../util/cancelablepromise":198,"../../util/twilio-video-errors":214,"./peerconnectionmanager":158,"./room":162,"./twilioconnectiontransport":163}],150:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -34408,7 +22789,7 @@
  */
 
 module.exports = DominantSpeakerSignaling;
-},{"events":100}],183:[function(require,module,exports){
+},{"events":67}],151:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -34494,7 +22875,7 @@
 }();
 
 module.exports = IceBox;
-},{"../../util/filter":235}],184:[function(require,module,exports){
+},{"../../util/filter":200}],152:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -34505,13 +22886,9 @@
 
 function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
 
-var constants = require('../../util/constants');
 var defaultCreateCancelableRoomSignalingPromise = require('./cancelableroomsignalingpromise');
 var LocalParticipantV2 = require('./localparticipant');
 var Signaling = require('../');
-var SIP = require('../../sip');
-var SIPJSMediaHandler = require('./sipjsmediahandler');
-var util = require('../../util');
 
 /**
  * {@link SignalingV2} implements version 2 of our signaling protocol.
@@ -34529,36 +22906,11 @@
   function SignalingV2(wsServer, options) {
     _classCallCheck(this, SignalingV2);
 
-    var uri = util.makeClientSIPURI();
-
     /* eslint new-cap:0 */
     options = Object.assign({
-      createCancelableRoomSignalingPromise: defaultCreateCancelableRoomSignalingPromise,
-      registrarServer: constants.REGISTRAR_SERVER,
-      UA: SIP.UA
+      createCancelableRoomSignalingPromise: defaultCreateCancelableRoomSignalingPromise
     }, options);
 
-    var debug = options.logLevel === 'debug';
-    var useWssHack = wsServer.startsWith('wss://');
-
-    var UA = options.UA;
-    var ua = options._useTwilioConnection ? null : new UA({
-      autostart: false,
-      log: {
-        builtinEnabled: debug
-      },
-      extraSupported: ['room-signaling', 'timer'],
-      hackAllowUnregisteredOptionTags: true,
-      keepAliveInterval: 30,
-      mediaHandlerFactory: SIPJSMediaHandler.defaultFactory,
-      register: false,
-      registrarServer: options.registrarServer,
-      traceSip: debug,
-      uri: uri,
-      wsServers: wsServer,
-      hackWssInTransport: useWssHack
-    });
-
     var _this = _possibleConstructorReturn(this, (SignalingV2.__proto__ || Object.getPrototypeOf(SignalingV2)).call(this));
 
     Object.defineProperties(_this, {
@@ -34568,9 +22920,6 @@
       _options: {
         value: options
       },
-      _ua: {
-        value: ua
-      },
       _wsServer: {
         value: wsServer
       }
@@ -34584,63 +22933,10 @@
 
 
   _createClass(SignalingV2, [{
-    key: '_close',
-    value: function _close(key) {
-      if (!this._ua) {
-        this.transition('closing', key);
-        this.transition('closed', key);
-        return Promise.resolve(this);
-      }
-      this.transition('closing', key);
-      this._ua.stop();
-      this._ua.transport.disconnect();
-      this.transition('closed', key);
-      return Promise.resolve(this);
-    }
-
-    /**
-     * @private
-     */
-
-  }, {
-    key: '_open',
-    value: function _open(key) {
-      var _this2 = this;
-
-      if (!this._ua) {
-        this.transition('opening', key);
-        this.transition('open', key);
-        return Promise.resolve(this);
-      }
-      var ua = this._ua;
-
-      function startUA() {
-        ua.start();
-      }
-
-      this.transition('opening', key);
-      return util.promiseFromEvents(startUA, ua, 'connected', 'disconnected').then(function () {
-        _this2.transition('open', key);
-        return _this2;
-      }, function () {
-        _this2.transition('closed', key);
-        throw new Error('Open failed');
-      });
-    }
-
-    /**
-     * @private
-     */
-
-  }, {
     key: '_connect',
     value: function _connect(localParticipant, token, iceServerSource, encodingParameters, preferredCodecs, options) {
       options = Object.assign({}, this._options, options);
-
-      var ua = this._ua;
-      var wsServer = this._wsServer;
-
-      return this._createCancelableRoomSignalingPromise.bind(null, token, ua || wsServer, localParticipant, iceServerSource, encodingParameters, preferredCodecs, options);
+      return this._createCancelableRoomSignalingPromise.bind(null, token, this._wsServer, localParticipant, iceServerSource, encodingParameters, preferredCodecs, options);
     }
   }, {
     key: 'createLocalParticipantSignaling',
@@ -34653,7 +22949,7 @@
 }(Signaling);
 
 module.exports = SignalingV2;
-},{"../":172,"../../sip":198,"../../util":236,"../../util/constants":234,"./cancelableroomsignalingpromise":181,"./localparticipant":185,"./sipjsmediahandler":195}],185:[function(require,module,exports){
+},{"../":140,"./cancelableroomsignalingpromise":149,"./localparticipant":153}],153:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -34940,7 +23236,7 @@
  */
 
 module.exports = LocalParticipantV2;
-},{"../localparticipant":173,"./localtrackpublication":186}],186:[function(require,module,exports){
+},{"../localparticipant":141,"./localtrackpublication":154}],154:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -35032,7 +23328,7 @@
  */
 
 module.exports = LocalTrackPublicationV2;
-},{"../../util/twilio-video-errors":249,"../localtrackpublication":174}],187:[function(require,module,exports){
+},{"../../util/twilio-video-errors":214,"../localtrackpublication":142}],155:[function(require,module,exports){
 /* eslint callback-return:0 */
 'use strict';
 
@@ -35210,7 +23506,7 @@
  */
 
 module.exports = NetworkQualityMonitor;
-},{"../../stats/peerconnectionreportfactory":217,"events":100}],188:[function(require,module,exports){
+},{"../../stats/peerconnectionreportfactory":182,"events":67}],156:[function(require,module,exports){
 'use strict';
 
 var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
@@ -35490,7 +23786,7 @@
 }
 
 module.exports = NetworkQualitySignaling;
-},{"../../util/asyncvar":232,"events":100}],189:[function(require,module,exports){
+},{"../../util/asyncvar":197,"events":67}],157:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -36696,7 +24992,7 @@
 }
 
 module.exports = PeerConnectionV2;
-},{"../../data/receiver":128,"../../media/track/receiver":153,"../../statemachine":199,"../../util":236,"../../util/constants":234,"../../util/log":239,"../../util/sdp":240,"../../util/sdp/issue8329":241,"../../util/sdp/trackmatcher/identity":243,"../../util/sdp/trackmatcher/mid":244,"../../util/sdp/trackmatcher/ordered":245,"../../util/twilio-video-errors":249,"./icebox":183,"@twilio/webrtc":58,"@twilio/webrtc/lib/util":71,"@twilio/webrtc/lib/util/sdp":73}],190:[function(require,module,exports){
+},{"../../data/receiver":96,"../../media/track/receiver":121,"../../statemachine":164,"../../util":201,"../../util/constants":199,"../../util/log":204,"../../util/sdp":205,"../../util/sdp/issue8329":206,"../../util/sdp/trackmatcher/identity":208,"../../util/sdp/trackmatcher/mid":209,"../../util/sdp/trackmatcher/ordered":210,"../../util/twilio-video-errors":214,"./icebox":151,"@twilio/webrtc":24,"@twilio/webrtc/lib/util":37,"@twilio/webrtc/lib/util/sdp":39}],158:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -37266,7 +25562,7 @@
 }
 
 module.exports = PeerConnectionManager;
-},{"../../media/track/sender":162,"../../queueingeventemitter":168,"../../util":236,"../../util/twilio-video-errors":249,"../../webaudio/audiocontext":251,"./peerconnection":189,"@twilio/webrtc/lib/util":71}],191:[function(require,module,exports){
+},{"../../media/track/sender":130,"../../queueingeventemitter":136,"../../util":201,"../../util/twilio-video-errors":214,"../../webaudio/audiocontext":216,"./peerconnection":157,"@twilio/webrtc/lib/util":37}],159:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -37334,7 +25630,7 @@
  */
 
 module.exports = RecordingV2;
-},{"../recording":176}],192:[function(require,module,exports){
+},{"../recording":144}],160:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -37454,7 +25750,7 @@
 }(RemoteParticipantSignaling);
 
 module.exports = RemoteParticipantV2;
-},{"../remoteparticipant":177,"./remotetrackpublication":193}],193:[function(require,module,exports){
+},{"../remoteparticipant":145,"./remotetrackpublication":161}],161:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -37512,7 +25808,7 @@
  */
 
 module.exports = RemoteTrackPublicationV2;
-},{"../remotetrackpublication":178}],194:[function(require,module,exports){
+},{"../remotetrackpublication":146}],162:[function(require,module,exports){
 'use strict';
 
 var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
@@ -38270,751 +26566,7 @@
 }
 
 module.exports = RoomV2;
-},{"../../stats/statsreport":227,"../../util":236,"../../util/twilio-video-errors":249,"../room":179,"./dominantspeakersignaling":182,"./networkqualitymonitor":187,"./networkqualitysignaling":188,"./recording":191,"./remoteparticipant":192}],195:[function(require,module,exports){
-'use strict';
-
-var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
-
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
-
-var SIP = require('../../sip');
-
-var SIPJSMediaHandler = function () {
-  function SIPJSMediaHandler(peerConnectionManager, createMessage) {
-    _classCallCheck(this, SIPJSMediaHandler);
-
-    Object.defineProperties(this, {
-      createMessage: {
-        enumerable: true,
-        value: createMessage
-      },
-      peerConnectionManager: {
-        enumerable: true,
-        value: peerConnectionManager
-      }
-    });
-  }
-
-  _createClass(SIPJSMediaHandler, [{
-    key: 'close',
-    value: function close() {
-      this.peerConnectionManager.close();
-    }
-  }, {
-    key: 'getDescription',
-    value: function getDescription() {
-      var connectMessage = Object.assign({
-        /* eslint camelcase:0 */
-        peer_connections: this.peerConnectionManager.getStates()
-      }, this.createMessage());
-      return Promise.resolve({
-        body: JSON.stringify(connectMessage),
-        contentType: 'application/room-signaling+json'
-      });
-    }
-  }, {
-    key: 'hasDescription',
-    value: function hasDescription() {
-      return true;
-    }
-  }, {
-    key: 'hold',
-    value: function hold() {
-      // NOTE(mroberts): We don't use SIP.js's hold functionality.
-    }
-  }, {
-    key: 'isReady',
-    value: function isReady() {
-      // NOTE(mroberts): We don't use SIP.js's isReady functionality.
-      return true;
-    }
-  }, {
-    key: 'isMuted',
-    value: function isMuted() {
-      // NOTE(mroberts): We don't use SIP.js's isMuted functionality.
-      return {
-        audio: false,
-        video: false
-      };
-    }
-  }, {
-    key: 'mute',
-    value: function mute() {
-      // NOTE(mroberts): We don't use SIP.js's mute functionality.
-    }
-  }, {
-    key: 'render',
-    value: function render() {
-      // NOTE(mroberts): We don't use SIP.js's render functionality.
-    }
-  }, {
-    key: 'setDescription',
-    value: function setDescription(message) {
-      var roomState = getRoomState(message);
-      if (roomState) {
-        var peerConnectionStates = roomState.peer_connections;
-        if (peerConnectionStates) {
-          return this.peerConnectionManager.update(peerConnectionStates);
-        }
-      }
-      return Promise.resolve();
-    }
-  }, {
-    key: 'unhold',
-    value: function unhold() {
-      // NOTE(mroberts): We don't use SIP.js's unhold functionality.
-    }
-  }, {
-    key: 'unmute',
-    value: function unmute() {
-      // NOTE(mroberts): We don't use SIP.js's unmute functionality.
-    }
-  }, {
-    key: 'updateIceServers',
-    value: function updateIceServers() {
-      // NOTE(mroberts): We don't use SIP.js's ICE server functionality.
-    }
-  }], [{
-    key: 'defaultFactory',
-    value: function defaultFactory() {
-      // NOTE(mroberts): We don't use SIP.js's defaultFactory functionality.
-    }
-  }]);
-
-  return SIPJSMediaHandler;
-}();
-
-SIPJSMediaHandler.defaultFactory.isSupported = function isSupported() {
-  return SIP.WebRTC.isSupported();
-};
-
-function getRoomState(message) {
-  try {
-    return JSON.parse(message.body);
-  } catch (error) {
-    return null;
-  }
-}
-
-module.exports = SIPJSMediaHandler;
-},{"../../sip":198}],196:[function(require,module,exports){
-'use strict';
-
-var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
-
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
-
-function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
-
-function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
-
-var _require = require('@twilio/webrtc/lib/util/sdp'),
-    getSdpFormat = _require.getSdpFormat;
-
-var constants = require('../../util/constants');
-var packageInfo = require('../../../package.json');
-var InsightsPublisher = require('../../util/insightspublisher');
-var NullInsightsPublisher = require('../../util/insightspublisher/null');
-var SIP = require('../../sip');
-var DefaultSIPJSMediaHandler = require('./sipjsmediahandler');
-var StateMachine = require('../../statemachine');
-
-var _require2 = require('../../util'),
-    createMediaSignalingPayload = _require2.createMediaSignalingPayload,
-    getUserAgent = _require2.getUserAgent,
-    makeServerSIPURI = _require2.makeServerSIPURI,
-    withJitter = _require2.withJitter;
-
-var _require3 = require('../../util/twilio-video-errors'),
-    RoomCompletedError = _require3.RoomCompletedError;
-
-var _require4 = require('../../util/twilio-video-errors'),
-    SignalingConnectionDisconnectedError = _require4.SignalingConnectionDisconnectedError,
-    SignalingConnectionError = _require4.SignalingConnectionError,
-    SignalingConnectionTimeoutError = _require4.SignalingConnectionTimeoutError,
-    SignalingIncomingMessageInvalidError = _require4.SignalingIncomingMessageInvalidError,
-    createTwilioError = _require4.createTwilioError;
-
-var RSP_VERSION = 2;
-var SDK_NAME = packageInfo.name + '.js';
-var SDK_VERSION = packageInfo.version;
-
-/*
-Transport States
-----------------
-
-                      +-----------+
-                      |           |
-                      |  syncing  |---------+
-                      |           |         |
-                      +-----------+         |
-                         ^     |            |
-                         |     |            |
-                         |     v            v
-    +------------+    +-----------+    +--------------+
-    |            |    |           |    |              |
-    | connecting |--->| connected |--->| disconnected |
-    |            |    |           |    |              |
-    +------------+    +-----------+    +--------------+
-             |                              ^
-             |                              |
-             |                              |
-             +------------------------------+
-
-*/
-
-var states = {
-  connecting: ['connected', 'disconnected'],
-  connected: ['disconnected', 'syncing'],
-  syncing: ['connected', 'disconnected'],
-  disconnected: []
-};
-
-/**
- * A {@link Transport} supports sending and receiving Room Signaling Protocol
- * (RSP) messages. It also supports RSP requests, such as Sync and Disconnect.
- * @extends StateMachine
- * @implements MediaSignalingTransport
- * @emits Transport#connected
- * @emits Transport#message
- */
-
-var Transport = function (_StateMachine) {
-  _inherits(Transport, _StateMachine);
-
-  /**
-   * Construct a {@link Transport}.
-   * @param {?string} name
-   * @param {string} accessToken
-   * @param {ParticipantSignaling} localParticipant
-   * @param {PeerConnectionManager} peerConnectionManager
-   * @param {object} ua
-   * @param {object} [options]
-   */
-  function Transport(name, accessToken, localParticipant, peerConnectionManager, ua, options) {
-    _classCallCheck(this, Transport);
-
-    options = Object.assign({
-      InsightsPublisher: InsightsPublisher,
-      NullInsightsPublisher: NullInsightsPublisher,
-      SIPJSMediaHandler: DefaultSIPJSMediaHandler,
-      sdpFormat: getSdpFormat(),
-      userAgent: getUserAgent()
-    }, options);
-
-    var _this = _possibleConstructorReturn(this, (Transport.__proto__ || Object.getPrototypeOf(Transport)).call(this, 'connecting', states));
-
-    var eventPublisherOptions = {};
-    if (options.wsServerInsights) {
-      eventPublisherOptions.gateway = options.wsServerInsights;
-    }
-
-    var EventPublisher = options.insights ? options.InsightsPublisher : options.NullInsightsPublisher;
-    Object.defineProperties(_this, {
-      _eventPublisher: {
-        value: new EventPublisher(accessToken, SDK_NAME, SDK_VERSION, options.environment, options.realm, eventPublisherOptions)
-      },
-      _sdpFormat: {
-        value: options.sdpFormat
-      },
-      _updatesReceived: {
-        value: []
-      },
-      _updatesToSend: {
-        value: []
-      },
-      _userAgent: {
-        value: options.userAgent
-      }
-    });
-
-    Object.defineProperties(_this, {
-      _session: {
-        value: createSession(_this, name, accessToken, localParticipant, peerConnectionManager, ua, options.SIPJSMediaHandler, options.iceServerSourceStatus, options.dominantSpeaker, options.networkQuality)
-      }
-    });
-    setupEventListeners(_this, _this._session, ua);
-    return _this;
-  }
-
-  /**
-   * Disconnect the {@link Transport}. Returns true if calling the method resulted
-   * in disconnection.
-   * @param {TwilioError} [error]
-   * @returns {boolean}
-   */
-
-
-  _createClass(Transport, [{
-    key: 'disconnect',
-    value: function disconnect(error) {
-      if (this.state !== 'disconnected') {
-        this.preempt('disconnected', null, [error]);
-        this._session.terminate({
-          body: JSON.stringify({
-            type: 'disconnect',
-            version: RSP_VERSION
-          }),
-          extraHeaders: ['Content-Type: application/room-signaling+json']
-        });
-        this._eventPublisher.disconnect();
-        return true;
-      }
-      return false;
-    }
-
-    /**
-     * Publish an RSP Update. Returns true if calling the method resulted in
-     * publishing (or eventually publishing) the update.
-     * @param {object} update
-     * @returns {boolean}
-     */
-
-  }, {
-    key: 'publish',
-    value: function publish(update) {
-      update = Object.assign({
-        type: 'update',
-        version: RSP_VERSION
-      }, update);
-      switch (this.state) {
-        case 'connected':
-          publishWithRetries(this, this._session, update);
-          return true;
-        case 'connecting':
-        case 'syncing':
-          this._updatesToSend.push(update);
-          return true;
-        case 'disconnected':
-        default:
-          return false;
-      }
-    }
-
-    /**
-     * Publish (or queue) an event to the Insights gateway.
-     * @param {string} groupName - Event group name
-     * @param {string} eventName - Event name
-     * @param {object} payload - Event payload
-     * @returns {boolean} true if queued or published, false if disconnected from the Insights gateway
-     */
-
-  }, {
-    key: 'publishEvent',
-    value: function publishEvent(groupName, eventName, payload) {
-      return this._eventPublisher.publish(groupName, eventName, payload);
-    }
-
-    /**
-     * Sync the {@link Transport}. Returns true if calling the method resulted in
-     * syncing.
-     * @returns {boolean}
-     */
-
-  }, {
-    key: 'sync',
-    value: function sync() {
-      if (this.state === 'connected') {
-        this.preempt('syncing');
-        this._session.sendReinvite();
-        return true;
-      }
-      return false;
-    }
-  }]);
-
-  return Transport;
-}(StateMachine);
-
-/**
- * @event Transport#connected
- * @param {object} initialState
- */
-
-/**
- * @event Transport#message
- * @param {object} state
- */
-
-function createSession(transport, name, accessToken, localParticipant, peerConnectionManager, ua, SIPJSMediaHandler, iceServerSourceStatus, dominantSpeaker, networkQuality) {
-  var target = 'sip:' + makeServerSIPURI();
-  return ua.invite(target, {
-    extraHeaders: [constants.headers.X_TWILIO_ACCESSTOKEN + ': ' + accessToken, 'Session-Expires: 120'],
-    media: { stream: {} },
-    mediaHandlerFactory: function mediaHandlerFactory() {
-      return new SIPJSMediaHandler(peerConnectionManager, function createMessage() {
-        if (transport.state === 'disconnected') {
-          return {
-            type: 'disconnect',
-            version: RSP_VERSION
-          };
-        }
-        var type = {
-          connecting: 'connect',
-          syncing: 'sync'
-        }[transport.state] || 'update';
-
-        var message = {
-          name: name,
-          participant: localParticipant.getState(),
-          type: type,
-          version: RSP_VERSION
-        };
-
-        if (message.type === 'connect') {
-          message.ice_servers = iceServerSourceStatus;
-          message.publisher = {
-            name: SDK_NAME,
-            sdk_version: SDK_VERSION,
-            user_agent: transport._userAgent
-          };
-          message.media_signaling = createMediaSignalingPayload(dominantSpeaker, networkQuality);
-        }
-
-        var sdpFormat = transport._sdpFormat;
-        if (type === 'connect' && sdpFormat) {
-          message.format = sdpFormat;
-        }
-
-        return message;
-      });
-    },
-    onInfo: function onInfo(request) {
-      this.emit('info', request);
-      request.reply(200);
-    }
-  });
-}
-
-function publishWithRetries(transport, session, payload, attempts) {
-  attempts = attempts || 0;
-  return new Promise(function (resolve, reject) {
-    function receiveResponse(response) {
-      switch (Math.floor(response.status_code / 100)) {
-        case 2:
-          resolve();
-          break;
-        case 5:
-          if (attempts < constants.PUBLISH_MAX_ATTEMPTS) {
-            resolve(publishWithRetries(transport, session, payload, ++attempts));
-          } else {
-            reject(new Error('Transport failed to send a message even after ' + constants.PUBLISH_MAX_ATTEMPTS + ' attempts'));
-          }
-          break;
-        default:
-          reject(response);
-      }
-    }
-    function sendRequest() {
-      if (transport.state === 'disconnected') {
-        return;
-      }
-      session.sendRequest('INFO', {
-        body: JSON.stringify(payload),
-        extraHeaders: ['Content-Type: application/room-signaling+json', 'Event: room-signaling', 'Info-Package: room-signaling'],
-        receiveResponse: receiveResponse
-      });
-    }
-    if (attempts === 0) {
-      sendRequest();
-      return;
-    }
-
-    var backOffMs = (1 << attempts - 1) * constants.PUBLISH_BACKOFF_MS;
-    setTimeout(sendRequest, withJitter(backOffMs, constants.PUBLISH_BACKOFF_JITTER));
-  });
-}
-
-function reducePeerConnections(peerConnections) {
-  return Array.from(peerConnections.reduce(function (peerConnectionsById, update) {
-    var reduced = peerConnectionsById.get(update.id) || update;
-
-    // First, reduce the top-level `description` property.
-    if (!reduced.description && update.description) {
-      reduced.description = update.description;
-    } else if (reduced.description && update.description) {
-      if (update.description.revision > reduced.description.revision) {
-        reduced.description = update.description;
-      }
-    }
-
-    // Then, reduce the top-level `ice` property.
-    if (!reduced.ice && update.ice) {
-      reduced.ice = update.ice;
-    } else if (reduced.ice && update.ice) {
-      if (update.ice.revision > reduced.ice.revision) {
-        reduced.ice = update.ice;
-      }
-    }
-
-    // Finally, update the map.
-    peerConnectionsById.set(reduced.id, reduced);
-
-    return peerConnectionsById;
-  }, new Map()).values());
-}
-
-function reduceUpdates(updates) {
-  return updates.reduce(function (reduced, update) {
-    // First, reduce the top-level `participant` property.
-    if (!reduced.participant && update.participant) {
-      reduced.participant = update.participant;
-    } else if (reduced.participant && update.participant) {
-      if (update.participant.revision > reduced.participant.revision) {
-        reduced.participant = update.participant;
-      }
-    }
-
-    // Then, reduce the top-level `peer_connections` property.
-    /* eslint camelcase:0 */
-    if (!reduced.peer_connections && update.peer_connections) {
-      reduced.peer_connections = reducePeerConnections(update.peer_connections);
-    } else if (reduced.peer_connections && update.peer_connections) {
-      reduced.peer_connections = reducePeerConnections(reduced.peer_connections.concat(update.peer_connections));
-    }
-
-    return reduced;
-  }, {
-    type: 'update',
-    version: RSP_VERSION
-  });
-}
-
-/**
- * Parse the body of a SIP incoming request or response.
- * @param {object} requestOrResponse
- * @returns {?object}
- * @throws {SignalingIncomingMessageInvalidError}
- */
-function parseRequestOrResponseBody(requestOrResponse) {
-  if (requestOrResponse.body) {
-    try {
-      return JSON.parse(requestOrResponse.body);
-    } catch (e) {
-      throw new SignalingIncomingMessageInvalidError();
-    }
-  }
-  return null;
-}
-
-/**
- * Get a {@link TwilioError} for a SIP incoming request or response from its body.
- * @param {object} requestOrResponse
- * @returns {?TwilioError}
- */
-function getTwilioErrorFromRequestOrResponseBody(requestOrResponse) {
-  try {
-    var message = parseRequestOrResponseBody(requestOrResponse);
-    if (message) {
-      switch (message.type) {
-        case 'disconnected':
-          if (message.status === 'completed') {
-            return new RoomCompletedError();
-          }
-          break;
-        case 'error':
-          return createTwilioError(message.code, message.message);
-        default:
-          break;
-      }
-    }
-    return null;
-  } catch (error) {
-    return error;
-  }
-}
-
-/**
- * Get a {@link TwilioError} for a SIP incoming request or response from its headers.
- * @param {object} requestOrResponse
- * @returns {?TwilioError}
- */
-function getTwilioErrorFromRequestOrResponseHeaders(requestOrResponse) {
-  var headers = requestOrResponse.headers;
-  if (headers && headers['X-Twilio-Error']) {
-    var twilioErrorHeader = headers['X-Twilio-Error'][0].raw.split(' ');
-    var code = parseInt(twilioErrorHeader[0], 10);
-    var message = twilioErrorHeader.slice(1).join(' ');
-    return createTwilioError(code, message);
-  }
-  return null;
-}
-
-/**
- * Create a {@link TwilioError} from a SIP request or response.
- * @param {object} requestOrResponse - SIP request or response
- * @returns {?TwilioError}
- */
-function getTwilioErrorFromRequestOrResponse(requestOrResponse) {
-  return getTwilioErrorFromRequestOrResponseHeaders(requestOrResponse) || getTwilioErrorFromRequestOrResponseBody(requestOrResponse);
-}
-
-function setupEventListeners(transport, session, ua) {
-  function disconnect(requestOrResponse, cause) {
-    var twilioError = void 0;
-
-    if (requestOrResponse && !(requestOrResponse instanceof SIP.OutgoingRequest)) {
-      twilioError = getTwilioErrorFromRequestOrResponse(requestOrResponse);
-    }
-
-    if (!twilioError) {
-      switch (cause) {
-        case SIP.C.causes.REQUEST_TIMEOUT:
-          twilioError = new SignalingConnectionTimeoutError();
-          break;
-        case SIP.C.causes.CONNECTION_ERROR:
-          twilioError = new SignalingConnectionError();
-          break;
-        default:
-          twilioError = new SignalingConnectionDisconnectedError();
-      }
-    }
-
-    transport.disconnect(twilioError);
-  }
-
-  function handleRequestOrResponse(requestOrResponse) {
-    // We don't need to handle requests we sent ourselves.
-    if (requestOrResponse instanceof SIP.OutgoingRequest) {
-      return;
-    }
-
-    // Handle any errors first.
-    var error = void 0;
-    try {
-      error = getTwilioErrorFromRequestOrResponse(requestOrResponse);
-    } catch (e) {
-      if (e instanceof SignalingIncomingMessageInvalidError) {
-        return;
-      }
-      error = e;
-    }
-
-    // If we get an error other than a SignalingIncomingMessageInvalidError,
-    // then disconnect.
-    if (error) {
-      transport.disconnect(error);
-      return;
-    }
-
-    // Otherwise, try to parse the RSP message.
-    var message = void 0;
-    try {
-      message = parseRequestOrResponseBody(requestOrResponse);
-    } catch (e) {}
-    // Do nothing.
-
-
-    // If there's no RSP message to handle, just return.
-    if (!message) {
-      return;
-    }
-
-    switch (transport.state) {
-      case 'connected':
-        switch (message.type) {
-          case 'connected':
-          case 'synced':
-          case 'update':
-            transport.emit('message', message);
-            return;
-          case 'disconnected':
-            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);
-            return;
-          default:
-            // Do nothing.
-            return;
-        }
-      case 'connecting':
-        switch (message.type) {
-          case 'connected':
-            transport.emit('connected', message);
-            transport.preempt('connected');
-            return;
-          case 'synced':
-          case 'update':
-            transport._updatesReceived.push(message);
-            return;
-          case 'disconnected':
-            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);
-            return;
-          default:
-            // Do nothing.
-            return;
-        }
-      case 'disconnected':
-        // Do nothing.
-        return;
-      case 'syncing':
-        switch (message.type) {
-          case 'connected':
-          case 'update':
-            transport._updatesReceived.push(message);
-            return;
-          case 'synced':
-            transport.emit('message', message);
-            transport.preempt('connected');
-            return;
-          case 'disconnected':
-            transport.disconnect(message.status === 'completed' ? new RoomCompletedError() : null);
-            return;
-          default:
-            // Do nothing.
-            return;
-        }
-      default:
-        // Impossible
-        return;
-    }
-  }
-
-  session.on('info', handleRequestOrResponse);
-  session.once('bye', disconnect);
-
-  session.once('accepted', handleRequestOrResponse);
-  session.once('failed', disconnect);
-
-  transport.on('stateChanged', function stateChanged(state) {
-    switch (state) {
-      case 'connected':
-        {
-          session.removeListener('accepted', handleRequestOrResponse);
-          session.removeListener('failed', disconnect);
-
-          var updates = transport._updatesToSend.splice(0);
-          if (updates.length) {
-            transport.publish(reduceUpdates(updates));
-          }
-
-          transport._updatesReceived.splice(0).forEach(transport.emit.bind(transport, 'message'));
-
-          return;
-        }
-      case 'disconnected':
-        session.removeListener('accepted', handleRequestOrResponse);
-        session.removeListener('failed', disconnect);
-        session.removeListener('info', handleRequestOrResponse);
-        session.removeListener('bye', disconnect);
-        transport.removeListener('stateChanged', stateChanged);
-        ua.stop();
-        return;
-      case 'syncing':
-        // Do nothing.
-        return;
-      default:
-        // Impossible
-        return;
-    }
-  });
-
-  ua.once('disconnected', disconnect);
-  ua.once('keepAliveTimeout', function () {
-    return transport.disconnect(new SignalingConnectionTimeoutError());
-  });
-}
-
-module.exports = Transport;
-},{"../../../package.json":254,"../../sip":198,"../../statemachine":199,"../../util":236,"../../util/constants":234,"../../util/insightspublisher":237,"../../util/insightspublisher/null":238,"../../util/twilio-video-errors":249,"./sipjsmediahandler":195,"@twilio/webrtc/lib/util/sdp":73}],197:[function(require,module,exports){
+},{"../../stats/statsreport":192,"../../util":201,"../../util/twilio-video-errors":214,"../room":147,"./dominantspeakersignaling":150,"./networkqualitymonitor":155,"./networkqualitysignaling":156,"./recording":159,"./remoteparticipant":160}],163:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -39545,25 +27097,7 @@
 }
 
 module.exports = TwilioConnectionTransport;
-},{"../../../package.json":254,"../../statemachine":199,"../../twilioconnection":231,"../../util":236,"../../util/insightspublisher":237,"../../util/insightspublisher/null":238,"../../util/twilio-video-errors":249,"@twilio/webrtc/lib/util/sdp":73}],198:[function(require,module,exports){
-(function (global){
-'use strict';
-
-var toplevel = global.window || global;
-var Transport = require('@twilio/sip.js/src/Transport');
-var WebSocket = toplevel.WebSocket ? toplevel.WebSocket : require('ws');
-var addEventListener = toplevel.addEventListener ? toplevel.addEventListener.bind(toplevel) : null;
-
-module.exports = require('@twilio/sip.js/src/SIP')({
-  addEventListener: addEventListener,
-  console: toplevel.console,
-  Promise: toplevel.Promise,
-  WebSocket: WebSocket,
-  timers: toplevel,
-  Transport: Transport
-});
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"@twilio/sip.js/src/SIP":40,"@twilio/sip.js/src/Transport":49,"ws":255}],199:[function(require,module,exports){
+},{"../../../package.json":219,"../../statemachine":164,"../../twilioconnection":196,"../../util":201,"../../util/insightspublisher":202,"../../util/insightspublisher/null":203,"../../util/twilio-video-errors":214,"@twilio/webrtc/lib/util/sdp":39}],164:[function(require,module,exports){
 'use strict';
 
 var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
@@ -40065,7 +27599,7 @@
 }
 
 module.exports = StateMachine;
-},{"./util":236,"events":100}],200:[function(require,module,exports){
+},{"./util":201,"events":67}],165:[function(require,module,exports){
 /* eslint no-undefined:0 */
 'use strict';
 
@@ -40084,7 +27618,7 @@
 }
 
 module.exports = average;
-},{}],201:[function(require,module,exports){
+},{}],166:[function(require,module,exports){
 'use strict';
 
 /**
@@ -40155,7 +27689,7 @@
 }();
 
 module.exports = IceReport;
-},{}],202:[function(require,module,exports){
+},{}],167:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -40214,7 +27748,7 @@
 }();
 
 module.exports = IceReportFactory;
-},{"./icereport":201}],203:[function(require,module,exports){
+},{"./icereport":166}],168:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40267,7 +27801,7 @@
  */
 
 module.exports = LocalAudioTrackStats;
-},{"./localtrackstats":204}],204:[function(require,module,exports){
+},{"./localtrackstats":169}],169:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40319,7 +27853,7 @@
 }(TrackStats);
 
 module.exports = LocalTrackStats;
-},{"./trackstats":229}],205:[function(require,module,exports){
+},{"./trackstats":194}],170:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40408,7 +27942,7 @@
 }(LocalTrackStats);
 
 module.exports = LocalVideoTrackStats;
-},{"./localtrackstats":204}],206:[function(require,module,exports){
+},{"./localtrackstats":169}],171:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40440,7 +27974,7 @@
 }(NetworkQualityMediaStats);
 
 module.exports = NetworkQualityAudioStats;
-},{"./networkqualitymediastats":210}],207:[function(require,module,exports){
+},{"./networkqualitymediastats":175}],172:[function(require,module,exports){
 'use strict';
 
 /**
@@ -40484,7 +28018,7 @@
 };
 
 module.exports = NetworkQualityBandwidthStats;
-},{}],208:[function(require,module,exports){
+},{}],173:[function(require,module,exports){
 'use strict';
 
 /**
@@ -40521,7 +28055,7 @@
 };
 
 module.exports = NetworkQualityFractionLostStats;
-},{}],209:[function(require,module,exports){
+},{}],174:[function(require,module,exports){
 'use strict';
 
 /**
@@ -40565,7 +28099,7 @@
 };
 
 module.exports = NetworkQualityLatencyStats;
-},{}],210:[function(require,module,exports){
+},{}],175:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40623,7 +28157,7 @@
 };
 
 module.exports = NetworkQualityMediaStats;
-},{"./networkqualityrecvstats":211,"./networkqualitysendstats":213}],211:[function(require,module,exports){
+},{"./networkqualityrecvstats":176,"./networkqualitysendstats":178}],176:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40656,7 +28190,7 @@
 }(NetworkQualitySendOrRecvStats);
 
 module.exports = NetworkQualityRecvStats;
-},{"./networkqualitysendorrecvstats":212}],212:[function(require,module,exports){
+},{"./networkqualitysendorrecvstats":177}],177:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40707,7 +28241,7 @@
 };
 
 module.exports = NetworkQualitySendOrRecvStats;
-},{"./networkqualitybandwidthstats":207,"./networkqualityfractionloststats":208,"./networkqualitylatencystats":209}],213:[function(require,module,exports){
+},{"./networkqualitybandwidthstats":172,"./networkqualityfractionloststats":173,"./networkqualitylatencystats":174}],178:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40740,7 +28274,7 @@
 }(NetworkQualitySendOrRecvStats);
 
 module.exports = NetworkQualitySendStats;
-},{"./networkqualitysendorrecvstats":212}],214:[function(require,module,exports){
+},{"./networkqualitysendorrecvstats":177}],179:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40788,7 +28322,7 @@
 };
 
 module.exports = NetworkQualityStats;
-},{"./networkqualityaudiostats":206,"./networkqualityvideostats":215}],215:[function(require,module,exports){
+},{"./networkqualityaudiostats":171,"./networkqualityvideostats":180}],180:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -40820,7 +28354,7 @@
 }(NetworkQualityMediaStats);
 
 module.exports = NetworkQualityVideoStats;
-},{"./networkqualitymediastats":210}],216:[function(require,module,exports){
+},{"./networkqualitymediastats":175}],181:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -40919,7 +28453,7 @@
 }();
 
 module.exports = PeerConnectionReport;
-},{"./receiverreport":218,"./senderreport":225}],217:[function(require,module,exports){
+},{"./receiverreport":183,"./senderreport":190}],182:[function(require,module,exports){
 'use strict';
 
 var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
@@ -41447,7 +28981,7 @@
 }
 
 module.exports = PeerConnectionReportFactory;
-},{"./icereportfactory":202,"./peerconnectionreport":216,"./receiverreportfactory":219,"./senderreportfactory":226}],218:[function(require,module,exports){
+},{"./icereportfactory":167,"./peerconnectionreport":181,"./receiverreportfactory":184,"./senderreportfactory":191}],183:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -41595,7 +29129,7 @@
 }(SenderOrReceiverReport);
 
 module.exports = ReceiverReport;
-},{"./average":200,"./senderorreceiverreport":223,"./sum":228}],219:[function(require,module,exports){
+},{"./average":165,"./senderorreceiverreport":188,"./sum":193}],184:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -41661,7 +29195,7 @@
 }(SenderOrReceiverReportFactory);
 
 module.exports = ReceiverReportFactory;
-},{"./receiverreport":218,"./senderorreceiverreportfactory":224}],220:[function(require,module,exports){
+},{"./receiverreport":183,"./senderorreceiverreportfactory":189}],185:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -41708,7 +29242,7 @@
 }(RemoteTrackStats);
 
 module.exports = RemoteAudioTrackStats;
-},{"./remotetrackstats":221}],221:[function(require,module,exports){
+},{"./remotetrackstats":186}],186:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -41755,7 +29289,7 @@
 }(TrackStats);
 
 module.exports = RemoteTrackStats;
-},{"./trackstats":229}],222:[function(require,module,exports){
+},{"./trackstats":194}],187:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -41818,7 +29352,7 @@
 }(RemoteTrackStats);
 
 module.exports = RemoteVideoTrackStats;
-},{"./remotetrackstats":221}],223:[function(require,module,exports){
+},{"./remotetrackstats":186}],188:[function(require,module,exports){
 'use strict';
 
 /**
@@ -41856,7 +29390,7 @@
 };
 
 module.exports = SenderOrReceiverReport;
-},{}],224:[function(require,module,exports){
+},{}],189:[function(require,module,exports){
 'use strict';
 
 /**
@@ -41896,7 +29430,7 @@
 };
 
 module.exports = SenderOrReceiverReportFactory;
-},{}],225:[function(require,module,exports){
+},{}],190:[function(require,module,exports){
 /* eslint no-undefined:0 */
 'use strict';
 
@@ -41996,7 +29530,7 @@
 }(SenderOrReceiverReport);
 
 module.exports = SenderReport;
-},{"./average":200,"./senderorreceiverreport":223,"./sum":228}],226:[function(require,module,exports){
+},{"./average":165,"./senderorreceiverreport":188,"./sum":193}],191:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -42062,7 +29596,7 @@
 }(SenderOrReceiverReportFactory);
 
 module.exports = SenderReportFactory;
-},{"./senderorreceiverreportfactory":224,"./senderreport":225}],227:[function(require,module,exports){
+},{"./senderorreceiverreportfactory":189,"./senderreport":190}],192:[function(require,module,exports){
 'use strict';
 
 function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
@@ -42126,7 +29660,7 @@
 };
 
 module.exports = StatsReport;
-},{"./localaudiotrackstats":203,"./localvideotrackstats":205,"./remoteaudiotrackstats":220,"./remotevideotrackstats":222}],228:[function(require,module,exports){
+},{"./localaudiotrackstats":168,"./localvideotrackstats":170,"./remoteaudiotrackstats":185,"./remotevideotrackstats":187}],193:[function(require,module,exports){
 'use strict';
 
 /**
@@ -42141,7 +29675,7 @@
 }
 
 module.exports = sum;
-},{}],229:[function(require,module,exports){
+},{}],194:[function(require,module,exports){
 'use strict';
 
 /**
@@ -42201,7 +29735,7 @@
 };
 
 module.exports = TrackStats;
-},{}],230:[function(require,module,exports){
+},{}],195:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -42271,7 +29805,7 @@
  */
 
 module.exports = TrackTransceiver;
-},{"events":100}],231:[function(require,module,exports){
+},{"events":67}],196:[function(require,module,exports){
 (function (global){
 'use strict';
 
@@ -42803,7 +30337,7 @@
 
 module.exports = TwilioConnection;
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./statemachine":199,"./util":236,"./util/log":239,"./util/timeout":247,"ws":255}],232:[function(require,module,exports){
+},{"./statemachine":164,"./util":201,"./util/log":204,"./util/timeout":212,"ws":220}],197:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -42891,7 +30425,7 @@
 }();
 
 module.exports = AsyncVar;
-},{"./":236}],233:[function(require,module,exports){
+},{"./":201}],198:[function(require,module,exports){
 'use strict';
 
 /**
@@ -43039,27 +30573,13 @@
 }();
 
 module.exports = CancelablePromise;
-},{}],234:[function(require,module,exports){
+},{}],199:[function(require,module,exports){
 'use strict';
 
 module.exports.DEFAULT_ENVIRONMENT = 'prod';
 module.exports.DEFAULT_REALM = 'us1';
 module.exports.DEFAULT_LOG_LEVEL = 'warn';
-module.exports.REGISTRAR_SERVER = 'endpoint.twilio.com';
-module.exports.WS_SERVER = function (environment, realm) {
-  switch (environment) {
-    case 'prod':
-      switch (realm) {
-        case 'us1':
-          return 'wss://endpoint.twilio.com';
-        default:
-          return 'wss://endpoint.' + realm + '.twilio.com';
-      }
-    default:
-      return 'wss://endpoint.' + environment + '-' + realm + '.twilio.com';
-  }
-};
-module.exports.WS_SERVER_TWILIOCONNECTION = function (environment) {
+module.exports.WS_SERVER = function (environment) {
   return environment === 'prod' ? 'wss://global.vss.twilio.com/signaling' : 'wss://global.vss.' + environment + '.twilio.com/signaling';
 };
 module.exports.ECS_SERVER = function (environment, realm) {
@@ -43119,7 +30639,7 @@
 module.exports.DEFAULT_NQ_LEVEL_LOCAL = 1;
 module.exports.DEFAULT_NQ_LEVEL_REMOTE = 0;
 module.exports.MAX_NQ_LEVEL = 3;
-},{}],235:[function(require,module,exports){
+},{}],200:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -43184,7 +30704,7 @@
 }();
 
 module.exports = Filter;
-},{}],236:[function(require,module,exports){
+},{}],201:[function(require,module,exports){
 'use strict';
 
 var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
@@ -43330,24 +30850,6 @@
   return typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent : 'Unknown';
 }
 
-/**
- * Construct the SIP URI for a client.
- * @returns {string}
- */
-function makeClientSIPURI() {
-  /* eslint new-cap:0 */
-  return makeUUID() + '@' + constants.REGISTRAR_SERVER;
-}
-
-/**
- * Construct the SIP URI for the server.
- * @returns {string}
- */
-function makeServerSIPURI() {
-  /* eslint new-cap:0 */
-  return 'orchestrator@' + constants.REGISTRAR_SERVER;
-}
-
 function makeUUID() {
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
     var r = Math.random() * 16 | 0;
@@ -43608,6 +31110,7 @@
  */
 function validateLocalTrack(track, options) {
   if (!(track instanceof options.LocalAudioTrack || track instanceof options.LocalDataTrack || track instanceof options.LocalVideoTrack || track instanceof options.MediaStreamTrack)) {
+    /* eslint new-cap:0 */
     throw constants.typeErrors.INVALID_TYPE('track', 'LocalAudioTrack, LocalVideoTrack, LocalDataTrack, or MediaStreamTrack');
   }
 }
@@ -43809,8 +31312,6 @@
 exports.hidePrivateProperties = hidePrivateProperties;
 exports.hidePrivateAndCertainPublicPropertiesInClass = hidePrivateAndCertainPublicPropertiesInClass;
 exports.inRange = inRange;
-exports.makeClientSIPURI = makeClientSIPURI;
-exports.makeServerSIPURI = makeServerSIPURI;
 exports.makeUUID = makeUUID;
 exports.oncePerTick = oncePerTick;
 exports.promiseFromEvents = promiseFromEvents;
@@ -43825,7 +31326,7 @@
 exports.validateLocalTrack = validateLocalTrack;
 exports.valueToJSON = valueToJSON;
 exports.withJitter = withJitter;
-},{"./constants":234}],237:[function(require,module,exports){
+},{"./constants":199}],202:[function(require,module,exports){
 (function (global){
 'use strict';
 
@@ -44115,7 +31616,7 @@
 
 module.exports = InsightsPublisher;
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"..":236,"events":100,"ws":255}],238:[function(require,module,exports){
+},{"..":201,"events":67,"ws":220}],203:[function(require,module,exports){
 // TODO(mroberts): This should be described as implementing some
 // InsightsPublisher interface.
 'use strict';
@@ -44172,7 +31673,7 @@
 }();
 
 module.exports = InsightsPublisher;
-},{}],239:[function(require,module,exports){
+},{}],204:[function(require,module,exports){
 /* eslint new-cap:0, no-console:0 */
 'use strict';
 
@@ -44474,7 +31975,7 @@
 }
 
 module.exports = Log;
-},{"./constants":234}],240:[function(require,module,exports){
+},{"./constants":199}],205:[function(require,module,exports){
 'use strict';
 
 var difference = require('../').difference;
@@ -44741,7 +32242,7 @@
 exports.setBitrateParameters = setBitrateParameters;
 exports.setCodecPreferences = setCodecPreferences;
 exports.setSimulcast = setSimulcast;
-},{"../":236,"./simulcast":242}],241:[function(require,module,exports){
+},{"../":201,"./simulcast":207}],206:[function(require,module,exports){
 'use strict';
 
 var RTCSessionDescription = require('@twilio/webrtc').RTCSessionDescription;
@@ -44956,7 +32457,7 @@
 }
 
 module.exports = workaround;
-},{"./":240,"@twilio/webrtc":58}],242:[function(require,module,exports){
+},{"./":205,"@twilio/webrtc":24}],207:[function(require,module,exports){
 'use strict';
 
 var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
@@ -45294,7 +32795,7 @@
  */
 
 module.exports = setSimulcastInMediaSection;
-},{"../":236}],243:[function(require,module,exports){
+},{"../":201}],208:[function(require,module,exports){
 'use strict';
 
 /**
@@ -45337,7 +32838,7 @@
 }();
 
 module.exports = IdentityTrackMatcher;
-},{}],244:[function(require,module,exports){
+},{}],209:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -45402,7 +32903,7 @@
 }();
 
 module.exports = MIDTrackMatcher;
-},{"../":240}],245:[function(require,module,exports){
+},{"../":205}],210:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -45544,7 +33045,7 @@
 }();
 
 module.exports = OrderedTrackMatcher;
-},{"../":240,"../../":236}],246:[function(require,module,exports){
+},{"../":205,"../../":201}],211:[function(require,module,exports){
 /* globals RTCPeerConnection, webkitRTCPeerConnection, mozRTCPeerConnection, navigator */
 'use strict';
 
@@ -45578,7 +33079,7 @@
 }
 
 module.exports = isSupported;
-},{"@twilio/webrtc/lib/util":71}],247:[function(require,module,exports){
+},{"@twilio/webrtc/lib/util":37}],212:[function(require,module,exports){
 'use strict';
 
 /**
@@ -45666,7 +33167,7 @@
 }();
 
 module.exports = Timeout;
-},{}],248:[function(require,module,exports){
+},{}],213:[function(require,module,exports){
 'use strict';
 
 var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
@@ -45827,7 +33328,7 @@
  */
 
 module.exports = TimeoutPromise;
-},{"./":236,"events":100}],249:[function(require,module,exports){
+},{"./":201,"events":67}],214:[function(require,module,exports){
 'use strict';
 
 // NOTE: Do not edit this file. This code is auto-generated. Contact the
@@ -47027,7 +34528,7 @@
 
 exports.ConfigurationAcquireTurnFailedError = ConfigurationAcquireTurnFailedError;
 Object.defineProperty(TwilioErrorByCode, 53501, { value: ConfigurationAcquireTurnFailedError });
-},{"./twilioerror":250}],250:[function(require,module,exports){
+},{"./twilioerror":215}],215:[function(require,module,exports){
 'use strict';
 
 /**
@@ -47099,7 +34600,7 @@
 }(Error);
 
 module.exports = TwilioError;
-},{}],251:[function(require,module,exports){
+},{}],216:[function(require,module,exports){
 /* globals webkitAudioContext, AudioContext */
 'use strict';
 
@@ -47198,7 +34699,7 @@
 }();
 
 module.exports = new AudioContextFactory();
-},{}],252:[function(require,module,exports){
+},{}],217:[function(require,module,exports){
 'use strict';
 
 /**
@@ -47261,7 +34762,7 @@
 }
 
 module.exports = detectSilence;
-},{}],253:[function(require,module,exports){
+},{}],218:[function(require,module,exports){
 'use strict';
 
 var detectSilence = require('./detectsilence');
@@ -47334,64 +34835,30 @@
 }
 
 module.exports = workaround;
-},{"./audiocontext":251,"./detectsilence":252}],254:[function(require,module,exports){
+},{"./audiocontext":216,"./detectsilence":217}],219:[function(require,module,exports){
 module.exports={
-  "_args": [
-    [
-      "twilio-video@2.0.0-beta8",
-      "/Users/vsmoliy/Desktop/xys-vsp-be-video"
-    ]
-  ],
-  "_from": "twilio-video@2.0.0-beta8",
-  "_id": "twilio-video@2.0.0-beta8",
-  "_inBundle": false,
-  "_integrity": "sha512-5qU/mfL6XzqduvwuztlbXQr6UqUAn5T2tRuIX2nO+otD8FbJd53EpDJY3KSo4V4vyDEGW424gAgD+ahwtW56ig==",
-  "_location": "/twilio-video",
-  "_phantomChildren": {},
-  "_requested": {
-    "type": "version",
-    "registry": true,
-    "raw": "twilio-video@2.0.0-beta8",
-    "name": "twilio-video",
-    "escapedName": "twilio-video",
-    "rawSpec": "2.0.0-beta8",
-    "saveSpec": null,
-    "fetchSpec": "2.0.0-beta8"
-  },
-  "_requiredBy": [
-    "/"
-  ],
-  "_resolved": "https://registry.npmjs.org/twilio-video/-/twilio-video-2.0.0-beta8.tgz",
-  "_spec": "2.0.0-beta8",
-  "_where": "/Users/vsmoliy/Desktop/xys-vsp-be-video",
-  "author": {
-    "name": "Mark Andrus Roberts",
-    "email": "mroberts@twilio.com"
-  },
-  "browser": {
-    "ws": "./src/ws.js",
-    "xmlhttprequest": "./src/xmlhttprequest.js"
-  },
-  "bugs": {
-    "url": "https://github.com/twilio/twilio-video.js/issues"
-  },
+  "name": "twilio-video",
+  "title": "Twilio Video",
+  "description": "Twilio Video JavaScript library",
+  "version": "2.0.0-beta9",
+  "homepage": "https://twilio.com",
+  "author": "Mark Andrus Roberts <mroberts@twilio.com>",
   "contributors": [
-    {
-      "name": "Ryan Rowland",
-      "email": "rrowland@twilio.com"
-    },
-    {
-      "name": "Manjesh Malavalli",
-      "email": "mmalavalli@twilio.com"
-    }
+    "Ryan Rowland <rrowland@twilio.com>",
+    "Manjesh Malavalli <mmalavalli@twilio.com>"
   ],
-  "dependencies": {
-    "@twilio/sip.js": "^0.7.7",
-    "@twilio/webrtc": "4.0.0",
-    "ws": "^3.3.1",
-    "xmlhttprequest": "^1.8.0"
+  "keywords": [
+    "twilio",
+    "webrtc",
+    "library",
+    "javascript",
+    "video",
+    "rooms"
+  ],
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/twilio/twilio-video.js.git"
   },
-  "description": "Twilio Video JavaScript library",
   "devDependencies": {
     "@types/express": "^4.11.0",
     "@types/node": "^8.5.1",
@@ -47437,86 +34904,104 @@
   "engines": {
     "node": ">=0.12"
   },
-  "homepage": "https://twilio.com",
-  "keywords": [
-    "twilio",
-    "webrtc",
-    "library",
-    "javascript",
-    "video",
-    "rooms"
-  ],
   "license": "BSD-3-Clause",
   "main": "./es5/index.js",
-  "name": "twilio-video",
-  "repository": {
-    "type": "git",
-    "url": "git+https://github.com/twilio/twilio-video.js.git"
-  },
   "scripts": {
-    "build": "npm-run-all clean lint docs cover test:integration build:es5 build:js build:min.js test:umd",
-    "build:es5": "rimraf ./es5 && babel lib -d es5",
-    "build:js": "node ./scripts/build.js ./src/twilio-video.js ./LICENSE.md ./dist/twilio-video.js",
-    "build:min.js": "uglifyjs ./dist/twilio-video.js -o ./dist/twilio-video.min.js --comments \"/^! twilio-video.js/\" -b beautify=false,ascii_only=true",
-    "build:quick": "npm-run-all clean lint docs build:es5 build:js build:min.js",
-    "build:travis": "npm-run-all clean lint docs cover test:integration:travis build:es5 build:js build:min.js test:umd test:framework",
-    "clean": "rimraf ./coverage ./es5 ./dist",
-    "cover": "istanbul cover node_modules/mocha/bin/_mocha -- ./test/unit/index.js",
-    "docs": "node ./scripts/docs.js ./dist/docs",
     "lint": "eslint ./lib ./test/*.js ./test/framework/*.js ./test/lib/*.js ./test/integration/** ./test/unit/**",
-    "test": "npm-run-all test:unit test:integration",
-    "test:crossbrowser": "npm-run-all test:crossbrowser:*",
-    "test:crossbrowser:build": "npm-run-all test:crossbrowser:build:*",
-    "test:crossbrowser:build:browser": "cd ./test/crossbrowser && browserify lib/crossbrowser/src/browser/index.js > src/browser/index.js",
+    "test:unit": "mocha ./test/unit/index.js",
+    "test:integration:adapter": "node ./scripts/karma.js karma/integration.adapter.conf.js",
+    "test:integration:travis": "node ./scripts/integration.js",
+    "test:integration": "node ./scripts/karma.js karma/integration.conf.js",
+    "test:umd": "mocha ./test/umd/index.js",
     "test:crossbrowser:build:clean": "rimraf ./test/crossbrowser/lib ./test/crossbrowser/src/browser/index.js",
     "test:crossbrowser:build:lint": "cd ./test/crossbrowser && tslint --project tsconfig.json",
     "test:crossbrowser:build:tsc": "cd ./test/crossbrowser && tsc",
+    "test:crossbrowser:build:browser": "cd ./test/crossbrowser && browserify lib/crossbrowser/src/browser/index.js > src/browser/index.js",
+    "test:crossbrowser:build": "npm-run-all test:crossbrowser:build:*",
     "test:crossbrowser:test": "cd ./test/crossbrowser && mocha --compilers ts:ts-node/register test/integration/spec/**/*.ts",
-    "test:framework": "npm-run-all test:framework:angular test:framework:no-framework test:framework:react",
-    "test:framework:angular": "npm-run-all test:framework:angular:*",
-    "test:framework:angular:install": "cd ./test/framework/twilio-video-angular && rimraf ./node_modules && npm install",
-    "test:framework:angular:run": "mocha ./test/framework/twilio-video-angular.js",
-    "test:framework:no-framework": "npm-run-all test:framework:no-framework:*",
-    "test:framework:no-framework:run": "mocha ./test/framework/twilio-video-no-framework.js",
-    "test:framework:react": "npm-run-all test:framework:react:*",
-    "test:framework:react:build": "cd ./test/framework/twilio-video-react && npm run build",
-    "test:framework:react:install": "cd ./test/framework/twilio-video-react && rimraf ./node_modules && npm install",
-    "test:framework:react:run": "mocha ./test/framework/twilio-video-react.js",
-    "test:framework:react:test": "node ./scripts/framework.js twilio-video-react",
-    "test:integration": "node ./scripts/karma.js karma/integration.conf.js",
-    "test:integration:adapter": "node ./scripts/karma.js karma/integration.adapter.conf.js",
-    "test:integration:travis": "node ./scripts/integration.js",
-    "test:sdkdriver": "npm-run-all test:sdkdriver:*",
-    "test:sdkdriver:build": "npm-run-all test:sdkdriver:build:*",
+    "test:crossbrowser": "npm-run-all test:crossbrowser:*",
     "test:sdkdriver:build:clean": "rimraf ./test/lib/sdkdriver/lib ./test/lib/sdkdriver/test/integration/browser/index.js",
     "test:sdkdriver:build:lint": "cd ./test/lib/sdkdriver && tslint --project tsconfig.json",
     "test:sdkdriver:build:tsc": "cd ./test/lib/sdkdriver && tsc --rootDir src",
-    "test:sdkdriver:test": "npm-run-all test:sdkdriver:test:*",
-    "test:sdkdriver:test:integration": "npm-run-all test:sdkdriver:test:integration:*",
+    "test:sdkdriver:build": "npm-run-all test:sdkdriver:build:*",
+    "test:sdkdriver:test:unit": "cd ./test/lib/sdkdriver && mocha --compilers ts:ts-node/register test/unit/spec/**/*.ts",
     "test:sdkdriver:test:integration:browser": "cd ./test/lib/sdkdriver/test/integration && browserify browser/browser.js > browser/index.js",
     "test:sdkdriver:test:integration:run": "cd ./test/lib/sdkdriver && mocha --compilers ts:ts-node/register test/integration/spec/**/*.ts",
-    "test:sdkdriver:test:unit": "cd ./test/lib/sdkdriver && mocha --compilers ts:ts-node/register test/unit/spec/**/*.ts",
-    "test:umd": "mocha ./test/umd/index.js",
-    "test:unit": "mocha ./test/unit/index.js"
+    "test:sdkdriver:test:integration": "npm-run-all test:sdkdriver:test:integration:*",
+    "test:sdkdriver:test": "npm-run-all test:sdkdriver:test:*",
+    "test:sdkdriver": "npm-run-all test:sdkdriver:*",
+    "test:framework:angular:install": "cd ./test/framework/twilio-video-angular && rimraf ./node_modules && npm install",
+    "test:framework:angular:run": "mocha ./test/framework/twilio-video-angular.js",
+    "test:framework:angular": "npm-run-all test:framework:angular:*",
+    "test:framework:no-framework:run": "mocha ./test/framework/twilio-video-no-framework.js",
+    "test:framework:no-framework": "npm-run-all test:framework:no-framework:*",
+    "test:framework:react:install": "cd ./test/framework/twilio-video-react && rimraf ./node_modules && npm install",
+    "test:framework:react:test": "node ./scripts/framework.js twilio-video-react",
+    "test:framework:react:build": "cd ./test/framework/twilio-video-react && npm run build",
+    "test:framework:react:run": "mocha ./test/framework/twilio-video-react.js",
+    "test:framework:react": "npm-run-all test:framework:react:*",
+    "test:framework": "npm-run-all test:framework:angular test:framework:no-framework test:framework:react",
+    "test": "npm-run-all test:unit test:integration",
+    "build:es5": "rimraf ./es5 && babel lib -d es5",
+    "build:js": "node ./scripts/build.js ./src/twilio-video.js ./LICENSE.md ./dist/twilio-video.js",
+    "build:min.js": "uglifyjs ./dist/twilio-video.js -o ./dist/twilio-video.min.js --comments \"/^! twilio-video.js/\" -b beautify=false,ascii_only=true",
+    "build": "npm-run-all clean lint docs cover test:integration build:es5 build:js build:min.js test:umd",
+    "build:travis": "npm-run-all clean lint docs cover test:integration:travis build:es5 build:js build:min.js test:umd test:framework",
+    "build:quick": "npm-run-all clean lint docs build:es5 build:js build:min.js",
+    "docs": "node ./scripts/docs.js ./dist/docs",
+    "clean": "rimraf ./coverage ./es5 ./dist",
+    "cover": "istanbul cover node_modules/mocha/bin/_mocha -- ./test/unit/index.js"
+  },
+  "dependencies": {
+    "@twilio/webrtc": "4.0.0",
+    "ws": "^3.3.1",
+    "xmlhttprequest": "^1.8.0"
   },
-  "title": "Twilio Video",
-  "version": "2.0.0-beta8"
+  "browser": {
+    "ws": "./src/ws.js",
+    "xmlhttprequest": "./src/xmlhttprequest.js"
+  }
 }
 
-},{}],255:[function(require,module,exports){
+},{}],220:[function(require,module,exports){
 module.exports = WebSocket;
 
-},{}],256:[function(require,module,exports){
+},{}],221:[function(require,module,exports){
 exports.XMLHttpRequest = XMLHttpRequest;
 
-},{}],257:[function(require,module,exports){
+},{}],222:[function(require,module,exports){
+if (typeof Object.create === 'function') {
+  // implementation from standard node.js 'util' module
+  module.exports = function inherits(ctor, superCtor) {
+    ctor.super_ = superCtor
+    ctor.prototype = Object.create(superCtor.prototype, {
+      constructor: {
+        value: ctor,
+        enumerable: false,
+        writable: true,
+        configurable: true
+      }
+    });
+  };
+} else {
+  // old school shim for old browsers
+  module.exports = function inherits(ctor, superCtor) {
+    ctor.super_ = superCtor
+    var TempCtor = function () {}
+    TempCtor.prototype = superCtor.prototype
+    ctor.prototype = new TempCtor()
+    ctor.prototype.constructor = ctor
+  }
+}
+
+},{}],223:[function(require,module,exports){
 module.exports = function isBuffer(arg) {
   return arg && typeof arg === 'object'
     && typeof arg.copy === 'function'
     && typeof arg.fill === 'function'
     && typeof arg.readUInt8 === 'function';
 }
-},{}],258:[function(require,module,exports){
+},{}],224:[function(require,module,exports){
 (function (process,global){
 // Copyright Joyent, Inc. and other Node contributors.
 //
@@ -48106,7 +35591,7 @@
 }
 
 }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./support/isBuffer":257,"_process":110,"inherits":105}],259:[function(require,module,exports){
+},{"./support/isBuffer":223,"_process":75,"inherits":222}],225:[function(require,module,exports){
 'use strict';
 
 var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
@@ -48176,7 +35661,7 @@
 yeast.decode = decode;
 module.exports = yeast;
 
-},{}],260:[function(require,module,exports){
+},{}],226:[function(require,module,exports){
 /* eslint-disable no-use-before-define, no-console, no-undef */
 
 const Video = require('twilio-video');
@@ -48496,4 +35981,4 @@
   document.querySelector('.power-off-display').style.display = 'none';
 }
 
-},{"@aspnet/signalr":21,"socket.io-client":111,"twilio-video":137}]},{},[260]);
+},{"@aspnet/signalr":21,"socket.io-client":76,"twilio-video":105}]},{},[226]);
Index: src/services/rooms/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const CustomersRoom = require('./CustomersRoom');\nconst OperatorsRoom = require('./OperatorsRoom');\n\nconst RoomMediator = require('./roomMediator');\n\nconst roomMediator = new RoomMediator();\n\nconst createCustomersRoom = io => new CustomersRoom(io, roomMediator);\nconst createOperatorsRoom = io => new OperatorsRoom(io, roomMediator);\n\nexports.createCustomersRoom = createCustomersRoom;\nexports.createOperatorsRoom = createOperatorsRoom;\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/services/rooms/index.js	(date 1566483545000)
+++ src/services/rooms/index.js	(date 1566563574000)
@@ -1,9 +1,9 @@
 const CustomersRoom = require('./CustomersRoom');
 const OperatorsRoom = require('./OperatorsRoom');
 
-const RoomMediator = require('./roomMediator');
+const RoomsMediator = require('./RoomsMediator');
 
-const roomMediator = new RoomMediator();
+const roomMediator = new RoomsMediator();
 
 const createCustomersRoom = io => new CustomersRoom(io, roomMediator);
 const createOperatorsRoom = io => new OperatorsRoom(io, roomMediator);
Index: src/services/rooms/roomMediator.js
===================================================================
--- src/services/rooms/roomMediator.js	(date 1566483545000)
+++ src/services/rooms/RoomsMediator.js	(date 1566563144000)
@@ -1,5 +1,5 @@
 const EventEmitter = require('events').EventEmitter;
 
-class RoomMediator extends EventEmitter {}
+class RoomsMediator extends EventEmitter {}
 
-module.exports = RoomMediator;
+module.exports = RoomsMediator;
